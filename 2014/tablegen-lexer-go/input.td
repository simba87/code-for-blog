//==--- DiagnosticSemaKinds.td - libsema diagnostics ----------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// Semantic Analysis
//===----------------------------------------------------------------------===//

let Component = "Sema" in {
let CategoryName = "Semantic Issue" in {

// For loop analysis
def warn_variables_not_in_loop_body : Warning<
  "variable%select{s| %1|s %1 and %2|s %1, %2, and %3|s %1, %2, %3, and %4}0 "
  "used in loop condition not modified in loop body">,
  InGroup<DiagGroup<"loop-analysis">>, DefaultIgnore;

def warn_duplicate_enum_values : Warning<
  "element %0 has been implicitly assigned %1 which another element has "
  "been assigned">, InGroup<DiagGroup<"duplicate-enum">>, DefaultIgnore;
def note_duplicate_element : Note<"element %0 also has value %1">;

// Constant expressions
def err_expr_not_ice : Error<
  "expression is not an %select{integer|integral}0 constant expression">;
def ext_expr_not_ice : Extension<
  "expression is not an %select{integer|integral}0 constant expression; "
  "folding it to a constant is a GNU extension">, InGroup<GNU>;
def err_typecheck_converted_constant_expression : Error<
  "value of type %0 is not implicitly convertible to %1">;
def err_typecheck_converted_constant_expression_disallowed : Error<
  "conversion from %0 to %1 is not allowed in a converted constant expression">;
def err_expr_not_cce : Error<
  "%select{case value|enumerator value|non-type template argument|array size}0 "
  "is not a constant expression">;
def err_cce_narrowing : ExtWarn<
  "%select{case value|enumerator value|non-type template argument|array size}0 "
  "%select{cannot be narrowed from type %2 to %3|"
  "evaluates to %2, which cannot be narrowed to type %3}1">,
  InGroup<CXX11Narrowing>, DefaultError;
def err_cce_narrowing_sfinae : Error<
  "%select{case value|enumerator value|non-type template argument|array size}0 "
  "%select{cannot be narrowed from type %2 to %3|"
  "evaluates to %2, which cannot be narrowed to type %3}1">;
def err_ice_not_integral : Error<
  "integral constant expression must have integral or unscoped enumeration "
  "type, not %0">;
def err_ice_incomplete_type : Error<
  "integral constant expression has incomplete class type %0">;
def err_ice_explicit_conversion : Error<
  "integral constant expression requires explicit conversion from %0 to %1">;
def note_ice_conversion_here : Note<
  "conversion to %select{integral|enumeration}0 type %1 declared here">;
def err_ice_ambiguous_conversion : Error<
  "ambiguous conversion from type %0 to an integral or unscoped "
  "enumeration type">;

// Semantic analysis of constant literals.
def ext_predef_outside_function : Warning<
  "predefined identifier is only valid inside function">,
  InGroup<DiagGroup<"predefined-identifier-outside-function">>;
def warn_float_overflow : Warning<
  "magnitude of floating-point constant too large for type %0; maximum is %1">,
   InGroup<LiteralRange>;
def warn_float_underflow : Warning<
  "magnitude of floating-point constant too small for type %0; minimum is %1">,
  InGroup<LiteralRange>;
def warn_double_const_requires_fp64 : Warning<
  "double precision constant requires cl_khr_fp64, casting to single precision">;

// C99 variable-length arrays
def ext_vla : Extension<"variable length arrays are a C99 feature">,
  InGroup<VLAExtension>;
def warn_vla_used : Warning<"variable length array used">,
  InGroup<VLA>, DefaultIgnore;
def warn_cxx11_compat_array_of_runtime_bound : Warning<
  "arrays of runtime bound are incompatible with C++ standards before C++1y">,
  InGroup<CXXPre1yCompatPedantic>, DefaultIgnore;
def err_vla_non_pod : Error<"variable length array of non-POD element type %0">;
def err_vla_in_sfinae : Error<
  "variable length array cannot be formed during template argument deduction">;
def err_array_star_in_function_definition : Error<
  "variable length array must be bound in function definition">;
def err_vla_decl_in_file_scope : Error<
  "variable length array declaration not allowed at file scope">;
def err_vla_decl_has_static_storage : Error<
  "variable length array declaration can not have 'static' storage duration">;
def err_vla_decl_has_extern_linkage : Error<
  "variable length array declaration can not have 'extern' linkage">;
def ext_vla_folded_to_constant : Extension<
  "variable length array folded to constant array as an extension">;

// C99 variably modified types
def err_variably_modified_template_arg : Error<
  "variably modified type %0 cannot be used as a template argument">;
def err_variably_modified_nontype_template_param : Error<
  "non-type template parameter of variably modified type %0">;
def err_variably_modified_new_type : Error<
  "'new' cannot allocate object of variably modified type %0">;

// C99 Designated Initializers
def ext_designated_init : Extension<
  "designated initializers are a C99 feature">, InGroup<C99>;
def err_array_designator_negative : Error<
  "array designator value '%0' is negative">;
def err_array_designator_empty_range : Error<
  "array designator range [%0, %1] is empty">;
def err_array_designator_non_array : Error<
  "array designator cannot initialize non-array type %0">;
def err_array_designator_too_large : Error<
  "array designator index (%0) exceeds array bounds (%1)">;
def err_field_designator_non_aggr : Error<
  "field designator cannot initialize a "
  "%select{non-struct, non-union|non-class}0 type %1">;
def err_field_designator_unknown : Error<
  "field designator %0 does not refer to any field in type %1">;
def err_field_designator_nonfield : Error<
  "field designator %0 does not refer to a non-static data member">;
def note_field_designator_found : Note<"field designator refers here">;
def err_designator_for_scalar_init : Error<
  "designator in initializer for scalar type %0">;
def warn_subobject_initializer_overrides : Warning<
  "subobject initialization overrides initialization of other fields "
  "within its enclosing subobject">, InGroup<InitializerOverrides>;
def warn_initializer_overrides : Warning<
  "initializer overrides prior initialization of this subobject">,
  InGroup<InitializerOverrides>;
def note_previous_initializer : Note<
  "previous initialization %select{|with side effects }0is here"
  "%select{| (side effects may not occur at run time)}0">;
def err_designator_into_flexible_array_member : Error<
  "designator into flexible array member subobject">;
def note_flexible_array_member : Note<
  "initialized flexible array member %0 is here">;
def ext_flexible_array_init : Extension<
  "flexible array initialization is a GNU extension">, InGroup<GNU>;

// Declarations.
def err_bad_variable_name : Error<
  "%0 cannot be the name of a variable or data member">;
def err_bad_parameter_name : Error<
  "'%0' cannot be the name of a parameter">;
def err_parameter_name_omitted : Error<"parameter name omitted">;
def warn_unused_parameter : Warning<"unused parameter %0">,
  InGroup<UnusedParameter>, DefaultIgnore;
def warn_unused_variable : Warning<"unused variable %0">,
  InGroup<UnusedVariable>, DefaultIgnore;
def warn_unused_exception_param : Warning<"unused exception parameter %0">,
  InGroup<UnusedExceptionParameter>, DefaultIgnore;
def warn_decl_in_param_list : Warning<
  "declaration of %0 will not be visible outside of this function">,
  InGroup<Visibility>;
def warn_redefinition_in_param_list : Warning<
  "redefinition of %0 will not be visible outside of this function">,
  InGroup<Visibility>;
def warn_empty_parens_are_function_decl : Warning<
  "empty parentheses interpreted as a function declaration">,
  InGroup<VexingParse>;
def warn_parens_disambiguated_as_function_declaration : Warning<
  "parentheses were disambiguated as a function declaration">,
  InGroup<VexingParse>;
def note_additional_parens_for_variable_declaration : Note<
  "add a pair of parentheses to declare a variable">;
def note_empty_parens_function_call : Note<
  "change this ',' to a ';' to call %0">;
def note_empty_parens_default_ctor : Note<
  "remove parentheses to declare a variable">;
def note_empty_parens_zero_initialize : Note<
  "replace parentheses with an initializer to declare a variable">;
def warn_unused_function : Warning<"unused function %0">,
  InGroup<UnusedFunction>, DefaultIgnore;
def warn_unused_member_function : Warning<"unused member function %0">,
  InGroup<UnusedMemberFunction>, DefaultIgnore;
def warn_used_but_marked_unused: Warning<"%0 was marked unused but was used">,
  InGroup<UsedButMarkedUnused>, DefaultIgnore;
def warn_unneeded_internal_decl : Warning<
  "%select{function|variable}0 %1 is not needed and will not be emitted">,
  InGroup<UnneededInternalDecl>, DefaultIgnore;
def warn_unneeded_static_internal_decl : Warning<
  "'static' function %0 declared in header file "
  "should be declared 'static inline'">,
  InGroup<UnneededInternalDecl>, DefaultIgnore;
def warn_unneeded_member_function : Warning<
  "member function %0 is not needed and will not be emitted">,
  InGroup<UnneededMemberFunction>, DefaultIgnore;
def warn_unused_private_field: Warning<"private field %0 is not used">,
  InGroup<UnusedPrivateField>, DefaultIgnore;

def warn_parameter_size: Warning<
  "%0 is a large (%1 bytes) pass-by-value argument; "
  "pass it by reference instead ?">, InGroup<LargeByValueCopy>;
def warn_return_value_size: Warning<
  "return value of %0 is a large (%1 bytes) pass-by-value object; "
  "pass it by reference instead ?">, InGroup<LargeByValueCopy>;
def warn_return_value_udt: Warning<
  "%0 has C-linkage specified, but returns user-defined type %1 which is "
  "incompatible with C">, InGroup<ReturnTypeCLinkage>;
def warn_return_value_udt_incomplete: Warning<
  "%0 has C-linkage specified, but returns incomplete type %1 which could be "
  "incompatible with C">, InGroup<ReturnTypeCLinkage>;
def warn_implicit_function_decl : Warning<
  "implicit declaration of function %0">,
  InGroup<ImplicitFunctionDeclare>, DefaultIgnore;
def ext_implicit_function_decl : ExtWarn<
  "implicit declaration of function %0 is invalid in C99">,
  InGroup<ImplicitFunctionDeclare>;
def note_function_suggestion : Note<"did you mean %0?">;

def err_ellipsis_first_arg : Error<
  "ISO C requires a named argument before '...'">;
def err_declarator_need_ident : Error<"declarator requires an identifier">;
def err_bad_language : Error<"unknown linkage language">;
def warn_use_out_of_scope_declaration : Warning<
  "use of out-of-scope declaration of %0">;
def err_inline_non_function : Error<
  "'inline' can only appear on functions">;
def err_noreturn_non_function : Error<
  "'_Noreturn' can only appear on functions">;
def warn_qual_return_type : Warning< 
  "'%0' type qualifier%s1 on return type %plural{1:has|:have}1 no effect">,
  InGroup<IgnoredQualifiers>, DefaultIgnore;

def warn_decl_shadow :
  Warning<"declaration shadows a %select{"
          "local variable|"
          "variable in %2|"
          "static data member of %2|"
          "field of %2}1">,
  InGroup<Shadow>, DefaultIgnore;

// C++ using declarations
def err_using_requires_qualname : Error<
  "using declaration requires a qualified name">;
def err_using_typename_non_type : Error<
  "'typename' keyword used on a non-type">;
def err_using_dependent_value_is_type : Error<
  "dependent using declaration resolved to type without 'typename'">;
def err_using_decl_nested_name_specifier_is_not_class : Error<
  "using declaration in class refers into '%0', which is not a class">;
def err_using_decl_nested_name_specifier_is_current_class : Error<
  "using declaration refers to its own class">;
def err_using_decl_nested_name_specifier_is_not_base_class : Error<
  "using declaration refers into '%0', which is not a base class of %1">;
def err_using_decl_constructor_not_in_direct_base : Error<
  "%0 is not a direct base of %1, can not inherit constructors">;
def err_using_decl_constructor_conflict : Error<
  "can not inherit constructor, already inherited constructor with "
  "the same signature">;
def note_using_decl_constructor_conflict_current_ctor : Note<
  "conflicting constructor">;
def note_using_decl_constructor_conflict_previous_ctor : Note<
  "previous constructor">;
def note_using_decl_constructor_conflict_previous_using : Note<
  "previously inherited here">;
def warn_using_decl_constructor_ellipsis : Warning<
  "inheriting constructor does not inherit ellipsis">,
  InGroup<DiagGroup<"inherited-variadic-ctor">>;
def note_using_decl_constructor_ellipsis : Note<
  "constructor declared with ellipsis here">;
def err_using_decl_can_not_refer_to_class_member : Error<
  "using declaration can not refer to class member">;
def err_using_decl_can_not_refer_to_namespace : Error<
  "using declaration can not refer to namespace">;
def err_using_decl_constructor : Error<
  "using declaration can not refer to a constructor">;
def warn_cxx98_compat_using_decl_constructor : Warning<
  "inheriting constructors are incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
def err_using_decl_destructor : Error<
  "using declaration can not refer to a destructor">;
def err_using_decl_template_id : Error<
  "using declaration can not refer to a template specialization">;
def note_using_decl_target : Note<"target of using declaration">;
def note_using_decl_conflict : Note<"conflicting declaration">;
def err_using_decl_redeclaration : Error<"redeclaration of using decl">;
def err_using_decl_conflict : Error<
  "target of using declaration conflicts with declaration already in scope">;
def err_using_decl_conflict_reverse : Error<
  "declaration conflicts with target of using declaration already in scope">;
def note_using_decl : Note<"%select{|previous }0using declaration">;

def warn_access_decl_deprecated : Warning<
  "access declarations are deprecated; use using declarations instead">,
  InGroup<Deprecated>;
def err_access_decl : Error<
  "ISO C++11 does not allow access declarations; "
  "use using declarations instead">;
def warn_exception_spec_deprecated : Warning<
  "dynamic exception specifications are deprecated">,
  InGroup<Deprecated>, DefaultIgnore;
def note_exception_spec_deprecated : Note<"use '%0' instead">;
def warn_deprecated_copy_operation : Warning<
  "definition of implicit copy %select{constructor|assignment operator}1 "
  "for %0 is deprecated because it has a user-declared "
  "%select{copy %select{assignment operator|constructor}1|destructor}2">,
  InGroup<Deprecated>, DefaultIgnore;

def warn_global_constructor : Warning<
  "declaration requires a global constructor">,
  InGroup<GlobalConstructors>, DefaultIgnore;
def warn_global_destructor : Warning<
  "declaration requires a global destructor">,
   InGroup<GlobalConstructors>, DefaultIgnore;
def warn_exit_time_destructor : Warning<
  "declaration requires an exit-time destructor">,
  InGroup<ExitTimeDestructors>, DefaultIgnore;

def err_invalid_thread : Error<
  "'%0' is only allowed on variable declarations">;
def err_thread_non_global : Error<
  "'%0' variables must have global storage">;
def err_thread_unsupported : Error<
  "thread-local storage is unsupported for the current target">;

def warn_maybe_falloff_nonvoid_function : Warning<
  "control may reach end of non-void function">,
  InGroup<ReturnType>;
def warn_falloff_nonvoid_function : Warning<
  "control reaches end of non-void function">,
  InGroup<ReturnType>;
def err_maybe_falloff_nonvoid_block : Error<
  "control may reach end of non-void block">;
def err_falloff_nonvoid_block : Error<
  "control reaches end of non-void block">;
def warn_suggest_noreturn_function : Warning<
  "%select{function|method}0 %1 could be declared with attribute 'noreturn'">,
  InGroup<MissingNoreturn>, DefaultIgnore;
def warn_suggest_noreturn_block : Warning<
  "block could be declared with attribute 'noreturn'">,
  InGroup<MissingNoreturn>, DefaultIgnore;
def warn_unreachable : Warning<"will never be executed">,
  InGroup<DiagGroup<"unreachable-code">>, DefaultIgnore;

/// Built-in functions.
def ext_implicit_lib_function_decl : ExtWarn<
  "implicitly declaring library function '%0' with type %1">;
def note_please_include_header : Note<
  "please include the header <%0> or explicitly provide a "
  "declaration for '%1'">;
def note_previous_builtin_declaration : Note<"%0 is a builtin with type %1">;
def warn_implicit_decl_requires_stdio : Warning<
  "declaration of built-in function '%0' requires inclusion of the header "
  "<stdio.h>">,
  InGroup<BuiltinRequiresHeader>;
def warn_implicit_decl_requires_setjmp : Warning<
  "declaration of built-in function '%0' requires inclusion of the header "
  "<setjmp.h>">,
  InGroup<BuiltinRequiresHeader>;
def warn_implicit_decl_requires_ucontext : Warning<
  "declaration of built-in function '%0' requires inclusion of the header "
  "<ucontext.h>">,
  InGroup<BuiltinRequiresHeader>;
def warn_redecl_library_builtin : Warning<
  "incompatible redeclaration of library function %0">,
  InGroup<DiagGroup<"incompatible-library-redeclaration">>;
def err_builtin_definition : Error<"definition of builtin function %0">;
def err_types_compatible_p_in_cplusplus : Error<
  "__builtin_types_compatible_p is not valid in C++">;
def warn_builtin_unknown : Warning<"use of unknown builtin %0">,
  InGroup<ImplicitFunctionDeclare>, DefaultError;
def warn_dyn_class_memaccess : Warning<
  "%select{destination for|source of|first operand of|second operand of}0 this "
  "%1 call is a pointer to dynamic class %2; vtable pointer will be "
  "%select{overwritten|copied|moved|compared}3">,
  InGroup<DiagGroup<"dynamic-class-memaccess">>;
def note_bad_memaccess_silence : Note<
  "explicitly cast the pointer to silence this warning">;
def warn_sizeof_pointer_expr_memaccess : Warning<
  "'%0' call operates on objects of type %1 while the size is based on a " 
  "different type %2">, 
  InGroup<SizeofPointerMemaccess>;
def warn_sizeof_pointer_expr_memaccess_note : Note<
  "did you mean to %select{dereference the argument to 'sizeof' (and multiply "
  "it by the number of elements)|remove the addressof in the argument to "
  "'sizeof' (and multiply it by the number of elements)|provide an explicit "
  "length}0?">;
def warn_sizeof_pointer_type_memaccess : Warning<
  "argument to 'sizeof' in %0 call is the same pointer type %1 as the "
  "%select{destination|source}2; expected %3 or an explicit length">,
  InGroup<SizeofPointerMemaccess>;
def warn_strlcpycat_wrong_size : Warning<
  "size argument in %0 call appears to be size of the source; expected the size of "
  "the destination">,
  InGroup<DiagGroup<"strlcpy-strlcat-size">>;
def note_strlcpycat_wrong_size : Note<
  "change size argument to be the size of the destination">;
  
def warn_strncat_large_size : Warning<
  "the value of the size argument in 'strncat' is too large, might lead to a " 
  "buffer overflow">, InGroup<StrncatSize>;
def warn_strncat_src_size : Warning<"size argument in 'strncat' call appears " 
  "to be size of the source">, InGroup<StrncatSize>;
def warn_strncat_wrong_size : Warning<
  "the value of the size argument to 'strncat' is wrong">, InGroup<StrncatSize>;
def note_strncat_wrong_size : Note<
  "change the argument to be the free space in the destination buffer minus " 
  "the terminating null byte">;

/// main()
// static main() is not an error in C, just in C++.
def warn_static_main : Warning<"'main' should not be declared static">,
    InGroup<Main>;
def err_static_main : Error<"'main' is not allowed to be declared static">;
def err_inline_main : Error<"'main' is not allowed to be declared inline">;
def ext_noreturn_main : ExtWarn<
  "'main' is not allowed to be declared _Noreturn">, InGroup<Main>;
def note_main_remove_noreturn : Note<"remove '_Noreturn'">;
def err_constexpr_main : Error<
  "'main' is not allowed to be declared constexpr">;
def err_main_template_decl : Error<"'main' cannot be a template">;
def err_main_returns_nonint : Error<"'main' must return 'int'">;
def ext_main_returns_nonint : ExtWarn<"return type of 'main' is not 'int'">,
    InGroup<MainReturnType>;
def note_main_change_return_type : Note<"change return type to 'int'">;
def err_main_surplus_args : Error<"too many parameters (%0) for 'main': "
    "must be 0, 2, or 3">;
def warn_main_one_arg : Warning<"only one parameter on 'main' declaration">,
    InGroup<Main>;
def err_main_arg_wrong : Error<"%select{first|second|third|fourth}0 "
    "parameter of 'main' (%select{argument count|argument array|environment|"
    "platform-specific data}0) must be of type %1">;

/// parser diagnostics
def ext_no_declarators : ExtWarn<"declaration does not declare anything">,
  InGroup<MissingDeclarations>;
def ext_typedef_without_a_name : ExtWarn<"typedef requires a name">,
  InGroup<MissingDeclarations>;
def err_typedef_not_identifier : Error<"typedef name must be an identifier">;
def err_statically_allocated_object : Error<
  "interface type cannot be statically allocated">;
def err_object_cannot_be_passed_returned_by_value : Error<
  "interface type %1 cannot be %select{returned|passed}0 by value"
  "; did you forget * in %1?">;
def err_parameters_retval_cannot_have_fp16_type : Error<
  "%select{parameters|function return value}0 cannot have __fp16 type; did you forget * ?">;
def err_opencl_half_load_store : Error<
  "%select{loading directly from|assigning directly to}0 pointer to type %1 is not allowed">;
def err_opencl_cast_to_half : Error<"casting to type %0 is not allowed">;
def err_opencl_half_declaration : Error<
  "declaring variable of type %0 is not allowed">;
def err_opencl_half_argument : Error<
  "declaring function argument of type %0 is not allowed; did you forget * ?">;
def err_opencl_half_return : Error<
  "declaring function return value of type %0 is not allowed; did you forget * ?">;
def warn_enum_value_overflow : Warning<"overflow in enumeration value">;
def warn_pragma_options_align_reset_failed : Warning<
  "#pragma options align=reset failed: %0">;
def err_pragma_options_align_mac68k_target_unsupported : Error<
  "mac68k alignment pragma is not supported on this target">;
def warn_pragma_pack_invalid_alignment : Warning<
  "expected #pragma pack parameter to be '1', '2', '4', '8', or '16'">;
// Follow the MSVC implementation.
def warn_pragma_pack_show : Warning<"value of #pragma pack(show) == %0">;
def warn_pragma_pack_pop_identifer_and_alignment : Warning<
  "specifying both a name and alignment to 'pop' is undefined">;
def warn_pragma_pack_pop_failed : Warning<"#pragma pack(pop, ...) failed: %0">;

def warn_pragma_unused_undeclared_var : Warning<
  "undeclared variable %0 used as an argument for '#pragma unused'">;
def warn_pragma_unused_expected_var_arg : Warning<
  "only variables can be arguments to '#pragma unused'">;
def err_pragma_push_visibility_mismatch : Error<
  "#pragma visibility push with no matching #pragma visibility pop">;
def note_surrounding_namespace_ends_here : Note<
  "surrounding namespace with visibility attribute ends here">;
def err_pragma_pop_visibility_mismatch : Error<
  "#pragma visibility pop with no matching #pragma visibility push">;
def note_surrounding_namespace_starts_here : Note<
  "surrounding namespace with visibility attribute starts here">;

/// Objective-C parser diagnostics
def err_duplicate_class_def : Error<
  "duplicate interface definition for class %0">;
def err_undef_superclass : Error<
  "cannot find interface declaration for %0, superclass of %1">;
def err_forward_superclass : Error<
  "attempting to use the forward class %0 as superclass of %1">;
def err_no_nsconstant_string_class : Error<
  "cannot find interface declaration for %0">;
def err_recursive_superclass : Error<
  "trying to recursively use %0 as superclass of %1">;
def warn_previous_alias_decl : Warning<"previously declared alias is ignored">;
def err_conflicting_aliasing_type : Error<"conflicting types for alias %0">;
def warn_undef_interface : Warning<"cannot find interface declaration for %0">;
def warn_duplicate_protocol_def : Warning<"duplicate protocol definition of %0 is ignored">;
def err_protocol_has_circular_dependency : Error<
  "protocol has circular dependency">;
def err_undeclared_protocol : Error<"cannot find protocol declaration for %0">;
def warn_undef_protocolref : Warning<"cannot find protocol definition for %0">;
def warn_readonly_property : Warning<
  "attribute 'readonly' of property %0 restricts attribute "
  "'readwrite' of property inherited from %1">;

def warn_property_attribute : Warning<
  "'%1' attribute on property %0 does not match the property inherited from %2">;
def warn_property_types_are_incompatible : Warning<
  "property type %0 is incompatible with type %1 inherited from %2">;
def warn_protocol_property_mismatch : Warning<
  "property of type %0 was selected for synthesis">,
  InGroup<DiagGroup<"protocol-property-synthesis-ambiguity">>;
def err_undef_interface : Error<"cannot find interface declaration for %0">;
def err_category_forward_interface : Error<
  "cannot define %select{category|class extension}0 for undefined class %1">;
def err_class_extension_after_impl : Error<
  "cannot declare class extension for %0 after class implementation">;
def note_implementation_declared : Note<
  "class implementation is declared here">;
def note_while_in_implementation : Note<
  "detected while default synthesizing properties in class implementation">;
def note_class_declared : Note<
  "class is declared here">;
def note_receiver_class_declared : Note<
  "receiver is instance of class declared here">;
def note_receiver_is_id : Note<
  "receiver is treated with 'id' type for purpose of method lookup">;
def note_suppressed_class_declare : Note<
  "class with specified objc_requires_property_definitions attribute is declared here">;
def err_objc_root_class_subclass : Error<
  "objc_root_class attribute may only be specified on a root class declaration">;
def warn_objc_root_class_missing : Warning<
	"class %0 defined without specifying a base class">,
  InGroup<ObjCRootClass>;
def note_objc_needs_superclass : Note<
  "add a super class to fix this problem">;
def warn_dup_category_def : Warning<
  "duplicate definition of category %1 on interface %0">;
def err_conflicting_super_class : Error<"conflicting super class name %0">;
def err_dup_implementation_class : Error<"reimplementation of class %0">;
def err_dup_implementation_category : Error<
  "reimplementation of category %1 for class %0">;
def err_conflicting_ivar_type : Error<
  "instance variable %0 has conflicting type%diff{: $ vs $|}1,2">;
def err_duplicate_ivar_declaration : Error<
  "instance variable is already declared">;
def warn_on_superclass_use : Warning<
  "class implementation may not have super class">;
def err_conflicting_ivar_bitwidth : Error<
  "instance variable %0 has conflicting bit-field width">;
def err_conflicting_ivar_name : Error<
  "conflicting instance variable names: %0 vs %1">;
def err_inconsistant_ivar_count : Error<
  "inconsistent number of instance variables specified">;
def warn_undef_method_impl : Warning<"method definition for %0 not found">,
  InGroup<DiagGroup<"incomplete-implementation">>;
def note_required_for_protocol_at : 
  Note<"required for direct or indirect protocol %0">;

def warn_conflicting_overriding_ret_types : Warning<
  "conflicting return type in "
  "declaration of %0%diff{: $ vs $|}1,2">,
  InGroup<OverridingMethodMismatch>, DefaultIgnore;

def warn_conflicting_ret_types : Warning<
  "conflicting return type in "
  "implementation of %0%diff{: $ vs $|}1,2">,
  InGroup<MismatchedReturnTypes>;

def warn_conflicting_overriding_ret_type_modifiers : Warning<
  "conflicting distributed object modifiers on return type "
  "in declaration of %0">,
  InGroup<OverridingMethodMismatch>, DefaultIgnore;

def warn_conflicting_ret_type_modifiers : Warning<
  "conflicting distributed object modifiers on return type "
  "in implementation of %0">,
  InGroup<DistributedObjectModifiers>;

def warn_non_covariant_overriding_ret_types : Warning<
  "conflicting return type in "
  "declaration of %0: %1 vs %2">,
  InGroup<OverridingMethodMismatch>, DefaultIgnore;

def warn_non_covariant_ret_types : Warning<
  "conflicting return type in "
  "implementation of %0: %1 vs %2">,
  InGroup<MethodSignatures>, DefaultIgnore;

def warn_conflicting_overriding_param_types : Warning<
  "conflicting parameter types in "
  "declaration of %0%diff{: $ vs $|}1,2">,
  InGroup<OverridingMethodMismatch>, DefaultIgnore;

def warn_conflicting_param_types : Warning<
  "conflicting parameter types in "
  "implementation of %0%diff{: $ vs $|}1,2">,
  InGroup<MismatchedParameterTypes>;

def warn_conflicting_param_modifiers : Warning<
  "conflicting distributed object modifiers on parameter type "
  "in implementation of %0">,
  InGroup<DistributedObjectModifiers>;

def warn_conflicting_overriding_param_modifiers : Warning<
  "conflicting distributed object modifiers on parameter type "
  "in declaration of %0">,
  InGroup<OverridingMethodMismatch>, DefaultIgnore;

def warn_non_contravariant_overriding_param_types : Warning<
  "conflicting parameter types in "
  "declaration of %0: %1 vs %2">,
  InGroup<OverridingMethodMismatch>, DefaultIgnore;

def warn_non_contravariant_param_types : Warning<
  "conflicting parameter types in "
  "implementation of %0: %1 vs %2">,
  InGroup<MethodSignatures>, DefaultIgnore;

def warn_conflicting_overriding_variadic :Warning<
  "conflicting variadic declaration of method and its "
  "implementation">,
  InGroup<OverridingMethodMismatch>, DefaultIgnore;

def warn_conflicting_variadic :Warning<
  "conflicting variadic declaration of method and its "
  "implementation">;

def warn_category_method_impl_match:Warning<
  "category is implementing a method which will also be implemented"
  " by its primary class">, InGroup<ObjCProtocolMethodImpl>;

def warn_implements_nscopying : Warning<
"default assign attribute on property %0 which implements "
"NSCopying protocol is not appropriate with -fobjc-gc[-only]">;

def warn_multiple_method_decl : Warning<"multiple methods named %0 found">;
def warn_strict_multiple_method_decl : Warning<
  "multiple methods named %0 found">, InGroup<StrictSelector>, DefaultIgnore;
def warn_accessor_property_type_mismatch : Warning<
  "type of property %0 does not match type of accessor %1">;
def not_conv_function_declared_at : Note<"type conversion function declared here">;
def note_method_declared_at : Note<"method %0 declared here">;
def note_property_attribute : Note<"property %0 is declared "
  "%select{deprecated|unavailable}1 here">;
def err_setter_type_void : Error<"type of setter must be void">;
def err_duplicate_method_decl : Error<"duplicate declaration of method %0">;
def warn_duplicate_method_decl : 
  Warning<"multiple declarations of method %0 found and ignored">, 
  InGroup<MethodDuplicate>, DefaultIgnore;
def err_objc_var_decl_inclass : 
    Error<"cannot declare variable inside @interface or @protocol">;
def error_missing_method_context : Error<
  "missing context for method declaration">;
def err_objc_property_attr_mutually_exclusive : Error<
  "property attributes '%0' and '%1' are mutually exclusive">;
def err_objc_property_requires_object : Error<
  "property with '%0' attribute must be of object type">;
def warn_objc_property_no_assignment_attribute : Warning<
  "no 'assign', 'retain', or 'copy' attribute is specified - "
  "'assign' is assumed">,
  InGroup<ObjCPropertyNoAttribute>;
def warn_objc_isa_use : Warning<
  "direct access to Objective-C's isa is deprecated in favor of "
  "object_getClass()">, InGroup<DeprecatedObjCIsaUsage>;
def warn_objc_isa_assign : Warning<
  "assignment to Objective-C's isa is deprecated in favor of "
  "object_setClass()">, InGroup<DeprecatedObjCIsaUsage>;
def warn_objc_pointer_masking : Warning<
  "bitmasking for introspection of Objective-C object pointers is strongly "
  "discouraged">,
  InGroup<DiagGroup<"deprecated-objc-pointer-introspection">>;
def warn_objc_property_default_assign_on_object : Warning<
  "default property attribute 'assign' not appropriate for non-GC object">,
  InGroup<ObjCPropertyNoAttribute>;
def warn_property_attr_mismatch : Warning<
  "property attribute in class extension does not match the primary class">;
def warn_objc_property_copy_missing_on_block : Warning<
    "'copy' attribute must be specified for the block property "
    "when -fobjc-gc-only is specified">;
def warn_objc_property_retain_of_block : Warning<
    "retain'ed block property does not copy the block "
    "- use copy attribute instead">, InGroup<ObjCRetainBlockProperty>;
def warn_objc_readonly_property_has_setter : Warning<
    "setter cannot be specified for a readonly property">,
    InGroup<ObjCReadonlyPropertyHasSetter>;
def warn_atomic_property_rule : Warning<
  "writable atomic property %0 cannot pair a synthesized %select{getter|setter}1 "
  "with a user defined %select{getter|setter}2">,
  InGroup<DiagGroup<"atomic-property-with-user-defined-accessor">>;
def note_atomic_property_fixup_suggest : Note<"setter and getter must both be "
  "synthesized, or both be user defined,or the property must be nonatomic">;
def err_atomic_property_nontrivial_assign_op : Error<
  "atomic property of reference type %0 cannot have non-trivial assignment"
  " operator">;
def warn_owning_getter_rule : Warning<
  "property's synthesized getter follows Cocoa naming"
  " convention for returning 'owned' objects">,
  InGroup<DiagGroup<"objc-property-matches-cocoa-ownership-rule">>;
def warn_auto_synthesizing_protocol_property :Warning<
  "auto property synthesis will not synthesize property"
  " declared in a protocol">,
  InGroup<DiagGroup<"objc-protocol-property-synthesis">>;
def warn_no_autosynthesis_shared_ivar_property : Warning <
  "auto property synthesis will not synthesize property "
  "'%0' because it cannot share an ivar with another synthesized property">,
  InGroup<ObjCNoPropertyAutoSynthesis>;
def warn_no_autosynthesis_property : Warning<
  "auto property synthesis will not synthesize property "
  "'%0' because it is 'readwrite' but it will be synthesized 'readonly' "
  "via another property">,
  InGroup<ObjCNoPropertyAutoSynthesis>;
def warn_autosynthesis_property_ivar_match :Warning<
  "autosynthesized property %0 will use %select{|synthesized}1 instance variable "
  "%2, not existing instance variable %3">,
  InGroup<DiagGroup<"objc-autosynthesis-property-ivar-name-match">>;
def warn_missing_explicit_synthesis : Warning <
  "auto property synthesis is synthesizing property not explicitly synthesized">,
  InGroup<DiagGroup<"objc-missing-property-synthesis">>, DefaultIgnore;
def warn_property_getter_owning_mismatch : Warning<
  "property declared as returning non-retained objects"
  "; getter returning retained objects">;
def error_property_setter_ambiguous_use : Error<
  "synthesized properties '%0' and '%1' both claim setter %2 -"
  " use of this setter will cause unexpected behavior">;
def err_ownin_getter_rule : Error<
  "property's synthesized getter follows Cocoa naming"
  " convention for returning 'owned' objects">;
def warn_default_atomic_custom_getter_setter : Warning<
  "atomic by default property %0 has a user defined %select{getter|setter}1 "
  "(property should be marked 'atomic' if this is intended)">,
  InGroup<CustomAtomic>, DefaultIgnore;
def err_use_continuation_class : Error<
  "illegal redeclaration of property in class extension %0"
  " (attribute must be 'readwrite', while its primary must be 'readonly')">;
def err_type_mismatch_continuation_class : Error<
  "type of property %0 in class extension does not match "
  "property type in primary class">;
def err_use_continuation_class_redeclaration_readwrite : Error<
  "illegal redeclaration of 'readwrite' property in class extension %0"
  " (perhaps you intended this to be a 'readwrite' redeclaration of a "
  "'readonly' public property?)">;
def err_continuation_class : Error<"class extension has no primary class">;
def err_property_type : Error<"property cannot have array or function type %0">;
def error_missing_property_context : Error<
  "missing context for property implementation declaration">;
def error_bad_property_decl : Error<
  "property implementation must have its declaration in interface %0">;
def error_category_property : Error<
  "property declared in category %0 cannot be implemented in "
  "class implementation">;
def note_property_declare : Note<
  "property declared here">;
def note_protocol_property_declare : Note<
  "it could also be property of type %0 declared here">;
def note_property_synthesize : Note<
  "property synthesized here">;
def error_synthesize_category_decl : Error<
  "@synthesize not allowed in a category's implementation">;
def error_reference_property : Error<
  "property of reference type is not supported">;
def error_missing_property_interface : Error<
  "property implementation in a category with no category declaration">;
def error_bad_category_property_decl : Error<
  "property implementation must have its declaration in the category %0">;
def error_bad_property_context : Error<
  "property implementation must be in a class or category implementation">;
def error_missing_property_ivar_decl : Error<
  "synthesized property %0 must either be named the same as a compatible"
  " instance variable or must explicitly name an instance variable">;
def error_synthesize_weak_non_arc_or_gc : Error<
  "@synthesize of 'weak' property is only allowed in ARC or GC mode">;
def err_arc_perform_selector_retains : Error<
  "performSelector names a selector which retains the object">;
def warn_arc_perform_selector_leaks : Warning<
  "performSelector may cause a leak because its selector is unknown">,
  InGroup<DiagGroup<"arc-performSelector-leaks">>;
def err_gc_weak_property_strong_type : Error<
  "weak attribute declared on a __strong type property in GC mode">;
def warn_receiver_is_weak : Warning <
  "weak %select{receiver|property|implicit property}0 may be "
  "unpredictably set to nil">,
  InGroup<DiagGroup<"receiver-is-weak">>, DefaultIgnore;
def note_arc_assign_to_strong : Note<
  "assign the value to a strong variable to keep the object alive during use">;
def warn_arc_repeated_use_of_weak : Warning <
  "weak %select{variable|property|implicit property|instance variable}0 %1 is "
  "accessed multiple times in this %select{function|method|block|lambda}2 "
  "but may be unpredictably set to nil; assign to a strong variable to keep "
  "the object alive">,
  InGroup<ARCRepeatedUseOfWeak>, DefaultIgnore;
def warn_implicitly_retains_self : Warning <
  "block implicitly retains 'self'; explicitly mention 'self' to indicate "
  "this is intended behavior">,
  InGroup<DiagGroup<"implicit-retain-self">>, DefaultIgnore;
def warn_arc_possible_repeated_use_of_weak : Warning <
  "weak %select{variable|property|implicit property|instance variable}0 %1 may "
  "be accessed multiple times in this %select{function|method|block|lambda}2 "
  "and may be unpredictably set to nil; assign to a strong variable to keep "
  "the object alive">,
  InGroup<ARCRepeatedUseOfWeakMaybe>, DefaultIgnore;
def note_arc_weak_also_accessed_here : Note<
  "also accessed here">;
def err_incomplete_synthesized_property : Error<
  "cannot synthesize property %0 with incomplete type %1">;

def error_property_ivar_type : Error<
  "type of property %0 (%1) does not match type of instance variable %2 (%3)">;
def error_property_accessor_type : Error<
  "type of property %0 (%1) does not match type of accessor %2 (%3)">;
def error_ivar_in_superclass_use : Error<
  "property %0 attempting to use instance variable %1 declared in super class %2">;
def error_weak_property : Error<
  "existing instance variable %1 for __weak property %0 must be __weak">;
def error_strong_property : Error<
  "existing instance variable %1 for strong property %0 may not be __weak">;
def error_dynamic_property_ivar_decl : Error<
  "dynamic property can not have instance variable specification">;
def error_duplicate_ivar_use : Error<
  "synthesized properties %0 and %1 both claim instance variable %2">;
def error_property_implemented : Error<"property %0 is already implemented">;
def warn_objc_property_attr_mutually_exclusive : Warning<
  "property attributes '%0' and '%1' are mutually exclusive">,
  InGroup<ReadOnlySetterAttrs>, DefaultIgnore;
def warn_objc_missing_super_call : Warning<
  "method possibly missing a [super %0] call">,
  InGroup<ObjCMissingSuperCalls>;
def error_dealloc_bad_result_type : Error<
  "dealloc return type must be correctly specified as 'void' under ARC, "
  "instead of %0">;
def warn_undeclared_selector : Warning<
  "undeclared selector %0">, InGroup<UndeclaredSelector>, DefaultIgnore;
def warn_undeclared_selector_with_typo : Warning<
  "undeclared selector %0; did you mean %1?">,
  InGroup<UndeclaredSelector>, DefaultIgnore;
def warn_implicit_atomic_property : Warning<
  "property is assumed atomic by default">, InGroup<ImplicitAtomic>, DefaultIgnore;
def note_auto_readonly_iboutlet_fixup_suggest : Note<
  "property should be changed to be readwrite">;
def warn_auto_readonly_iboutlet_property : Warning<
  "readonly IBOutlet property '%0' when auto-synthesized may "
  "not work correctly with 'nib' loader">,
  InGroup<DiagGroup<"readonly-iboutlet-property">>;
def warn_auto_implicit_atomic_property : Warning<
  "property is assumed atomic when auto-synthesizing the property">,
  InGroup<ImplicitAtomic>, DefaultIgnore;
def warn_unimplemented_selector:  Warning<
  "creating selector for nonexistent method %0">, InGroup<Selector>, DefaultIgnore;
def warning_multiple_selectors: Warning<
  "multiple selectors named %0 found">, InGroup<SelectorTypeMismatch>, DefaultIgnore;
def warn_unimplemented_protocol_method : Warning<
  "method %0 in protocol not implemented">, InGroup<Protocol>;

// C++ declarations
def err_static_assert_expression_is_not_constant : Error<
  "static_assert expression is not an integral constant expression">;
def err_static_assert_failed : Error<"static_assert failed %0">;

def warn_inline_namespace_reopened_noninline : Warning<
  "inline namespace cannot be reopened as a non-inline namespace">;
def err_inline_namespace_mismatch : Error<
  "%select{|non-}0inline namespace "
  "cannot be reopened as %select{non-|}0inline">;

def err_unexpected_friend : Error<
  "friends can only be classes or functions">;
def ext_enum_friend : ExtWarn<
  "enumeration type %0 cannot be a friend">;
def warn_cxx98_compat_enum_friend : Warning<
  "befriending enumeration type %0 is incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
def ext_nonclass_type_friend : ExtWarn<
  "non-class friend type %0 is a C++11 extension">, InGroup<CXX11>;
def warn_cxx98_compat_nonclass_type_friend : Warning<
  "non-class friend type %0 is incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
def err_friend_is_member : Error<
  "friends cannot be members of the declaring class">;
def warn_cxx98_compat_friend_is_member : Warning<
  "friend declaration naming a member of the declaring class is incompatible "
  "with C++98">, InGroup<CXX98Compat>, DefaultIgnore;
def ext_unelaborated_friend_type : ExtWarn<
  "unelaborated friend declaration is a C++11 extension; specify "
  "'%select{struct|interface|union|class|enum}0' to befriend %1">,
  InGroup<CXX11>;
def warn_cxx98_compat_unelaborated_friend_type : Warning<
  "befriending %1 without '%select{struct|interface|union|class|enum}0' "
  "keyword is incompatible with C++98">, InGroup<CXX98Compat>, DefaultIgnore;
def err_qualified_friend_not_found : Error<
  "no function named %0 with type %1 was found in the specified scope">;
def err_introducing_special_friend : Error<
  "must use a qualified name when declaring a %select{constructor|"
  "destructor|conversion operator}0 as a friend">;
def err_tagless_friend_type_template : Error<
  "friend type templates must use an elaborated type">;
def err_no_matching_local_friend : Error<
  "no matching function found in local scope">;
def err_no_matching_local_friend_suggest : Error<
  "no matching function %0 found in local scope; did you mean %2?">;
def err_partial_specialization_friend : Error<
  "partial specialization cannot be declared as a friend">;
def err_qualified_friend_def : Error<
  "friend function definition cannot be qualified with '%0'">;
def err_friend_def_in_local_class : Error<
  "friend function cannot be defined in a local class">;
def err_friend_not_first_in_declaration : Error<
  "'friend' must appear first in a non-function declaration">;
def err_using_decl_friend : Error<
  "cannot befriend target of using declaration">;
  
def err_invalid_member_in_interface : Error<
  "%select{data member |non-public member function |static member function |"
          "user-declared constructor|user-declared destructor|operator |"
          "nested class }0%1 is not permitted within an interface type">;
def err_invalid_base_in_interface : Error<
  "interface type cannot inherit from "
  "%select{'struct|non-public 'interface|'class}0 %1'">;

def err_abstract_type_in_decl : Error<
  "%select{return|parameter|variable|field|instance variable}0 type %1 is an abstract class">;
def err_allocation_of_abstract_type : Error<
  "allocating an object of abstract class type %0">;
def err_throw_abstract_type : Error<
  "cannot throw an object of abstract type %0">;
def err_array_of_abstract_type : Error<"array of abstract class type %0">;

def err_multiple_final_overriders : Error<
  "virtual function %q0 has more than one final overrider in %1">; 
def note_final_overrider : Note<"final overrider of %q0 in %1">;

def err_type_defined_in_type_specifier : Error<
  "%0 can not be defined in a type specifier">;
def err_type_defined_in_result_type : Error<
  "%0 can not be defined in the result type of a function">;
def err_type_defined_in_param_type : Error<
  "%0 can not be defined in a parameter type">;
def err_type_defined_in_alias_template : Error<
  "%0 can not be defined in a type alias template">;

def note_pure_virtual_function : Note<
  "unimplemented pure virtual method %0 in %1">;

def err_deleted_decl_not_first : Error<
  "deleted definition must be first declaration">;

def err_deleted_override : Error<
  "deleted function %0 cannot override a non-deleted function">;

def err_non_deleted_override : Error<
  "non-deleted function %0 cannot override a deleted function">;

def warn_weak_vtable : Warning<
  "%0 has no out-of-line virtual method definitions; its vtable will be "
  "emitted in every translation unit">,
  InGroup<DiagGroup<"weak-vtables">>, DefaultIgnore;
def warn_weak_template_vtable : Warning<
  "explicit template instantiation %0 will emit a vtable in every "
  "translation unit">,
  InGroup<DiagGroup<"weak-template-vtables">>, DefaultIgnore;

def ext_using_undefined_std : ExtWarn<
  "using directive refers to implicitly-defined namespace 'std'">;
  
// C++ exception specifications
def err_exception_spec_in_typedef : Error<
  "exception specifications are not allowed in %select{typedefs|type aliases}0">;
def err_distant_exception_spec : Error<
  "exception specifications are not allowed beyond a single level "
  "of indirection">;
def err_incomplete_in_exception_spec : Error<
  "%select{|pointer to |reference to }0incomplete type %1 is not allowed "
  "in exception specification">;
def err_rref_in_exception_spec : Error<
  "rvalue reference type %0 is not allowed in exception specification">;
def err_mismatched_exception_spec : Error<
  "exception specification in declaration does not match previous declaration">;
def warn_mismatched_exception_spec : ExtWarn<
  "exception specification in declaration does not match previous declaration">;
def err_override_exception_spec : Error<
  "exception specification of overriding function is more lax than "
  "base version">;
def warn_override_exception_spec : ExtWarn<
  "exception specification of overriding function is more lax than "
  "base version">, InGroup<Microsoft>;
def err_incompatible_exception_specs : Error<
  "target exception specification is not superset of source">;
def err_deep_exception_specs_differ : Error<
  "exception specifications of %select{return|argument}0 types differ">;
def warn_missing_exception_specification : Warning<
  "%0 is missing exception specification '%1'">;
def err_noexcept_needs_constant_expression : Error<
  "argument to noexcept specifier must be a constant expression">;

// C++ access checking
def err_class_redeclared_with_different_access : Error<
  "%0 redeclared with '%1' access">;
def err_access : Error<
  "%1 is a %select{private|protected}0 member of %3">, AccessControl;
def ext_ms_using_declaration_inaccessible : ExtWarn<
  "using declaration referring to inaccessible member '%0' (which refers "
  "to accessible member '%1') is a Microsoft compatibility extension">,
    AccessControl, InGroup<Microsoft>;
def err_access_ctor : Error<
  "calling a %select{private|protected}0 constructor of class %2">, 
  AccessControl;
def ext_rvalue_to_reference_access_ctor : ExtWarn<
  "C++98 requires an accessible copy constructor for class %2 when binding "
  "a reference to a temporary; was %select{private|protected}0">,
  AccessControl, InGroup<BindToTemporaryCopy>;
def err_access_base_ctor : Error<
  // The ERRORs represent other special members that aren't constructors, in
  // hopes that someone will bother noticing and reporting if they appear
  "%select{base class|inherited virtual base class}0 %1 has %select{private|"
  "protected}3 %select{default |copy |move |*ERROR* |*ERROR* "
  "|*ERROR*|}2constructor">, AccessControl;
def err_access_field_ctor : Error<
  // The ERRORs represent other special members that aren't constructors, in
  // hopes that someone will bother noticing and reporting if they appear
  "field of type %0 has %select{private|protected}2 "
  "%select{default |copy |move |*ERROR* |*ERROR* |*ERROR* |}1constructor">,
  AccessControl;
def err_access_friend_function : Error<
  "friend function %1 is a %select{private|protected}0 member of %3">,
  AccessControl;

def err_access_dtor : Error<
  "calling a %select{private|protected}1 destructor of class %0">, 
  AccessControl;
def err_access_dtor_base :
    Error<"base class %0 has %select{private|protected}1 destructor">,
    AccessControl;
def err_access_dtor_vbase :
    Error<"inherited virtual base class %1 has "
    "%select{private|protected}2 destructor">,
    AccessControl;
def err_access_dtor_temp :
    Error<"temporary of type %0 has %select{private|protected}1 destructor">,
    AccessControl;
def err_access_dtor_exception :
    Error<"exception object of type %0 has %select{private|protected}1 "
          "destructor">, AccessControl;
def err_access_dtor_field :
    Error<"field of type %1 has %select{private|protected}2 destructor">,
    AccessControl;
def err_access_dtor_var :
    Error<"variable of type %1 has %select{private|protected}2 destructor">,
    AccessControl;
def err_access_dtor_ivar :
    Error<"instance variable of type %0 has %select{private|protected}1 "
          "destructor">,
    AccessControl;
def note_previous_access_declaration : Note<
  "previously declared '%1' here">;
def note_access_natural : Note<
  "%select{|implicitly }1declared %select{private|protected}0 here">;
def note_access_constrained_by_path : Note<
  "constrained by %select{|implicitly }1%select{private|protected}0"
  " inheritance here">;
def note_access_protected_restricted_noobject : Note<
  "must name member using the type of the current context %0">;
def note_access_protected_restricted_ctordtor : Note<
  "protected %select{constructor|destructor}0 can only be used to "
  "%select{construct|destroy}0 a base class subobject">;
def note_access_protected_restricted_object : Note<
  "can only access this member on an object of type %0">;
def warn_cxx98_compat_sfinae_access_control : Warning<
  "substitution failure due to access control is incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore, NoSFINAE;
  
// C++ name lookup
def err_incomplete_nested_name_spec : Error<
  "incomplete type %0 named in nested name specifier">;
def err_dependent_nested_name_spec : Error<
  "nested name specifier for a declaration cannot depend on a template "
  "parameter">;
def err_nested_name_member_ref_lookup_ambiguous : Error<
  "lookup of %0 in member access expression is ambiguous">;
def ext_nested_name_member_ref_lookup_ambiguous : ExtWarn<
  "lookup of %0 in member access expression is ambiguous; using member of %1">,
  InGroup<AmbigMemberTemplate>;
def note_ambig_member_ref_object_type : Note<
  "lookup in the object type %0 refers here">;
def note_ambig_member_ref_scope : Note<
  "lookup from the current scope refers here">;
def err_qualified_member_nonclass : Error<
  "qualified member access refers to a member in %0">;
def err_incomplete_member_access : Error<
  "member access into incomplete type %0">;
def err_incomplete_type : Error<
  "incomplete type %0 where a complete type is required">;
def warn_cxx98_compat_enum_nested_name_spec : Warning<
  "enumeration type in nested name specifier is incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
  
// C++ class members
def err_storageclass_invalid_for_member : Error<
  "storage class specified for a member declaration">;
def err_mutable_function : Error<"'mutable' cannot be applied to functions">;
def err_mutable_reference : Error<"'mutable' cannot be applied to references">;
def err_mutable_const : Error<"'mutable' and 'const' cannot be mixed">;
def err_mutable_nonmember : Error<
  "'mutable' can only be applied to member variables">;
def err_virtual_non_function : Error<
  "'virtual' can only appear on non-static member functions">;
def err_virtual_out_of_class : Error<
  "'virtual' can only be specified inside the class definition">;
def err_virtual_member_function_template : Error<
  "'virtual' can not be specified on member function templates">;
def err_static_overrides_virtual : Error<
  "'static' member function %0 overrides a virtual function in a base class">;
def err_explicit_non_function : Error<
  "'explicit' can only appear on non-static member functions">;
def err_explicit_out_of_class : Error<
  "'explicit' can only be specified inside the class definition">;
def err_explicit_non_ctor_or_conv_function : Error<
  "'explicit' can only be applied to a constructor or conversion function">;
def err_static_not_bitfield : Error<"static member %0 cannot be a bit-field">;
def err_static_out_of_line : Error<
  "'static' can only be specified inside the class definition">;
def err_typedef_not_bitfield : Error<"typedef member %0 cannot be a bit-field">;
def err_not_integral_type_bitfield : Error<
  "bit-field %0 has non-integral type %1">;
def err_not_integral_type_anon_bitfield : Error<
  "anonymous bit-field has non-integral type %0">;
def err_member_function_initialization : Error<
  "initializer on function does not look like a pure-specifier">;
def err_non_virtual_pure : Error<
  "%0 is not virtual and cannot be declared pure">;
def warn_pure_function_definition : ExtWarn<
  "function definition with pure-specifier is a Microsoft extension">,
  InGroup<Microsoft>;
def err_implicit_object_parameter_init : Error<
  "cannot initialize object parameter of type %0 with an expression "
  "of type %1">;
def err_qualified_member_of_unrelated : Error<
  "%q0 is not a member of class %1">;

def warn_call_to_pure_virtual_member_function_from_ctor_dtor : Warning<
  "call to pure virtual member function %0; overrides of %0 in subclasses are "
  "not available in the %select{constructor|destructor}1 of %2">;

def note_field_decl : Note<"member is declared here">;
def note_ivar_decl : Note<"instance variable is declared here">;
def note_bitfield_decl : Note<"bit-field is declared here">;
def note_previous_decl : Note<"%0 declared here">;
def note_implicit_param_decl : Note<"%0 is an implicit parameter">;
def note_member_synthesized_at : Note<
  "implicit %select{default constructor|copy constructor|move constructor|copy "
  "assignment operator|move assignment operator|destructor}0 for %1 first "
  "required here">;
def note_inhctor_synthesized_at : Note<
  "inheriting constructor for %0 first required here">;
def err_missing_default_ctor : Error<
  "%select{|implicit default |inheriting }0constructor for %1 must explicitly "
  "initialize the %select{base class|member}2 %3 which does not have a default "
  "constructor">;

def err_illegal_union_or_anon_struct_member : Error<
  "%select{anonymous struct|union}0 member %1 has a non-trivial "
  "%select{constructor|copy constructor|move constructor|copy assignment "
  "operator|move assignment operator|destructor}2">;
def warn_cxx98_compat_nontrivial_union_or_anon_struct_member : Warning<
  "%select{anonymous struct|union}0 member %1 with a non-trivial "
  "%select{constructor|copy constructor|move constructor|copy assignment "
  "operator|move assignment operator|destructor}2 is incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;

def note_nontrivial_virtual_dtor : Note<
  "destructor for %0 is not trivial because it is virtual">;
def note_nontrivial_has_virtual : Note<
  "because type %0 has a virtual %select{member function|base class}1">;
def note_nontrivial_no_def_ctor : Note<
  "because %select{base class of |field of |}0type %1 has no "
  "default constructor">;
def note_user_declared_ctor : Note<
  "implicit default constructor suppressed by user-declared constructor">;
def note_nontrivial_no_copy : Note<
  "because no %select{<<ERROR>>|constructor|constructor|assignment operator|"
  "assignment operator|<<ERROR>>}2 can be used to "
  "%select{<<ERROR>>|copy|move|copy|move|<<ERROR>>}2 "
  "%select{base class|field|an object}0 of type %3">;
def note_nontrivial_user_provided : Note<
  "because %select{base class of |field of |}0type %1 has a user-provided "
  "%select{default constructor|copy constructor|move constructor|"
  "copy assignment operator|move assignment operator|destructor}2">;
def note_nontrivial_in_class_init : Note<
  "because field %0 has an initializer">;
def note_nontrivial_param_type : Note<
  "because its parameter is %diff{of type $, not $|of the wrong type}2,3">;
def note_nontrivial_default_arg : Note<"because it has a default argument">;
def note_nontrivial_variadic : Note<"because it is a variadic function">;
def note_nontrivial_subobject : Note<
  "because the function selected to %select{construct|copy|move|copy|move|"
  "destroy}2 %select{base class|field}0 of type %1 is not trivial">;
def note_nontrivial_objc_ownership : Note<
  "because type %0 has a member with %select{no|no|__strong|__weak|"
  "__autoreleasing}1 ownership">;

def err_static_data_member_not_allowed_in_anon_struct : Error<
  "static data member %0 not allowed in anonymous struct">;
def ext_static_data_member_in_union : ExtWarn<
  "static data member %0 in union is a C++11 extension">, InGroup<CXX11>;
def warn_cxx98_compat_static_data_member_in_union : Warning<
  "static data member %0 in union is incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
def ext_union_member_of_reference_type : ExtWarn<
  "union member %0 has reference type %1, which is a Microsoft extension">,
  InGroup<Microsoft>;
def err_union_member_of_reference_type : Error<
  "union member %0 has reference type %1">;
def ext_anonymous_struct_union_qualified : Extension<
  "anonymous %select{struct|union}0 cannot be '%1'">;
def err_different_return_type_for_overriding_virtual_function : Error<
  "virtual function %0 has a different return type "
  "%diff{($) than the function it overrides (which has return type $)|"
  "than the function it overrides}1,2">;
def note_overridden_virtual_function : Note<
  "overridden virtual function is here">;
def err_conflicting_overriding_cc_attributes : Error<
  "virtual function %0 has different calling convention attributes "
  "%diff{($) than the function it overrides (which has calling convention $)|"
  "than the function it overrides}1,2">;

def err_covariant_return_inaccessible_base : Error<
  "invalid covariant return for virtual function: %1 is a "
  "%select{private|protected}2 base class of %0">, AccessControl;
def err_covariant_return_ambiguous_derived_to_base_conv : Error<
  "return type of virtual function %3 is not covariant with the return type of "
  "the function it overrides (ambiguous conversion from derived class "
  "%0 to base class %1:%2)">;
def err_covariant_return_not_derived : Error<
  "return type of virtual function %0 is not covariant with the return type of "
  "the function it overrides (%1 is not derived from %2)">;
def err_covariant_return_incomplete : Error<
  "return type of virtual function %0 is not covariant with the return type of "
  "the function it overrides (%1 is incomplete)">;
def err_covariant_return_type_different_qualifications : Error<
  "return type of virtual function %0 is not covariant with the return type of "
  "the function it overrides (%1 has different qualifiers than %2)">;
def err_covariant_return_type_class_type_more_qualified : Error<
  "return type of virtual function %0 is not covariant with the return type of "
  "the function it overrides (class type %1 is more qualified than class "
  "type %2">;
  
// C++ constructors
def err_constructor_cannot_be : Error<"constructor cannot be declared '%0'">;
def err_invalid_qualified_constructor : Error<
  "'%0' qualifier is not allowed on a constructor">;
def err_ref_qualifier_constructor : Error<
  "ref-qualifier '%select{&&|&}0' is not allowed on a constructor">;

def err_constructor_return_type : Error<
  "constructor cannot have a return type">;
def err_constructor_redeclared : Error<"constructor cannot be redeclared">;
def err_constructor_byvalue_arg : Error<
  "copy constructor must pass its first argument by reference">;
def warn_no_constructor_for_refconst : Warning<
  "%select{struct|interface|union|class|enum}0 %1 does not declare any "
  "constructor to initialize its non-modifiable members">;
def note_refconst_member_not_initialized : Note<
  "%select{const|reference}0 member %1 will never be initialized">;
def ext_ms_explicit_constructor_call : ExtWarn<
  "explicit constructor calls are a Microsoft extension">, InGroup<Microsoft>;

// C++ destructors
def err_destructor_not_member : Error<
  "destructor must be a non-static member function">;
def err_destructor_cannot_be : Error<"destructor cannot be declared '%0'">;
def err_invalid_qualified_destructor : Error<
  "'%0' qualifier is not allowed on a destructor">;
def err_ref_qualifier_destructor : Error<
  "ref-qualifier '%select{&&|&}0' is not allowed on a destructor">;
def err_destructor_return_type : Error<"destructor cannot have a return type">;
def err_destructor_redeclared : Error<"destructor cannot be redeclared">;
def err_destructor_with_params : Error<"destructor cannot have any parameters">;
def err_destructor_variadic : Error<"destructor cannot be variadic">;
def err_destructor_typedef_name : Error<
  "destructor cannot be declared using a %select{typedef|type alias}1 %0 of the class name">;
def err_destructor_name : Error<
  "expected the class name after '~' to name the enclosing class">;
def err_destructor_class_name : Error<
  "expected the class name after '~' to name a destructor">;
def err_ident_in_dtor_not_a_type : Error<
  "identifier %0 in object destruction expression does not name a type">;
def err_destructor_expr_type_mismatch : Error<
  "destructor type %0 in object destruction expression does not match the "
  "type %1 of the object being destroyed">;
def note_destructor_type_here : Note<
  "type %0 is declared here">;

def err_destructor_template : Error<
  "destructor cannot be declared as a template">;

// C++ initialization
def err_init_conversion_failed : Error<
  "cannot initialize %select{a variable|a parameter|return object|an "
  "exception object|a member subobject|an array element|a new value|a value|a "
  "base class|a constructor delegation|a vector element}0 "
  "%diff{of type $ with an %select{rvalue|lvalue}2 of type $|"
  "with an %select{rvalue|lvalue}2 of incompatible type}1,3"
  "%select{|: different classes%diff{ ($ vs $)|}5,6"
  "|: different number of parameters (%5 vs %6)"
  "|: type mismatch at %ordinal5 parameter%diff{ ($ vs $)|}6,7"
  "|: different return type%diff{ ($ vs $)|}5,6"
  "|: different qualifiers ("
  "%select{none|const|restrict|const and restrict|volatile|const and volatile|"
  "volatile and restrict|const, volatile, and restrict}5 vs "
  "%select{none|const|restrict|const and restrict|volatile|const and volatile|"
  "volatile and restrict|const, volatile, and restrict}6)}4">;

def err_lvalue_to_rvalue_ref : Error<"rvalue reference %diff{to type $ cannot "
  "bind to lvalue of type $|cannot bind to incompatible lvalue}0,1">;
def err_lvalue_reference_bind_to_initlist : Error<
  "%select{non-const|volatile}0 lvalue reference to type %1 cannot bind to an "
  "initializer list temporary">;
def err_lvalue_reference_bind_to_temporary : Error<
  "%select{non-const|volatile}0 lvalue reference %diff{to type $ cannot bind "
  "to a temporary of type $|cannot bind to incompatible temporary}1,2">;
def err_lvalue_reference_bind_to_unrelated : Error<
  "%select{non-const|volatile}0 lvalue reference "
  "%diff{to type $ cannot bind to a value of unrelated type $|"
  "cannot bind to a value of unrelated type}1,2">;
def err_reference_bind_drops_quals : Error<
  "binding of reference %diff{to type $ to a value of type $ drops qualifiers|"
  "drops qualifiers}0,1">;
def err_reference_bind_failed : Error<
  "reference %diff{to type $ could not bind to an %select{rvalue|lvalue}1 of "
  "type $|could not bind to %select{rvalue|lvalue}1 of incompatible type}0,2">;
def err_reference_bind_init_list : Error<
  "reference to type %0 cannot bind to an initializer list">;
def warn_temporary_array_to_pointer_decay : Warning<
  "pointer is initialized by a temporary array, which will be destroyed at the "
  "end of the full-expression">,
  InGroup<DiagGroup<"address-of-array-temporary">>;
def err_init_list_bad_dest_type : Error<
  "%select{|non-aggregate }0type %1 cannot be initialized with an initializer "
  "list">;
def err_member_function_call_bad_cvr : Error<"member function %0 not viable: "
    "'this' argument has type %1, but function is not marked "
    "%select{const|restrict|const or restrict|volatile|const or volatile|"
    "volatile or restrict|const, volatile, or restrict}2">;

def err_reference_bind_to_bitfield : Error<
  "%select{non-const|volatile}0 reference cannot bind to "
  "bit-field%select{| %1}2">;
def err_reference_bind_to_vector_element : Error<
  "%select{non-const|volatile}0 reference cannot bind to vector element">;
def err_reference_var_requires_init : Error<
  "declaration of reference variable %0 requires an initializer">;
def err_reference_without_init : Error<
  "reference to type %0 requires an initializer">;
def note_value_initialization_here : Note<
  "in value-initialization of type %0 here">;
def err_reference_has_multiple_inits : Error<
  "reference cannot be initialized with multiple values">;
def err_init_non_aggr_init_list : Error<
  "initialization of non-aggregate type %0 with an initializer list">;
def err_init_reference_member_uninitialized : Error<
  "reference member of type %0 uninitialized">;
def note_uninit_reference_member : Note<
  "uninitialized reference member is here">;
def warn_field_is_uninit : Warning<"field %0 is uninitialized when used here">,
  InGroup<Uninitialized>;
def warn_reference_field_is_uninit : Warning<
  "reference %0 is not yet bound to a value when used here">,
  InGroup<Uninitialized>;
def warn_static_self_reference_in_init : Warning<
  "static variable %0 is suspiciously used within its own initialization">,
  InGroup<UninitializedStaticSelfInit>;
def warn_uninit_self_reference_in_init : Warning<
  "variable %0 is uninitialized when used within its own initialization">,
  InGroup<Uninitialized>;
def warn_uninit_self_reference_in_reference_init : Warning<
  "reference %0 is not yet bound to a value when used within its own"
  " initialization">,
  InGroup<Uninitialized>;
def warn_uninit_var : Warning<
  "variable %0 is uninitialized when %select{used here|captured by block}1">,
  InGroup<Uninitialized>, DefaultIgnore;
def warn_sometimes_uninit_var : Warning<
  "variable %0 is %select{used|captured}1 uninitialized whenever "
  "%select{'%3' condition is %select{true|false}4|"
  "'%3' loop %select{is entered|exits because its condition is false}4|"
  "'%3' loop %select{condition is true|exits because its condition is false}4|"
  "switch %3 is taken}2">, InGroup<UninitializedSometimes>, DefaultIgnore;
def warn_maybe_uninit_var : Warning<
  "variable %0 may be uninitialized when "
  "%select{used here|captured by block}1">,
  InGroup<UninitializedMaybe>, DefaultIgnore;
def note_uninit_var_def : Note<"variable %0 is declared here">;
def note_uninit_var_use : Note<
  "%select{uninitialized use occurs|variable is captured by block}0 here">;
def warn_uninit_byref_blockvar_captured_by_block : Warning<
  "block pointer variable %0 is uninitialized when captured by block">,
  InGroup<Uninitialized>, DefaultIgnore;
def note_block_var_fixit_add_initialization : Note<
  "maybe you meant to use __block %0">;
def note_var_fixit_add_initialization : Note<
  "initialize the variable %0 to silence this warning">;
def note_uninit_fixit_remove_cond : Note<
  "remove the %select{'%1' if its condition|condition if it}0 "
  "is always %select{false|true}2">;
def err_init_incomplete_type : Error<"initialization of incomplete type %0">;

def warn_unsequenced_mod_mod : Warning<
  "multiple unsequenced modifications to %0">, InGroup<Unsequenced>;
def warn_unsequenced_mod_use : Warning<
  "unsequenced modification and access to %0">, InGroup<Unsequenced>;

def err_temp_copy_no_viable : Error<
  "no viable constructor %select{copying variable|copying parameter|"
  "returning object|throwing object|copying member subobject|copying array "
  "element|allocating object|copying temporary|initializing base subobject|"
  "initializing vector element|capturing value}0 of type %1">;
def ext_rvalue_to_reference_temp_copy_no_viable : ExtWarn<
  "no viable constructor %select{copying variable|copying parameter|"
  "returning object|throwing object|copying member subobject|copying array "
  "element|allocating object|copying temporary|initializing base subobject|"
  "initializing vector element|capturing value}0 of type %1; C++98 requires a copy "
  "constructor when binding a reference to a temporary">,
  InGroup<BindToTemporaryCopy>;
def err_temp_copy_ambiguous : Error<
  "ambiguous constructor call when %select{copying variable|copying "
  "parameter|returning object|throwing object|copying member subobject|copying "
  "array element|allocating object|copying temporary|initializing base subobject|"
  "initializing vector element|capturing value}0 of type %1">;
def err_temp_copy_deleted : Error<
  "%select{copying variable|copying parameter|returning object|throwing "
  "object|copying member subobject|copying array element|allocating object|"
  "copying temporary|initializing base subobject|initializing vector element|"
  "capturing value}0 of type %1 invokes deleted constructor">;
def err_temp_copy_incomplete : Error<
  "copying a temporary object of incomplete type %0">;
def warn_cxx98_compat_temp_copy : Warning<
  "%select{copying variable|copying parameter|returning object|throwing "
  "object|copying member subobject|copying array element|allocating object|"
  "copying temporary|initializing base subobject|initializing vector element}1 "
  "of type %2 when binding a reference to a temporary would %select{invoke "
  "an inaccessible constructor|find no viable constructor|find ambiguous "
  "constructors|invoke a deleted constructor}0 in C++98">,
  InGroup<CXX98CompatBindToTemporaryCopy>, DefaultIgnore;
def err_selected_explicit_constructor : Error<
  "chosen constructor is explicit in copy-initialization">;
def note_constructor_declared_here : Note<
  "constructor declared here">;

// C++11 decltype
def err_decltype_in_declarator : Error<
    "'decltype' cannot be used to name a declaration">;
    
// C++11 auto
def warn_cxx98_compat_auto_type_specifier : Warning<
  "'auto' type specifier is incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
def err_auto_variable_cannot_appear_in_own_initializer : Error<
  "variable %0 declared with 'auto' type cannot appear in its own initializer">;
def err_illegal_decl_array_of_auto : Error<
  "'%0' declared as array of %1">;
def err_new_array_of_auto : Error<
  "cannot allocate array of 'auto'">;
def err_auto_not_allowed : Error<
  "'auto' not allowed %select{in function prototype|in non-static struct member"
  "|in non-static union member|in non-static class member|in interface member"
  "|in exception declaration|in template parameter|in block literal"
  "|in template argument|in typedef|in type alias|in function return type"
  "|in conversion function type|here}0">;
def err_auto_var_requires_init : Error<
  "declaration of variable %0 with type %1 requires an initializer">;
def err_auto_new_requires_ctor_arg : Error<
  "new expression for type %0 requires a constructor argument">;
def err_auto_new_requires_parens : Error<
  "new expression for type %0 cannot use list-initialization">;
def err_auto_var_init_no_expression : Error<
  "initializer for variable %0 with type %1 is empty">;
def err_auto_var_init_multiple_expressions : Error<
  "initializer for variable %0 with type %1 contains multiple expressions">;
def err_auto_new_ctor_multiple_expressions : Error<
  "new expression for type %0 contains multiple constructor arguments">;
def err_auto_missing_trailing_return : Error<
  "'auto' return without trailing return type">;
def err_trailing_return_without_auto : Error<
  "function with trailing return type must specify return type 'auto', not %0">;
def err_trailing_return_in_parens : Error<
  "trailing return type may not be nested within parentheses">;
def err_auto_var_deduction_failure : Error<
  "variable %0 with type %1 has incompatible initializer of type %2">;
def err_auto_var_deduction_failure_from_init_list : Error<
  "cannot deduce actual type for variable %0 with type %1 from initializer list">;
def err_auto_new_deduction_failure : Error<
  "new expression for type %0 has incompatible constructor argument of type %1">;
def err_auto_different_deductions : Error<
  "'%select{auto|decltype(auto)}0' deduced as %1 in declaration of %2 and "
  "deduced as %3 in declaration of %4">;
def err_implied_std_initializer_list_not_found : Error<
  "cannot deduce type of initializer list because std::initializer_list was "
  "not found; include <initializer_list>">;
def err_malformed_std_initializer_list : Error<
  "std::initializer_list must be a class template with a single type parameter">;
def warn_dangling_std_initializer_list : Warning<
  "array backing the initializer list will be destroyed at the end of "
  "%select{the full-expression|the constructor}0">,
  InGroup<DiagGroup<"dangling-initializer-list">>;

// C++1y decltype(auto) type
def err_decltype_auto_cannot_be_combined : Error<
  "'decltype(auto)' cannot be combined with other type specifiers">;
def err_decltype_auto_function_declarator_not_declaration : Error<
  "'decltype(auto)' can only be used as a return type "
  "in a function declaration">;
def err_decltype_auto_compound_type : Error<
  "cannot form %select{pointer to|reference to|array of}0 'decltype(auto)'">;
def err_decltype_auto_initializer_list : Error<
  "cannot deduce 'decltype(auto)' from initializer list">;

// C++1y deduced return types
def err_auto_fn_deduction_failure : Error<
  "cannot deduce return type %0 from returned value of type %1">;
def err_auto_fn_different_deductions : Error<
  "'%select{auto|decltype(auto)}0' in return type deduced as %1 here but "
  "deduced as %2 in earlier return statement">;
def err_auto_fn_used_before_defined : Error<
  "function %0 with deduced return type cannot be used before it is defined">;
def err_auto_fn_no_return_but_not_auto : Error<
  "cannot deduce return type %0 for function with no return statements">;
def err_auto_fn_return_void_but_not_auto : Error<
  "cannot deduce return type %0 from omitted return expression">;
def err_auto_fn_return_init_list : Error<
  "cannot deduce return type from initializer list">;
def err_auto_fn_virtual : Error<
  "function with deduced return type cannot be virtual">;

// C++11 override control
def override_keyword_only_allowed_on_virtual_member_functions : Error<
  "only virtual member functions can be marked '%0'">;
def err_function_marked_override_not_overriding : Error<
  "%0 marked 'override' but does not override any member functions">;
def err_class_marked_final_used_as_base : Error<
  "base %0 is marked 'final'">;
def warn_abstract_final_class : Warning<
  "abstract class is marked 'final'">, InGroup<AbstractFinalClass>;

// C++11 attributes
def err_repeat_attribute : Error<"'%0' attribute cannot be repeated">;

// C++11 final
def err_final_function_overridden : Error<
  "declaration of %0 overrides a 'final' function">;

// C++11 scoped enumerations
def err_enum_invalid_underlying : Error<
  "non-integral type %0 is an invalid underlying type">;
def err_enumerator_too_large : Error<
  "enumerator value is not representable in the underlying type %0">;
def ext_enumerator_too_large : ExtWarn<
  "enumerator value is not representable in the underlying type %0">,
  InGroup<Microsoft>;
def err_enumerator_wrapped : Error<
  "enumerator value %0 is not representable in the underlying type %1">;
def err_enum_redeclare_type_mismatch : Error<
  "enumeration redeclared with different underlying type %0 (was %1)">;
def err_enum_redeclare_fixed_mismatch : Error<
  "enumeration previously declared with %select{non|}0fixed underlying type">;
def err_enum_redeclare_scoped_mismatch : Error<
  "enumeration previously declared as %select{un|}0scoped">;
def err_enum_class_reference : Error<
  "reference to %select{|scoped }0enumeration must use 'enum' "
  "not 'enum class'">;
def err_only_enums_have_underlying_types : Error<
  "only enumeration types have underlying types">;

// C++11 delegating constructors
def err_delegating_ctor : Error<
  "delegating constructors are permitted only in C++11">;
def warn_cxx98_compat_delegating_ctor : Warning<
  "delegating constructors are incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
def err_delegating_initializer_alone : Error<
  "an initializer for a delegating constructor must appear alone">;
def warn_delegating_ctor_cycle : Warning<
  "constructor for %0 creates a delegation cycle">, DefaultError,
  InGroup<DelegatingCtorCycles>;
def note_it_delegates_to : Note<"it delegates to">;
def note_which_delegates_to : Note<"which delegates to">;

// C++11 range-based for loop
def err_for_range_decl_must_be_var : Error<
  "for range declaration must declare a variable">;
def err_for_range_storage_class : Error<
  "loop variable %0 may not be declared %select{'extern'|'static'|"
  "'__private_extern__'|'auto'|'register'|'constexpr'}1">;
def err_type_defined_in_for_range : Error<
  "types may not be defined in a for range declaration">;
def err_for_range_deduction_failure : Error<
  "cannot use type %0 as a range">;
def err_for_range_incomplete_type : Error<
  "cannot use incomplete type %0 as a range">;
def err_for_range_iter_deduction_failure : Error<
  "cannot use type %0 as an iterator">;
def err_for_range_member_begin_end_mismatch : Error<
  "range type %0 has '%select{begin|end}1' member but no '%select{end|begin}1' member">;
def err_for_range_begin_end_types_differ : Error<
  "'begin' and 'end' must return the same type (got %0 and %1)">;
def note_in_for_range: Note<
  "when looking up '%select{begin|end}0' function for range expression "
  "of type %1">;
def err_for_range_invalid: Error<
  "invalid range expression of type %0; no viable '%select{begin|end}1' "
  "function available">;
def err_for_range_dereference : Error<
  "invalid range expression of type %0; did you mean to dereference it "
  "with '*'?">;
def note_for_range_invalid_iterator : Note <
  "in implicit call to 'operator%select{!=|*|++}0' for iterator of type %1">;
def note_for_range_begin_end : Note<
  "selected '%select{begin|end}0' %select{function|template }1%2 with iterator type %3">;

// C++11 constexpr
def warn_cxx98_compat_constexpr : Warning<
  "'constexpr' specifier is incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
// FIXME: Maybe this should also go in -Wc++1y-compat?
def warn_cxx1y_compat_constexpr_not_const : Warning<
  "'constexpr' non-static member function will not be implicitly 'const' "
  "in C++1y; add 'const' to avoid a change in behavior">,
  InGroup<DiagGroup<"constexpr-not-const">>;
def err_invalid_constexpr : Error<
  "%select{function parameter|typedef|non-static data member}0 "
  "cannot be constexpr">;
def err_invalid_constexpr_member : Error<"non-static data member cannot be "
  "constexpr%select{; did you intend to make it %select{const|static}0?|}1">;
def err_constexpr_tag : Error<
  "%select{class|struct|interface|union|enum}0 cannot be marked constexpr">;
def err_constexpr_dtor : Error<"destructor cannot be marked constexpr">;
def err_constexpr_no_declarators : Error<
  "constexpr can only be used in variable and function declarations">;
def err_invalid_constexpr_var_decl : Error<
  "constexpr variable declaration must be a definition">;
def err_constexpr_static_mem_var_requires_init : Error<
  "declaration of constexpr static data member %0 requires an initializer">;
def err_constexpr_var_non_literal : Error<
  "constexpr variable cannot have non-literal type %0">;
def err_constexpr_var_requires_const_init : Error<
  "constexpr variable %0 must be initialized by a constant expression">;
def err_constexpr_redecl_mismatch : Error<
  "%select{non-constexpr declaration of %0 follows constexpr declaration"
  "|constexpr declaration of %0 follows non-constexpr declaration}1">;
def err_constexpr_virtual : Error<"virtual function cannot be constexpr">;
def err_constexpr_virtual_base : Error<
  "constexpr %select{member function|constructor}0 not allowed in "
  "%select{struct|interface|class}1 with virtual base "
  "%plural{1:class|:classes}2">;
def note_non_literal_incomplete : Note<
  "incomplete type %0 is not a literal type">;
def note_non_literal_virtual_base : Note<"%select{struct|interface|class}0 "
  "with virtual base %plural{1:class|:classes}1 is not a literal type">;
def note_constexpr_virtual_base_here : Note<"virtual base class declared here">;
def err_constexpr_non_literal_return : Error<
  "constexpr function's return type %0 is not a literal type">;
def err_constexpr_non_literal_param : Error<
  "constexpr %select{function|constructor}1's %ordinal0 parameter type %2 is "
  "not a literal type">;
def err_constexpr_body_invalid_stmt : Error<
  "statement not allowed in constexpr %select{function|constructor}0">;
def ext_constexpr_body_invalid_stmt : ExtWarn<
  "use of this statement in a constexpr %select{function|constructor}0 "
  "is a C++1y extension">, InGroup<CXX1y>;
def warn_cxx11_compat_constexpr_body_invalid_stmt : Warning<
  "use of this statement in a constexpr %select{function|constructor}0 "
  "is incompatible with C++ standards before C++1y">,
  InGroup<CXXPre1yCompat>, DefaultIgnore;
def ext_constexpr_type_definition : ExtWarn<
  "type definition in a constexpr %select{function|constructor}0 "
  "is a C++1y extension">, InGroup<CXX1y>;
def warn_cxx11_compat_constexpr_type_definition : Warning<
  "type definition in a constexpr %select{function|constructor}0 "
  "is incompatible with C++ standards before C++1y">,
  InGroup<CXXPre1yCompat>, DefaultIgnore;
def err_constexpr_vla : Error<
  "variably-modified type %0 cannot be used in a constexpr "
  "%select{function|constructor}1">;
def ext_constexpr_local_var : ExtWarn<
  "variable declaration in a constexpr %select{function|constructor}0 "
  "is a C++1y extension">, InGroup<CXX1y>;
def warn_cxx11_compat_constexpr_local_var : Warning<
  "variable declaration in a constexpr %select{function|constructor}0 "
  "is incompatible with C++ standards before C++1y">,
  InGroup<CXXPre1yCompat>, DefaultIgnore;
def err_constexpr_local_var_static : Error<
  "%select{static|thread_local}1 variable not permitted in a constexpr "
  "%select{function|constructor}0">;
def err_constexpr_local_var_non_literal_type : Error<
  "variable of non-literal type %1 cannot be defined in a constexpr "
  "%select{function|constructor}0">;
def err_constexpr_local_var_no_init : Error<
  "variables defined in a constexpr %select{function|constructor}0 must be "
  "initialized">;
def ext_constexpr_function_never_constant_expr : ExtWarn<
  "constexpr %select{function|constructor}0 never produces a "
  "constant expression">, InGroup<DiagGroup<"invalid-constexpr">>, DefaultError;
def err_constexpr_body_no_return : Error<
  "no return statement in constexpr function">;
def warn_cxx11_compat_constexpr_body_no_return : Warning<
  "constexpr function with no return statements is incompatible with C++ "
  "standards before C++1y">, InGroup<CXXPre1yCompat>, DefaultIgnore;
def ext_constexpr_body_multiple_return : ExtWarn<
  "multiple return statements in constexpr function is a C++1y extension">,
  InGroup<CXX1y>;
def warn_cxx11_compat_constexpr_body_multiple_return : Warning<
  "multiple return statements in constexpr function "
  "is incompatible with C++ standards before C++1y">,
  InGroup<CXXPre1yCompat>, DefaultIgnore;
def note_constexpr_body_previous_return : Note<
  "previous return statement is here">;
def err_constexpr_function_try_block : Error<
  "function try block not allowed in constexpr %select{function|constructor}0">;
def err_constexpr_union_ctor_no_init : Error<
  "constexpr union constructor does not initialize any member">;
def err_constexpr_ctor_missing_init : Error<
  "constexpr constructor must initialize all members">;
def note_constexpr_ctor_missing_init : Note<
  "member not initialized by constructor">;
def err_constexpr_method_non_literal : Error<
  "non-literal type %0 cannot have constexpr members">;
def note_non_literal_no_constexpr_ctors : Note<
  "%0 is not literal because it is not an aggregate and has no constexpr "
  "constructors other than copy or move constructors">;
def note_non_literal_base_class : Note<
  "%0 is not literal because it has base class %1 of non-literal type">;
def note_non_literal_field : Note<
  "%0 is not literal because it has data member %1 of "
  "%select{non-literal|volatile}3 type %2">;
def note_non_literal_user_provided_dtor : Note<
  "%0 is not literal because it has a user-provided destructor">;
def note_non_literal_nontrivial_dtor : Note<
  "%0 is not literal because it has a non-trivial destructor">;
def warn_private_extern : Warning<
  "use of __private_extern__ on a declaration may not produce external symbol "
  "private to the linkage unit and is deprecated">, InGroup<PrivateExtern>;
def note_private_extern : Note<
  "use __attribute__((visibility(\"hidden\"))) attribute instead">;

// C++11 char16_t/char32_t
def warn_cxx98_compat_unicode_type : Warning<
  "'%0' type specifier is incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
 
// Objective-C++
def err_objc_decls_may_only_appear_in_global_scope : Error<
  "Objective-C declarations may only appear in global scope">;
def warn_auto_var_is_id : Warning<
  "'auto' deduced as 'id' in declaration of %0">,
  InGroup<DiagGroup<"auto-var-id">>;

// Attributes
def err_nsobject_attribute : Error<
  "__attribute ((NSObject)) is for pointer types only">;
def err_attribute_can_be_applied_only_to_symbol_declaration : Error<
  "%0 attribute can be applied only to symbol declaration">;
def err_attributes_are_not_compatible : Error<
  "%0 and %1 attributes are not compatible">;
def err_attribute_wrong_number_arguments : Error<
  "attribute %plural{0:takes no arguments|1:takes one argument|"
  ":requires exactly %0 arguments}0">;
def err_attribute_too_many_arguments : Error<
  "attribute takes no more than %0 argument%s0">;
def err_suppress_autosynthesis : Error<
  "objc_requires_property_definitions attribute may only be specified on a class"
  "to a class declaration">;
def err_attribute_too_few_arguments : Error<
  "attribute takes at least %0 argument%s0">;
def err_attribute_missing_parameter_name : Error<
  "attribute requires unquoted parameter">;
def err_attribute_invalid_vector_type : Error<"invalid vector element type %0">;
def err_attribute_bad_neon_vector_size : Error<
  "Neon vector size must be 64 or 128 bits">;
def err_attribute_argument_not_int : Error<
  "'%0' attribute requires integer constant">;
def err_aligned_attribute_argument_not_int : Error<
  "'aligned' attribute requires integer constant">;
def err_alignas_attribute_wrong_decl_type : Error<
  "'%select{alignas|_Alignas}0' attribute cannot be applied to a %select{"
  "function parameter|variable with 'register' storage class|"
  "'catch' variable|bit-field}1">;
def err_alignas_missing_on_definition : Error<
  "'%select{alignas|_Alignas}0' must be specified on definition if it is "
  "specified on any declaration">;
def note_alignas_on_declaration : Note<
  "declared with '%select{alignas|_Alignas}0' attribute here">;
def err_alignas_mismatch : Error<
  "redeclaration has different alignment requirement (%1 vs %0)">;
def err_alignas_underaligned : Error<
  "requested alignment is less than minimum alignment of %1 for type %0">;
def err_attribute_first_argument_not_int_or_bool : Error<
  "%0 attribute first argument must be of int or bool type">;
def err_attribute_argument_outof_range : Error<
  "init_priority attribute requires integer constant between "
  "101 and 65535 inclusive">;
def err_init_priority_object_attr : Error<
  "can only use 'init_priority' attribute on file-scope definitions "
  "of objects of class type">;
def err_attribute_argument_vec_type_hint : Error<
  "invalid attribute argument %0 - expecting a vector or vectorizable scalar type">;
def err_attribute_argument_n_not_int : Error<
  "'%0' attribute requires parameter %1 to be an integer constant">;
def err_attribute_argument_n_not_string : Error<
  "'%0' attribute requires parameter %1 to be a string">;
def err_attribute_argument_n_not_identifier : Error<
  "'%0' attribute requires parameter %1 to be an identifier">;
def err_attribute_argument_out_of_bounds : Error<
  "'%0' attribute parameter %1 is out of bounds">;
def err_attribute_requires_objc_interface : Error<
  "attribute may only be applied to an Objective-C interface">;
def err_attribute_uuid_malformed_guid : Error<
  "uuid attribute contains a malformed GUID">;
def warn_nonnull_pointers_only : Warning<
  "nonnull attribute only applies to pointer arguments">;
def err_attribute_pointers_only : Error<
  "%0 attribute only applies to pointer arguments">;
def err_attribute_no_member_pointers : Error<
  "%0 attribute cannot be used with pointers to members">;
def err_attribute_invalid_implicit_this_argument : Error<
  "'%0' attribute is invalid for the implicit this argument">;
def err_ownership_type : Error<
  "%0 attribute only applies to %1 arguments">;
def err_format_strftime_third_parameter : Error<
  "strftime format attribute requires 3rd parameter to be 0">;
def err_format_attribute_requires_variadic : Error<
  "format attribute requires variadic function">;
def err_format_attribute_not : Error<"format argument not %0">;
def err_format_attribute_result_not : Error<"function does not return %0">;
def err_format_attribute_implicit_this_format_string : Error<
  "format attribute cannot specify the implicit this argument as the format "
  "string">;
def warn_unknown_method_family : Warning<"unrecognized method family">;
def err_init_method_bad_return_type : Error<
  "init methods must return an object pointer type, not %0">;
def err_attribute_invalid_size : Error<
  "vector size not an integral multiple of component size">;
def err_attribute_zero_size : Error<"zero vector size">;
def err_typecheck_vector_not_convertable : Error<
  "can't convert between vector values of different size (%0 and %1)">;
def err_typecheck_ext_vector_not_typedef : Error<
  "ext_vector_type only applies to types, not variables">;
def err_ext_vector_component_exceeds_length : Error<
  "vector component access exceeds type %0">;
def err_ext_vector_component_name_illegal : Error<
  "illegal vector component name '%0'">;
def err_attribute_address_space_not_int : Error<
  "address space attribute requires an integer constant">;
def err_attribute_address_space_negative : Error<
  "address space is negative">;
def err_attribute_address_space_too_high : Error<
  "address space is larger than the maximum supported (%0)">;
def err_attribute_address_multiple_qualifiers : Error<
  "multiple address spaces specified for type">;
def err_attribute_address_function_type : Error<
  "function type may not be qualified with an address space">;
def err_as_qualified_auto_decl : Error<
  "automatic variable qualified with an address space">;
def err_arg_with_address_space : Error<
  "parameter may not be qualified with an address space">;
def err_field_with_address_space : Error<
  "field may not be qualified with an address space">;
def err_attr_objc_ownership_redundant : Error<
  "the type %0 is already explicitly ownership-qualified">;
def err_attribute_not_string : Error<
  "argument to %0 attribute was not a string literal">;
def err_undeclared_nsnumber : Error<
  "NSNumber must be available to use Objective-C literals">;
def err_invalid_nsnumber_type : Error<
  "%0 is not a valid literal type for NSNumber">;
def err_undeclared_nsstring : Error<
  "cannot box a string value because NSString has not been declared">;
def err_objc_illegal_boxed_expression_type : Error<
  "illegal type %0 used in a boxed expression">;
def err_objc_incomplete_boxed_expression_type : Error<
  "incomplete type %0 used in a boxed expression">;
def err_undeclared_nsarray : Error<
  "NSArray must be available to use Objective-C array literals">;
def err_undeclared_nsdictionary : Error<
  "NSDictionary must be available to use Objective-C dictionary "
  "literals">;
def err_undeclared_boxing_method : Error<
  "declaration of %0 is missing in %1 class">;
def err_objc_literal_method_sig : Error<
  "literal construction method %0 has incompatible signature">;
def note_objc_literal_method_param : Note<
  "%select{first|second|third}0 parameter has unexpected type %1 "
  "(should be %2)">;
def note_objc_literal_method_return : Note<
  "method returns unexpected type %0 (should be an object type)">;
def err_invalid_collection_element : Error<
  "collection element of type %0 is not an Objective-C object">;
def err_box_literal_collection : Error<
  "%select{string|character|boolean|numeric}0 literal must be prefixed by '@' "
  "in a collection">;
def warn_objc_literal_comparison : Warning<
  "direct comparison of %select{an array literal|a dictionary literal|"
  "a numeric literal|a boxed expression|}0 has undefined behavior">,
  InGroup<ObjCLiteralComparison>;
def warn_missing_atsign_prefix : Warning<
  "string literal must be prefixed by '@' ">, InGroup<ObjCLiteralMissingAtSign>;
def warn_objc_string_literal_comparison : Warning<
  "direct comparison of a string literal has undefined behavior">, 
  InGroup<ObjCStringComparison>;
def note_objc_literal_comparison_isequal : Note<
  "use 'isEqual:' instead">;

let CategoryName = "Cocoa API Issue" in {
def warn_objc_redundant_literal_use : Warning<
  "using %0 with a literal is redundant">, InGroup<ObjCRedundantLiteralUse>;
}

def err_attr_tlsmodel_arg : Error<"tls_model must be \"global-dynamic\", "
  "\"local-dynamic\", \"initial-exec\" or \"local-exec\"">;

def err_only_annotate_after_access_spec : Error<
  "access specifier can only have annotation attributes">;

def err_attribute_section_invalid_for_target : Error<
  "argument to 'section' attribute is not valid for this target: %0">;
def err_attribute_section_local_variable : Error<
  "'section' attribute is not valid on local variables">;
def warn_mismatched_section : Warning<
  "section does not match previous declaration">, InGroup<Section>;

def err_anonymous_property: Error<
  "anonymous property is not supported">;
def err_property_is_variably_modified: Error<
  "property '%0' has a variably modified type">;
def err_no_getter_for_property : Error<
  "no getter defined for property '%0'">;
def err_no_setter_for_property : Error<
  "no setter defined for property '%0'">;
def error_cannot_find_suitable_getter : Error<
  "cannot find suitable getter for property '%0'">;
def error_cannot_find_suitable_setter : Error<
  "cannot find suitable setter for property '%0'">;

def err_attribute_aligned_not_power_of_two : Error<
  "requested alignment is not a power of 2">;
def err_attribute_aligned_greater_than_8192 : Error<
  "requested alignment must be 8192 bytes or smaller">;
def warn_redeclaration_without_attribute_prev_attribute_ignored : Warning<
  "'%0' redeclared without %1 attribute: previous %1 ignored">;
def warn_attribute_ignored : Warning<"%0 attribute ignored">,
  InGroup<IgnoredAttributes>;
def warn_attribute_after_definition_ignored : Warning<
  "attribute %0 after definition is ignored">,
   InGroup<IgnoredAttributes>;
def warn_unknown_attribute_ignored : Warning<
  "unknown attribute %0 ignored">, InGroup<UnknownAttributes>;
def warn_cxx11_gnu_attribute_on_type : Warning<
  "attribute %0 ignored, because it cannot be applied to a type">,
  InGroup<IgnoredAttributes>;
def warn_unhandled_ms_attribute_ignored : Warning<
  "__declspec attribute %0 is not supported">, 
  InGroup<IgnoredAttributes>;
def err_attribute_invalid_on_stmt : Error<
  "%0 attribute cannot be applied to a statement">;
def warn_declspec_attribute_ignored : Warning<
  "attribute %0 is ignored, place it after "
  "\"%select{class|struct|union|interface|enum}1\" to apply attribute to "
  "type declaration">, InGroup<IgnoredAttributes>;
def warn_attribute_precede_definition : Warning<
  "attribute declaration must precede definition">,
  InGroup<IgnoredAttributes>;
def warn_attribute_void_function_method : Warning<
  "attribute %0 cannot be applied to "
  "%select{functions|Objective-C method}1 without return value">,
  InGroup<IgnoredAttributes>;
def warn_attribute_weak_on_field : Warning<
  "__weak attribute cannot be specified on a field declaration">,
  InGroup<IgnoredAttributes>;
def warn_gc_attribute_weak_on_local : Warning<
  "Objective-C GC does not allow weak variables on the stack">,
  InGroup<IgnoredAttributes>;
def warn_nsobject_attribute : Warning<
  "__attribute ((NSObject)) may be put on a typedef only, "
  "attribute is ignored">, InGroup<NSobjectAttribute>;
def warn_attribute_weak_on_local : Warning<
  "__weak attribute cannot be specified on an automatic variable when ARC "
  "is not enabled">,
  InGroup<IgnoredAttributes>;
def warn_weak_identifier_undeclared : Warning<
  "weak identifier %0 never declared">;
def err_attribute_weak_static : Error<
  "weak declaration cannot have internal linkage">;
def err_attribute_selectany_non_extern_data : Error<
  "'selectany' can only be applied to data items with external linkage">;
def warn_attribute_invalid_on_definition : Warning<
  "'%0' attribute cannot be specified on a definition">,
  InGroup<IgnoredAttributes>;
def err_attribute_weakref_not_static : Error<
  "weakref declaration must have internal linkage">;
def err_attribute_weakref_not_global_context : Error<
  "weakref declaration of '%0' must be in a global context">;
def err_attribute_weakref_without_alias : Error<
  "weakref declaration of '%0' must also have an alias attribute">;
def err_alias_not_supported_on_darwin : Error <
  "only weak aliases are supported on darwin">;
def warn_attribute_wrong_decl_type : Warning<
  "%0 attribute only applies to %select{functions|unions|"
  "variables and functions|functions and methods|parameters|"
  "functions, methods and blocks|functions, methods, and classes|"
  "functions, methods, and parameters|classes|variables|methods|"
  "variables, functions and labels|fields and global variables|structs|"
  "variables, functions and tag types|thread-local variables|"
  "variables and fields|variables, data members and tag types|"
  "types and namespaces}1">,
  InGroup<IgnoredAttributes>;
def err_attribute_wrong_decl_type : Error<
  "%0 attribute only applies to %select{functions|unions|"
  "variables and functions|functions and methods|parameters|"
  "functions, methods and blocks|functions, methods, and classes|"
  "functions, methods, and parameters|classes|variables|methods|"
  "variables, functions and labels|fields and global variables|structs|"
  "variables, functions and tag types|thread-local variables|"
  "variables and fields|variables, data members and tag types|"
  "types and namespaces}1">;
def warn_function_attribute_wrong_type : Warning<
  "'%0' only applies to function types; type here is %1">,
  InGroup<IgnoredAttributes>;
def warn_pointer_attribute_wrong_type : Warning<
  "'%0' only applies to pointer types; type here is %1">,
  InGroup<IgnoredAttributes>;
def warn_objc_object_attribute_wrong_type : Warning<
  "'%0' only applies to Objective-C object or block pointer types; type here is %1">,
  InGroup<IgnoredAttributes>;
def warn_attribute_requires_functions_or_static_globals : Warning<
  "%0 only applies to variables with static storage duration and functions">,
  InGroup<IgnoredAttributes>;
def warn_gnu_inline_attribute_requires_inline : Warning<
  "'gnu_inline' attribute requires function to be marked 'inline',"
  " attribute ignored">,
  InGroup<IgnoredAttributes>;
def err_attribute_vecreturn_only_vector_member : Error<
  "the vecreturn attribute can only be used on a class or structure with one member, which must be a vector">;
def err_attribute_vecreturn_only_pod_record : Error<
  "the vecreturn attribute can only be used on a POD (plain old data) class or structure (i.e. no virtual functions)">;
def err_cconv_change : Error<
  "function declared '%0' here was previously declared "
  "%select{'%2'|without calling convention}1">;
def warn_cconv_ignored : Warning<
  "calling convention %0 ignored for this target">, InGroup<IgnoredAttributes>;
def err_cconv_knr : Error<
  "function with no prototype cannot use %0 calling convention">;
def err_cconv_varargs : Error<
  "variadic function cannot use %0 calling convention">;
def err_regparm_mismatch : Error<"function declared with regparm(%0) "
  "attribute was previously declared "
  "%plural{0:without the regparm|:with the regparm(%1)}1 attribute">;
def err_returns_retained_mismatch : Error<
  "function declared with the ns_returns_retained attribute "
  "was previously declared without the ns_returns_retained attribute">;
def err_objc_precise_lifetime_bad_type : Error<
  "objc_precise_lifetime only applies to retainable types; type here is %0">;
def warn_objc_precise_lifetime_meaningless : Error<
  "objc_precise_lifetime is not meaningful for "
  "%select{__unsafe_unretained|__autoreleasing}0 objects">;
def err_invalid_pcs : Error<"invalid PCS type">;
def err_attribute_can_be_applied_only_to_value_decl : Error<
  "%0 attribute can only be applied to value declarations">;
def warn_attribute_not_on_decl : Warning<
  "%0 attribute ignored when parsing type">, InGroup<IgnoredAttributes>;
def err_base_specifier_attribute : Error<
  "%0 attribute cannot be applied to a base specifier">;

// Availability attribute
def warn_availability_unknown_platform : Warning<
  "unknown platform %0 in availability macro">, InGroup<Availability>;
def warn_availability_version_ordering : Warning<
  "feature cannot be %select{introduced|deprecated|obsoleted}0 in %1 version "
  "%2 before it was %select{introduced|deprecated|obsoleted}3 in version %4; "
  "attribute ignored">, InGroup<Availability>;
def warn_mismatched_availability: Warning<
  "availability does not match previous declaration">, InGroup<Availability>;
def warn_mismatched_availability_override : Warning<
  "overriding method %select{introduced after|"
  "deprecated before|obsoleted before}0 overridden method on %1 (%2 vs. %3)">, 
  InGroup<Availability>;
def warn_mismatched_availability_override_unavail : Warning<
  "overriding method cannot be unavailable on %0 when its overridden method is "
  "available">,
  InGroup<Availability>;
def note_overridden_method : Note<
  "overridden method is here">;

// Thread Safety Attributes
def warn_thread_attribute_ignored : Warning<
  "ignoring %0 attribute because its argument is invalid">,
  InGroup<ThreadSafetyAttributes>, DefaultIgnore;
def warn_thread_attribute_argument_not_lockable : Warning<
  "%0 attribute requires arguments whose type is annotated "
  "with 'lockable' attribute; type here is '%1'">,
  InGroup<ThreadSafetyAttributes>, DefaultIgnore;
def warn_thread_attribute_argument_not_class : Warning<
  "%0 attribute requires arguments that are class type or point to"
  " class type; type here is '%1'">,
  InGroup<ThreadSafetyAttributes>, DefaultIgnore;  
def warn_thread_attribute_decl_not_lockable : Warning<
  "%0 attribute can only be applied in a context annotated "
  "with 'lockable' attribute">,
  InGroup<ThreadSafetyAttributes>, DefaultIgnore;
def warn_thread_attribute_decl_not_pointer : Warning<
  "'%0' only applies to pointer types; type here is %1">,
  InGroup<ThreadSafetyAttributes>, DefaultIgnore;
def warn_thread_attribute_wrong_decl_type : Warning<
  "%0 attribute only applies to %select{"
  "fields and global variables|functions and methods|"
  "classes and structs}1">,
  InGroup<ThreadSafetyAttributes>, DefaultIgnore;  
def err_attribute_argument_out_of_range : Error<
  "%0 attribute parameter %1 is out of bounds: "
  "%plural{0:no parameters to index into|"
  "1:can only be 1, since there is one parameter|"
  ":must be between 1 and %2}2">;

// Thread Safety Analysis   
def warn_unlock_but_no_lock : Warning<
  "unlocking '%0' that was not locked">,
  InGroup<ThreadSafetyAnalysis>, DefaultIgnore;
def warn_double_lock : Warning<
  "locking '%0' that is already locked">,
  InGroup<ThreadSafetyAnalysis>, DefaultIgnore;
def warn_no_unlock : Warning<
  "mutex '%0' is still locked at the end of function">,
  InGroup<ThreadSafetyAnalysis>, DefaultIgnore;
def warn_expecting_locked : Warning<
  "expecting mutex '%0' to be locked at the end of function">,
  InGroup<ThreadSafetyAnalysis>, DefaultIgnore;  
// FIXME: improve the error message about locks not in scope
def warn_lock_some_predecessors : Warning<
  "mutex '%0' is not locked on every path through here">,
  InGroup<ThreadSafetyAnalysis>, DefaultIgnore;
def warn_expecting_lock_held_on_loop : Warning<
  "expecting mutex '%0' to be locked at start of each loop">,
  InGroup<ThreadSafetyAnalysis>, DefaultIgnore;
def note_locked_here : Note<"mutex acquired here">;
def warn_lock_exclusive_and_shared : Warning<
  "mutex '%0' is locked exclusively and shared in the same scope">,
  InGroup<ThreadSafetyAnalysis>, DefaultIgnore;
def note_lock_exclusive_and_shared : Note<
  "the other lock of mutex '%0' is here">;
def warn_variable_requires_any_lock : Warning<
  "%select{reading|writing}1 variable '%0' requires locking "
  "%select{any mutex|any mutex exclusively}1">,
  InGroup<ThreadSafetyAnalysis>, DefaultIgnore;
def warn_var_deref_requires_any_lock : Warning<
  "%select{reading|writing}1 the value pointed to by '%0' requires locking "
  "%select{any mutex|any mutex exclusively}1">,
  InGroup<ThreadSafetyAnalysis>, DefaultIgnore;
def warn_fun_excludes_mutex : Warning<
  "cannot call function '%0' while mutex '%1' is locked">,
  InGroup<ThreadSafetyAnalysis>, DefaultIgnore;
def warn_cannot_resolve_lock : Warning<
  "cannot resolve lock expression">,
  InGroup<ThreadSafetyAnalysis>, DefaultIgnore;

// Imprecise thread safety warnings
def warn_variable_requires_lock : Warning<
  "%select{reading|writing}2 variable '%0' requires locking "
  "%select{'%1'|'%1' exclusively}2">,
  InGroup<ThreadSafetyAnalysis>, DefaultIgnore;
def warn_var_deref_requires_lock : Warning<
  "%select{reading|writing}2 the value pointed to by '%0' requires locking "
  "%select{'%1'|'%1' exclusively}2">,
  InGroup<ThreadSafetyAnalysis>, DefaultIgnore;
def warn_fun_requires_lock : Warning<
  "calling function '%0' requires %select{shared|exclusive}2 lock on '%1'">,
  InGroup<ThreadSafetyAnalysis>, DefaultIgnore;

// Precise thread safety warnings
def warn_variable_requires_lock_precise : Warning<
  "%select{reading|writing}2 variable '%0' requires locking "
  "%select{'%1'|'%1' exclusively}2">,
  InGroup<ThreadSafetyPrecise>, DefaultIgnore;
def warn_var_deref_requires_lock_precise : Warning<
  "%select{reading|writing}2 the value pointed to by '%0' requires locking "
  "%select{'%1'|'%1' exclusively}2">,
  InGroup<ThreadSafetyPrecise>, DefaultIgnore;
def warn_fun_requires_lock_precise : Warning<
  "calling function '%0' requires %select{shared|exclusive}2 lock on '%1'">,
  InGroup<ThreadSafetyPrecise>, DefaultIgnore;
def note_found_mutex_near_match : Note<"found near match '%0'">;

// Dummy warning that will trigger "beta" warnings from the analysis if enabled. 
def warn_thread_safety_beta : Warning<
  "Thread safety beta warning.">, InGroup<ThreadSafetyBeta>, DefaultIgnore;

def warn_impcast_vector_scalar : Warning<
  "implicit conversion turns vector to scalar: %0 to %1">,
  InGroup<Conversion>, DefaultIgnore;
def warn_impcast_complex_scalar : Warning<
  "implicit conversion discards imaginary component: %0 to %1">,
  InGroup<Conversion>, DefaultIgnore;
def warn_impcast_float_precision : Warning<
  "implicit conversion loses floating-point precision: %0 to %1">,
  InGroup<Conversion>, DefaultIgnore;
def warn_impcast_float_integer : Warning<
  "implicit conversion turns floating-point number into integer: %0 to %1">,
  InGroup<Conversion>, DefaultIgnore;
def warn_impcast_integer_sign : Warning<
  "implicit conversion changes signedness: %0 to %1">,
  InGroup<SignConversion>, DefaultIgnore;
def warn_impcast_integer_sign_conditional : Warning<
  "operand of ? changes signedness: %0 to %1">,
  InGroup<SignConversion>, DefaultIgnore;
def warn_impcast_integer_precision : Warning<
  "implicit conversion loses integer precision: %0 to %1">,
  InGroup<Conversion>, DefaultIgnore;
def warn_impcast_integer_64_32 : Warning<
  "implicit conversion loses integer precision: %0 to %1">,
  InGroup<Shorten64To32>, DefaultIgnore;
def warn_impcast_integer_precision_constant : Warning<
  "implicit conversion from %2 to %3 changes value from %0 to %1">,
  InGroup<ConstantConversion>;
def warn_impcast_bitfield_precision_constant : Warning<
  "implicit truncation from %2 to bitfield changes value from %0 to %1">,
  InGroup<BitFieldConstantConversion>;
def warn_impcast_literal_float_to_integer : Warning<
  "implicit conversion from %0 to %1 changes value from %2 to %3">,
  InGroup<LiteralConversion>;
def warn_impcast_string_literal_to_bool : Warning<
  "implicit conversion turns string literal into bool: %0 to %1">,
  InGroup<StringConversion>, DefaultIgnore;
def warn_impcast_different_enum_types : Warning<
  "implicit conversion from enumeration type %0 to different enumeration type "
  "%1">, InGroup<EnumConversion>;
def warn_impcast_bool_to_null_pointer : Warning<
    "initialization of pointer of type %0 to null from a constant boolean "
    "expression">, InGroup<BoolConversion>;
def warn_non_literal_null_pointer : Warning<
    "expression which evaluates to zero treated as a null pointer constant of "
    "type %0">, InGroup<NonLiteralNullConversion>;
def warn_impcast_null_pointer_to_integer : Warning<
    "implicit conversion of NULL constant to %0">,
    InGroup<NullConversion>;
def warn_impcast_floating_point_to_bool : Warning<
    "implicit conversion turns floating-point number into bool: %0 to %1">,
    InGroup<ImplicitConversionFloatingPointToBool>;
def warn_impcast_function_to_bool : Warning<
    "address of function %q0 will always evaluate to 'true'">,
    InGroup<BoolConversion>;
def note_function_to_bool_silence : Note<
    "prefix with the address-of operator to silence this warning">;
def note_function_to_bool_call : Note<
    "suffix with parentheses to turn this into a function call">;

def warn_cast_align : Warning<
  "cast from %0 to %1 increases required alignment from %2 to %3">,
  InGroup<CastAlign>, DefaultIgnore;

// Separate between casts to void* and non-void* pointers.
// Some APIs use (abuse) void* for something like a user context,
// and often that value is an integer even if it isn't a pointer itself.
// Having a separate warning flag allows users to control the warning
// for their workflow.
def warn_int_to_pointer_cast : Warning<
  "cast to %1 from smaller integer type %0">,
  InGroup<IntToPointerCast>;
def warn_int_to_void_pointer_cast : Warning<
  "cast to %1 from smaller integer type %0">,
  InGroup<IntToVoidPointerCast>;

def warn_attribute_ignored_for_field_of_type : Warning<
  "%0 attribute ignored for field of type %1">,
  InGroup<IgnoredAttributes>;
def warn_transparent_union_attribute_field_size_align : Warning<
  "%select{alignment|size}0 of field %1 (%2 bits) does not match the "
  "%select{alignment|size}0 of the first field in transparent union; "
  "transparent_union attribute ignored">,
  InGroup<IgnoredAttributes>;
def note_transparent_union_first_field_size_align : Note<
  "%select{alignment|size}0 of first field is %1 bits">;
def warn_transparent_union_attribute_not_definition : Warning<
  "transparent_union attribute can only be applied to a union definition; "
  "attribute ignored">,
  InGroup<IgnoredAttributes>;
def warn_transparent_union_attribute_floating : Warning<
  "first field of a transparent union cannot have %select{floating point|"
  "vector}0 type %1; transparent_union attribute ignored">,
  InGroup<IgnoredAttributes>;
def warn_transparent_union_attribute_zero_fields : Warning<
  "transparent union definition must contain at least one field; "
  "transparent_union attribute ignored">,
  InGroup<IgnoredAttributes>;
def warn_attribute_type_not_supported : Warning<
  "'%0' attribute argument not supported: %1">,
  InGroup<IgnoredAttributes>;
def warn_attribute_unknown_visibility : Warning<"unknown visibility '%0'">,
  InGroup<IgnoredAttributes>;
def warn_attribute_protected_visibility :
  Warning<"target does not support 'protected' visibility; using 'default'">,
  InGroup<DiagGroup<"unsupported-visibility">>;
def err_mismatched_visibility: Error<"visibility does not match previous declaration">;
def warn_attribute_unknown_endian : Warning<"unknown endian '%0'">,
  InGroup<IgnoredAttributes>;
def note_previous_attribute : Note<"previous attribute is here">;
def err_unknown_machine_mode : Error<"unknown machine mode %0">;
def err_unsupported_machine_mode : Error<"unsupported machine mode %0">;
def err_mode_not_primitive : Error<
  "mode attribute only supported for integer and floating-point types">;
def err_mode_wrong_type : Error<
  "type of machine mode does not match type of base type">;
def err_attr_wrong_decl : Error<
  "'%0' attribute invalid on this declaration, requires typedef or value">;
def warn_attribute_nonnull_no_pointers : Warning<
  "'nonnull' attribute applied to function with no pointer arguments">,
  InGroup<IgnoredAttributes>;
def warn_attribute_malloc_pointer_only : Warning<
  "'malloc' attribute only applies to functions returning a pointer type">,
  InGroup<IgnoredAttributes>;
def warn_attribute_sentinel_named_arguments : Warning<
  "'sentinel' attribute requires named arguments">,
  InGroup<IgnoredAttributes>;
def warn_attribute_sentinel_not_variadic : Warning<
  "'sentinel' attribute only supported for variadic %select{functions|blocks}0">,
  InGroup<IgnoredAttributes>;
def err_attribute_sentinel_less_than_zero : Error<
  "'sentinel' parameter 1 less than zero">;
def err_attribute_sentinel_not_zero_or_one : Error<
  "'sentinel' parameter 2 not 0 or 1">;
def err_attribute_cleanup_arg_not_found : Error<
  "'cleanup' argument %0 not found">;
def err_attribute_cleanup_arg_not_function : Error<
  "'cleanup' argument %0 is not a function">;
def err_attribute_cleanup_func_must_take_one_arg : Error<
  "'cleanup' function %0 must take 1 parameter">;
def err_attribute_cleanup_func_arg_incompatible_type : Error<
  "'cleanup' function %0 parameter has "
  "%diff{type $ which is incompatible with type $|incompatible type}1,2">;
def err_attribute_regparm_wrong_platform : Error<
  "'regparm' is not valid on this platform">;
def err_attribute_regparm_invalid_number : Error<
  "'regparm' parameter must be between 0 and %0 inclusive">;


// Clang-Specific Attributes
def warn_attribute_iboutlet : Warning<
  "%0 attribute can only be applied to instance variables or properties">,
  InGroup<IgnoredAttributes>;
def warn_attribute_ibaction: Warning<
  "ibaction attribute can only be applied to Objective-C instance methods">,
  InGroup<IgnoredAttributes>;
def err_iboutletcollection_type : Error<
  "invalid type %0 as argument of iboutletcollection attribute">;
def warn_iboutlet_object_type : Warning<
  "%select{instance variable|property}2 with %0 attribute must "
  "be an object type (invalid %1)">,
  InGroup<DiagGroup<"invalid-iboutlet">>;
def err_attribute_overloadable_not_function : Error<
  "'overloadable' attribute can only be applied to a function">;
def err_attribute_overloadable_missing : Error<
  "%select{overloaded function|redeclaration of}0 %1 must have the "
  "'overloadable' attribute">;
def note_attribute_overloadable_prev_overload : Note<
  "previous overload of function is here">;
def err_attribute_overloadable_no_prototype : Error<
  "'overloadable' function %0 must have a prototype">;
def warn_ns_attribute_wrong_return_type : Warning<
  "%0 attribute only applies to %select{functions|methods}1 that "
  "return %select{an Objective-C object|a pointer|a non-retainable pointer}2">,
  InGroup<IgnoredAttributes>;
def warn_ns_attribute_wrong_parameter_type : Warning<
  "%0 attribute only applies to %select{Objective-C object|pointer}1 "
  "parameters">,
  InGroup<IgnoredAttributes>;
def warn_objc_requires_super_protocol : Warning<
  "%0 attribute cannot be applied to %select{methods in protocols|dealloc}1">,
  InGroup<DiagGroup<"requires-super-attribute">>;
def note_protocol_decl : Note<
  "protocol is declared here">;

def err_ns_bridged_not_interface : Error<
  "parameter of 'ns_bridged' attribute does not name an Objective-C class">;

// Function Parameter Semantic Analysis.
def err_param_with_void_type : Error<"argument may not have 'void' type">;
def err_void_only_param : Error<
  "'void' must be the first and only parameter if specified">;
def err_void_param_qualified : Error<
  "'void' as parameter must not have type qualifiers">;
def err_ident_list_in_fn_declaration : Error<
  "a parameter list without types is only allowed in a function definition">;
def ext_param_not_declared : Extension<
  "parameter %0 was not declared, defaulting to type 'int'">;
def err_param_typedef_of_void : Error<
  "empty parameter list defined with a %select{typedef|type alias}0 of 'void' not allowed%select{ in C++|}0">;
def err_param_default_argument : Error<
  "C does not support default arguments">;
def err_param_default_argument_redefinition : Error<
  "redefinition of default argument">;
def warn_param_default_argument_redefinition : ExtWarn<
  "redefinition of default argument">;
def err_param_default_argument_missing : Error<
  "missing default argument on parameter">;
def err_param_default_argument_missing_name : Error<
  "missing default argument on parameter %0">;
def err_param_default_argument_references_param : Error<
  "default argument references parameter %0">;
def err_param_default_argument_references_local : Error<
  "default argument references local variable %0 of enclosing function">;
def err_param_default_argument_references_this : Error<
  "default argument references 'this'">;
def err_param_default_argument_nonfunc : Error<
  "default arguments can only be specified for parameters in a function "
  "declaration">;
def err_param_default_argument_template_redecl : Error<
  "default arguments cannot be added to a function template that has already "
  "been declared">;
def err_param_default_argument_member_template_redecl : Error<
  "default arguments cannot be added to an out-of-line definition of a member "
  "of a %select{class template|class template partial specialization|nested "
  "class in a template}0">;
def err_uninitialized_member_for_assign : Error<
  "cannot define the implicit copy assignment operator for %0, because "
  "non-static %select{reference|const}1 member %2 can't use copy "
  "assignment operator">;
def err_uninitialized_member_in_ctor : Error<
  "%select{|implicit default |inheriting }0constructor for %1 must explicitly "
  "initialize the %select{reference|const}2 member %3">;
def err_default_arg_makes_ctor_special : Error<
  "addition of default argument on redeclaration makes this constructor a "
  "%select{default|copy|move}0 constructor">;

def err_use_of_default_argument_to_function_declared_later : Error<
  "use of default argument to function %0 that is declared later in class %1">;
def note_default_argument_declared_here : Note<
  "default argument declared here">;

def ext_param_promoted_not_compatible_with_prototype : ExtWarn<
  "%diff{promoted type $ of K&R function parameter is not compatible with the "
  "parameter type $|promoted type of K&R function parameter is not compatible "
  "with parameter type}0,1 declared in a previous prototype">,
  InGroup<KNRPromotedParameter>;


// C++ Overloading Semantic Analysis.
def err_ovl_diff_return_type : Error<
  "functions that differ only in their return type cannot be overloaded">;
def err_ovl_static_nonstatic_member : Error<
  "static and non-static member functions with the same parameter types "
  "cannot be overloaded">;

def err_ovl_no_viable_function_in_call : Error<
  "no matching function for call to %0">;
def err_ovl_no_viable_member_function_in_call : Error<
  "no matching member function for call to %0">;
def err_ovl_ambiguous_call : Error<
  "call to %0 is ambiguous">;
def err_ovl_deleted_call : Error<
  "call to %select{unavailable|deleted}0 function %1%2">;
def err_ovl_ambiguous_member_call : Error<
  "call to member function %0 is ambiguous">;
def err_ovl_deleted_member_call : Error<
  "call to %select{unavailable|deleted}0 member function %1%2">;
def note_ovl_too_many_candidates : Note<
    "remaining %0 candidate%s0 omitted; "
    "pass -fshow-overloads=all to show them">;
def note_ovl_candidate : Note<"candidate "
    "%select{function|function|constructor|"
    "function |function |constructor |"
    "is the implicit default constructor|"
    "is the implicit copy constructor|"
    "is the implicit move constructor|"
    "is the implicit copy assignment operator|"
    "is the implicit move assignment operator|"
    "is an inherited constructor}0%1"
    "%select{| has different class%diff{ (expected $ but has $)|}3,4"
    "| has different number of parameters (expected %3 but has %4)"
    "| has type mismatch at %ordinal3 parameter"
    "%diff{ (expected $ but has $)|}4,5"
    "| has different return type%diff{ ($ expected but has $)|}3,4"
    "| has different qualifiers (expected "
    "%select{none|const|restrict|const and restrict|volatile|const and volatile"
    "|volatile and restrict|const, volatile, and restrict}3 but found "
    "%select{none|const|restrict|const and restrict|volatile|const and volatile"
    "|volatile and restrict|const, volatile, and restrict}4)}2">;

def note_ovl_candidate_inherited_constructor : Note<"inherited from here">;
def note_ovl_candidate_bad_deduction : Note<
    "candidate template ignored: failed template argument deduction">;
def note_ovl_candidate_incomplete_deduction : Note<"candidate template ignored: "
    "couldn't infer template argument %0">;
def note_ovl_candidate_inconsistent_deduction : Note<
    "candidate template ignored: deduced conflicting %select{types|values|"
    "templates}0 for parameter %1%diff{ ($ vs. $)|}2,3">;
def note_ovl_candidate_explicit_arg_mismatch_named : Note<
    "candidate template ignored: invalid explicitly-specified argument "
    "for template parameter %0">;
def note_ovl_candidate_explicit_arg_mismatch_unnamed : Note<
    "candidate template ignored: invalid explicitly-specified argument "
    "for %ordinal0 template parameter">;
def note_ovl_candidate_instantiation_depth : Note<
    "candidate template ignored: substitution exceeded maximum template "
    "instantiation depth">;
def note_ovl_candidate_underqualified : Note<
    "candidate template ignored: can't deduce a type for %0 which would "
    "make %2 equal %1">;
def note_ovl_candidate_substitution_failure : Note<
    "candidate template ignored: substitution failure%0%1">;
def note_ovl_candidate_disabled_by_enable_if : Note<
    "candidate template ignored: disabled by %0%1">;
def note_ovl_candidate_failed_overload_resolution : Note<
    "candidate template ignored: couldn't resolve reference to overloaded "
    "function %0">;
def note_ovl_candidate_non_deduced_mismatch : Note<
    "candidate template ignored: could not match %diff{$ against $|types}0,1">;
// This note is needed because the above note would sometimes print two
// different types with the same name.  Remove this note when the above note
// can handle that case properly.
def note_ovl_candidate_non_deduced_mismatch_qualified : Note<
    "candidate template ignored: could not match %q0 against %q1">;
    
// Note that we don't treat templates differently for this diagnostic.
def note_ovl_candidate_arity : Note<"candidate "
    "%select{function|function|constructor|function|function|constructor|"
    "constructor (the implicit default constructor)|"
    "constructor (the implicit copy constructor)|"
    "constructor (the implicit move constructor)|"
    "function (the implicit copy assignment operator)|"
    "function (the implicit move assignment operator)|"
    "constructor (inherited)}0 %select{|template }1"
    "not viable: requires%select{ at least| at most|}2 %3 argument%s3, but %4 "
    "%plural{1:was|:were}4 provided">;

def note_ovl_candidate_arity_one : Note<"candidate "
    "%select{function|function|constructor|function|function|constructor|"
    "constructor (the implicit default constructor)|"
    "constructor (the implicit copy constructor)|"
    "constructor (the implicit move constructor)|"
    "function (the implicit copy assignment operator)|"
    "function (the implicit move assignment operator)|"
    "constructor (inherited)}0 %select{|template }1not viable: "
    "%select{requires at least|allows at most single|requires single}2 "
    "argument %3, but %plural{0:no|:%4}4 arguments were provided">;

def note_ovl_candidate_deleted : Note<
    "candidate %select{function|function|constructor|"
    "function |function |constructor |"
    "constructor (the implicit default constructor)|"
    "constructor (the implicit copy constructor)|"
    "constructor (the implicit move constructor)|"
    "function (the implicit copy assignment operator)|"
    "function (the implicit move assignment operator)|"
    "constructor (inherited)}0%1 has been "
    "%select{explicitly made unavailable|explicitly deleted|"
    "implicitly deleted}2">;

// Giving the index of the bad argument really clutters this message, and
// it's relatively unimportant because 1) it's generally obvious which
// argument(s) are of the given object type and 2) the fix is usually
// to complete the type, which doesn't involve changes to the call line
// anyway.  If people complain, we can change it.
def note_ovl_candidate_bad_conv_incomplete : Note<"candidate "
    "%select{function|function|constructor|"
    "function |function |constructor |"
    "constructor (the implicit default constructor)|"
    "constructor (the implicit copy constructor)|"
    "constructor (the implicit move constructor)|"
    "function (the implicit copy assignment operator)|"
    "function (the implicit move assignment operator)|"
    "constructor (inherited)}0%1 "
    "not viable: cannot convert argument of incomplete type "
    "%diff{$ to $|to parameter type}2,3">;
def note_ovl_candidate_bad_list_argument : Note<"candidate "
    "%select{function|function|constructor|"
    "function |function |constructor |"
    "constructor (the implicit default constructor)|"
    "constructor (the implicit copy constructor)|"
    "constructor (the implicit move constructor)|"
    "function (the implicit copy assignment operator)|"
    "function (the implicit move assignment operator)|"
    "constructor (inherited)}0%1 "
    "not viable: cannot convert initializer list argument to %3">;
def note_ovl_candidate_bad_overload : Note<"candidate "
    "%select{function|function|constructor|"
    "function |function |constructor |"
    "constructor (the implicit default constructor)|"
    "constructor (the implicit copy constructor)|"
    "constructor (the implicit move constructor)|"
    "function (the implicit copy assignment operator)|"
    "function (the implicit move assignment operator)|"
    "constructor (inherited)}0%1"
    " not viable: no overload of %3 matching %2 for %ordinal4 argument">;
def note_ovl_candidate_bad_conv : Note<"candidate "
    "%select{function|function|constructor|"
    "function |function |constructor |"
    "constructor (the implicit default constructor)|"
    "constructor (the implicit copy constructor)|"
    "constructor (the implicit move constructor)|"
    "function (the implicit copy assignment operator)|"
    "function (the implicit move assignment operator)|"
    "constructor (inherited)}0%1"
    " not viable: no known conversion "
    "%diff{from $ to $|from argument type to parameter type}2,3 for "
    "%select{%ordinal5 argument|object argument}4"
    "%select{|; dereference the argument with *|"
    "; take the address of the argument with &|"
    "; remove *|"
    "; remove &}6">;
def note_ovl_candidate_bad_arc_conv : Note<"candidate "
    "%select{function|function|constructor|"
    "function |function |constructor |"
    "constructor (the implicit default constructor)|"
    "constructor (the implicit copy constructor)|"
    "constructor (the implicit move constructor)|"
    "function (the implicit copy assignment operator)|"
    "function (the implicit move assignment operator)|"
    "constructor (inherited)}0%1"
    " not viable: cannot implicitly convert argument "
    "%diff{of type $ to $|type to parameter type}2,3 for "
    "%select{%ordinal5 argument|object argument}4 under ARC">;
def note_ovl_candidate_bad_lvalue : Note<"candidate "
    "%select{function|function|constructor|"
    "function |function |constructor |"
    "constructor (the implicit default constructor)|"
    "constructor (the implicit copy constructor)|"
    "constructor (the implicit move constructor)|"
    "function (the implicit copy assignment operator)|"
    "function (the implicit move assignment operator)|"
    "constructor (inherited)}0%1"
    " not viable: expects an l-value for "
    "%select{%ordinal3 argument|object argument}2">;
def note_ovl_candidate_bad_addrspace : Note<"candidate "
    "%select{function|function|constructor|"
    "function |function |constructor |"
    "constructor (the implicit default constructor)|"
    "constructor (the implicit copy constructor)|"
    "constructor (the implicit move constructor)|"
    "function (the implicit copy assignment operator)|"
    "function (the implicit move assignment operator)|"
    "constructor (inherited)}0%1 not viable: "
    "%select{%ordinal6|'this'}5 argument (%2) is in "
    "address space %3, but parameter must be in address space %4">;
def note_ovl_candidate_bad_gc : Note<"candidate "
    "%select{function|function|constructor|"
    "function |function |constructor |"
    "constructor (the implicit default constructor)|"
    "constructor (the implicit copy constructor)|"
    "constructor (the implicit move constructor)|"
    "function (the implicit copy assignment operator)|"
    "function (the implicit move assignment operator)|"
    "constructor (inherited)}0%1 not viable: "
    "%select{%ordinal6|'this'}5 argument (%2) has %select{no|__weak|__strong}3 "
    "ownership, but parameter has %select{no|__weak|__strong}4 ownership">;
def note_ovl_candidate_bad_ownership : Note<"candidate "
    "%select{function|function|constructor|"
    "function |function |constructor |"
    "constructor (the implicit default constructor)|"
    "constructor (the implicit copy constructor)|"
    "constructor (the implicit move constructor)|"
    "function (the implicit copy assignment operator)|"
    "function (the implicit move assignment operator)|"
    "constructor (inherited)}0%1 not viable: "
    "%select{%ordinal6|'this'}5 argument (%2) has "
    "%select{no|__unsafe_unretained|__strong|__weak|__autoreleasing}3 ownership,"
    " but parameter has %select{no|__unsafe_unretained|__strong|__weak|"
    "__autoreleasing}4 ownership">;
def note_ovl_candidate_bad_cvr_this : Note<"candidate "
    "%select{|function|||function|||||"
    "function (the implicit copy assignment operator)|"
    "function (the implicit move assignment operator)|}0 not viable: "
    "'this' argument has type %2, but method is not marked "
    "%select{const|restrict|const or restrict|volatile|const or volatile|"
    "volatile or restrict|const, volatile, or restrict}3">;
def note_ovl_candidate_bad_cvr : Note<"candidate "
    "%select{function|function|constructor|"
    "function |function |constructor |"
    "constructor (the implicit default constructor)|"
    "constructor (the implicit copy constructor)|"
    "constructor (the implicit move constructor)|"
    "function (the implicit copy assignment operator)|"
    "function (the implicit move assignment operator)|"
    "constructor (inherited)}0%1 not viable: "
    "%ordinal4 argument (%2) would lose "
    "%select{const|restrict|const and restrict|volatile|const and volatile|"
    "volatile and restrict|const, volatile, and restrict}3 qualifier"
    "%select{||s||s|s|s}3">;
def note_ovl_candidate_bad_base_to_derived_conv : Note<"candidate "
    "%select{function|function|constructor|"
    "function |function |constructor |"
    "constructor (the implicit default constructor)|"
    "constructor (the implicit copy constructor)|"
    "constructor (the implicit move constructor)|"
    "function (the implicit copy assignment operator)|"
    "function (the implicit move assignment operator)|"
    "constructor (inherited)}0%1"
    " not viable: cannot %select{convert from|convert from|bind}2 "
    "%select{base class pointer|superclass|base class object of type}2 %3 to "
    "%select{derived class pointer|subclass|derived class reference}2 %4 for "
    "%ordinal5 argument">;
def note_ovl_candidate_bad_target : Note<
    "candidate %select{function|function|constructor|"
    "function |function |constructor |"
    "constructor (the implicit default constructor)|"
    "constructor (the implicit copy constructor)|"
    "constructor (the implicit move constructor)|"
    "function (the implicit copy assignment operator)|"
    "function (the implicit move assignment operator)|"
    "constructor (inherited)}0 not viable: call to "
    "%select{__device__|__global__|__host__|__host__ __device__}1 function from"
    " %select{__device__|__global__|__host__|__host__ __device__}2 function">;

def note_ambiguous_type_conversion: Note<
    "because of ambiguity in conversion %diff{of $ to $|between types}0,1">;
def note_ovl_builtin_binary_candidate : Note<
    "built-in candidate %0">;
def note_ovl_builtin_unary_candidate : Note<
    "built-in candidate %0">;
def err_ovl_no_viable_function_in_init : Error<
  "no matching constructor for initialization of %0">;
def err_ovl_no_conversion_in_cast : Error<
  "cannot convert %1 to %2 without a conversion operator">;
def err_ovl_no_viable_conversion_in_cast : Error<
  "no matching conversion for %select{|static_cast|reinterpret_cast|"
  "dynamic_cast|C-style cast|functional-style cast}0 from %1 to %2">;
def err_ovl_ambiguous_conversion_in_cast : Error<
  "ambiguous conversion for %select{|static_cast|reinterpret_cast|"
  "dynamic_cast|C-style cast|functional-style cast}0 from %1 to %2">;
def err_ovl_deleted_conversion_in_cast : Error<
  "%select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|"
  "functional-style cast}0 from %1 to %2 uses deleted function">;
def err_ovl_ambiguous_init : Error<"call to constructor of %0 is ambiguous">;
def err_ref_init_ambiguous : Error<
  "reference initialization of type %0 with initializer of type %1 is ambiguous">;
def err_ovl_deleted_init : Error<
  "call to %select{unavailable|deleted}0 constructor of %1">;
def err_ovl_deleted_special_init : Error<
  "call to implicitly-deleted %select{default constructor|copy constructor|"
  "move constructor|copy assignment operator|move assignment operator|"
  "destructor|function}0 of %1">;
def err_ovl_ambiguous_oper_unary : Error<
  "use of overloaded operator '%0' is ambiguous (operand type %1)">;
def err_ovl_ambiguous_oper_binary : Error<
  "use of overloaded operator '%0' is ambiguous (with operand types %1 and %2)">;
def err_ovl_no_viable_oper : Error<"no viable overloaded '%0'">;
def err_ovl_deleted_oper : Error<
  "overload resolution selected %select{unavailable|deleted}0 operator '%1'%2">;
def err_ovl_deleted_special_oper : Error<
  "object of type %0 cannot be %select{constructed|copied|moved|assigned|"
  "assigned|destroyed}1 because its %select{default constructor|"
  "copy constructor|move constructor|copy assignment operator|"
  "move assignment operator|destructor}1 is implicitly deleted">;
def err_ovl_no_viable_subscript :
    Error<"no viable overloaded operator[] for type %0">;
def err_ovl_no_oper :
    Error<"type %0 does not provide a %select{subscript|call}1 operator">;
def err_ovl_unresolvable : Error<
  "reference to overloaded function could not be resolved; "
  "did you mean to call it%select{| with no arguments}0?">;
def err_bound_member_function : Error<
  "reference to non-static member function must be called"
  "%select{|; did you mean to call it with no arguments?}0">;
def note_possible_target_of_call : Note<"possible target for call">;

def err_ovl_no_viable_object_call : Error<
  "no matching function for call to object of type %0">;
def err_ovl_ambiguous_object_call : Error<
  "call to object of type %0 is ambiguous">;
def err_ovl_deleted_object_call : Error<
  "call to %select{unavailable|deleted}0 function call operator in type %1%2">;
def note_ovl_surrogate_cand : Note<"conversion candidate of type %0">;
def err_member_call_without_object : Error<
  "call to non-static member function without an object argument">;

// C++ Address of Overloaded Function
def err_addr_ovl_no_viable : Error<
  "address of overloaded function %0 does not match required type %1">;
def err_addr_ovl_ambiguous : Error<
  "address of overloaded function %0 is ambiguous">;
def err_addr_ovl_not_func_ptrref : Error<
  "address of overloaded function %0 cannot be converted to type %1">;
def err_addr_ovl_no_qualifier : Error<
  "can't form member pointer of type %0 without '&' and class name">;

// C++11 Literal Operators
def err_ovl_no_viable_literal_operator : Error<
  "no matching literal operator for call to %0"
  "%select{| with argument of type %2| with arguments of types %2 and %3}1"
  "%select{| or 'const char *', and no matching literal operator template}4">;

// C++ Template Declarations
def err_template_param_shadow : Error<
  "declaration of %0 shadows template parameter">;
def note_template_param_here : Note<"template parameter is declared here">;
def warn_template_export_unsupported : Warning<
  "exported templates are unsupported">;
def err_template_outside_namespace_or_class_scope : Error<
  "templates can only be declared in namespace or class scope">;
def err_template_linkage : Error<"templates must have C++ linkage">;
def err_template_typedef : Error<"a typedef cannot be a template">;
def err_template_unnamed_class : Error<
  "cannot declare a class template with no name">;
def err_template_param_list_different_arity : Error<
  "%select{too few|too many}0 template parameters in template "
  "%select{|template parameter }1redeclaration">;
def note_template_param_list_different_arity : Note<
  "%select{too few|too many}0 template parameters in template template "
  "argument">;
def note_template_prev_declaration : Note<
  "previous template %select{declaration|template parameter}0 is here">;
def err_template_param_different_kind : Error<
  "template parameter has a different kind in template "
  "%select{|template parameter }0redeclaration">;
def note_template_param_different_kind : Note<
  "template parameter has a different kind in template argument">;
  
def err_template_nontype_parm_different_type : Error<
  "template non-type parameter has a different type %0 in template "
  "%select{|template parameter }1redeclaration">;

def note_template_nontype_parm_different_type : Note<
  "template non-type parameter has a different type %0 in template argument">;
def note_template_nontype_parm_prev_declaration : Note<
  "previous non-type template parameter with type %0 is here">;
def err_template_nontype_parm_bad_type : Error<
  "a non-type template parameter cannot have type %0">;
def err_template_param_default_arg_redefinition : Error<
  "template parameter redefines default argument">;
def note_template_param_prev_default_arg : Note<
  "previous default template argument defined here">;
def err_template_param_default_arg_missing : Error<
  "template parameter missing a default argument">;
def ext_template_parameter_default_in_function_template : ExtWarn<
  "default template arguments for a function template are a C++11 extension">,
  InGroup<CXX11>;
def warn_cxx98_compat_template_parameter_default_in_function_template : Warning<
  "default template arguments for a function template are incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
def err_template_parameter_default_template_member : Error<
  "cannot add a default template argument to the definition of a member of a "
  "class template">;
def err_template_parameter_default_friend_template : Error<
  "default template argument not permitted on a friend template">;
def err_template_template_parm_no_parms : Error<
  "template template parameter must have its own template parameters">;

def err_template_variable : Error<"variable %0 declared as a template">;
def err_template_variable_noparams : Error<
  "extraneous 'template<>' in declaration of variable %0">;
def err_template_member : Error<"member %0 declared as a template">;
def err_template_member_noparams : Error<
  "extraneous 'template<>' in declaration of member %0">;
def err_template_tag_noparams : Error<
  "extraneous 'template<>' in declaration of %0 %1">;
def err_template_decl_ref : Error<
  "cannot refer to class template %0 without a template argument list">;

// C++ Template Argument Lists
def err_template_missing_args : Error<
  "use of class template %0 requires template arguments">;
def err_template_arg_list_different_arity : Error<
  "%select{too few|too many}0 template arguments for "
  "%select{class template|function template|template template parameter"
  "|template}1 %2">;
def note_template_decl_here : Note<"template is declared here">;
def note_member_of_template_here : Note<"member is declared here">;
def err_template_arg_must_be_type : Error<
  "template argument for template type parameter must be a type">;
def err_template_arg_must_be_type_suggest : Error<
  "template argument for template type parameter must be a type; did you forget 'typename'?">;
def err_template_arg_must_be_expr : Error<
  "template argument for non-type template parameter must be an expression">;
def err_template_arg_nontype_ambig : Error<
  "template argument for non-type template parameter is treated as function type %0">;
def err_template_arg_must_be_template : Error<
  "template argument for template template parameter must be a class template%select{| or type alias template}0">;
def ext_template_arg_local_type : ExtWarn<
  "template argument uses local type %0">, InGroup<LocalTypeTemplateArgs>;
def ext_template_arg_unnamed_type : ExtWarn<
  "template argument uses unnamed type">, InGroup<UnnamedTypeTemplateArgs>;
def warn_cxx98_compat_template_arg_local_type : Warning<
  "local type %0 as template argument is incompatible with C++98">,
  InGroup<CXX98CompatLocalTypeTemplateArgs>, DefaultIgnore;
def warn_cxx98_compat_template_arg_unnamed_type : Warning<
  "unnamed type as template argument is incompatible with C++98">,
  InGroup<CXX98CompatUnnamedTypeTemplateArgs>, DefaultIgnore;
def note_template_unnamed_type_here : Note<
  "unnamed type used in template argument was declared here">;
def err_template_arg_overload_type : Error<
  "template argument is the type of an unresolved overloaded function">;
def err_template_arg_not_class_template : Error<
  "template argument does not refer to a class template or template "
  "template parameter">;
def note_template_arg_refers_here_func : Note<
  "template argument refers to function template %0, here">;
def err_template_arg_template_params_mismatch : Error<
  "template template argument has different template parameters than its "
  "corresponding template template parameter">;
def err_template_arg_not_integral_or_enumeral : Error<
  "non-type template argument of type %0 must have an integral or enumeration"
  " type">;
def err_template_arg_not_ice : Error<
  "non-type template argument of type %0 is not an integral constant "
  "expression">;
def err_template_arg_not_address_constant : Error<
  "non-type template argument of type %0 is not a constant expression">;
def warn_cxx98_compat_template_arg_null : Warning<
  "use of null pointer as non-type template argument is incompatible with "
  "C++98">, InGroup<CXX98Compat>, DefaultIgnore;
def err_template_arg_untyped_null_constant : Error<
  "null non-type template argument must be cast to template parameter type %0">;
def err_template_arg_wrongtype_null_constant : Error<
 "null non-type template argument of type %0 does not match template parameter "
 "of type %1">;
def err_deduced_non_type_template_arg_type_mismatch : Error<
  "deduced non-type template argument does not have the same type as the "
  "its corresponding template parameter%diff{ ($ vs $)|}0,1">;
def err_template_arg_not_convertible : Error<
  "non-type template argument of type %0 cannot be converted to a value "
  "of type %1">;
def warn_template_arg_negative : Warning<
  "non-type template argument with value '%0' converted to '%1' for unsigned "
  "template parameter of type %2">, InGroup<Conversion>, DefaultIgnore;
def warn_template_arg_too_large : Warning<
  "non-type template argument value '%0' truncated to '%1' for "
  "template parameter of type %2">, InGroup<Conversion>, DefaultIgnore;
def err_template_arg_no_ref_bind : Error<
  "non-type template parameter of reference type "
  "%diff{$ cannot bind to template argument of type $"
  "|cannot bind to template of incompatible argument type}0,1">;
def err_template_arg_ref_bind_ignores_quals : Error<
  "reference binding of non-type template parameter "
  "%diff{of type $ to template argument of type $|to template argument}0,1 "
  "ignores qualifiers">;
def err_template_arg_not_decl_ref : Error<
  "non-type template argument does not refer to any declaration">;
def err_template_arg_not_object_or_func_form : Error<
  "non-type template argument does not directly refer to an object or "
  "function">;
def err_template_arg_not_address_of : Error<
  "non-type template argument for template parameter of pointer type %0 must "
  "have its address taken">;
def err_template_arg_address_of_non_pointer : Error<
  "address taken in non-type template argument for template parameter of "
  "reference type %0">;
def err_template_arg_reference_var : Error<
  "non-type template argument of reference type %0 is not an object">;
def err_template_arg_field : Error<
  "non-type template argument refers to non-static data member %0">;
def err_template_arg_method : Error<
  "non-type template argument refers to non-static member function %0">;
def err_template_arg_object_no_linkage : Error<
  "non-type template argument refers to %select{function|object}0 %1 that "
  "does not have linkage">;
def warn_cxx98_compat_template_arg_object_internal : Warning<
  "non-type template argument referring to %select{function|object}0 %1 with "
  "internal linkage is incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
def ext_template_arg_object_internal : ExtWarn<
  "non-type template argument referring to %select{function|object}0 %1 with "
  "internal linkage is a C++11 extension">, InGroup<CXX11>;
def err_template_arg_thread_local : Error<
  "non-type template argument refers to thread-local object">;
def note_template_arg_internal_object : Note<
  "non-type template argument refers to %select{function|object}0 here">;
def note_template_arg_refers_here : Note<
  "non-type template argument refers here">;
def err_template_arg_not_object_or_func : Error<
  "non-type template argument does not refer to an object or function">;
def err_template_arg_not_pointer_to_member_form : Error<
  "non-type template argument is not a pointer to member constant">;
def ext_template_arg_extra_parens : ExtWarn<
  "address non-type template argument cannot be surrounded by parentheses">;
def warn_cxx98_compat_template_arg_extra_parens : Warning<
  "redundant parentheses surrounding address non-type template argument are "
  "incompatible with C++98">, InGroup<CXX98Compat>, DefaultIgnore;
def err_pointer_to_member_type : Error<
  "invalid use of pointer to member type after %select{.*|->*}0">;
def err_pointer_to_member_call_drops_quals : Error<
  "call to pointer to member function of type %0 drops '%1' qualifier%s2">;
def err_pointer_to_member_oper_value_classify: Error<
  "pointer-to-member function type %0 can only be called on an "
  "%select{rvalue|lvalue}1">;

// C++ template specialization
def err_template_spec_unknown_kind : Error<
  "can only provide an explicit specialization for a class template, function "
  "template, or a member function, static data member, "
  "%select{or member class|member class, or member enumeration}0 of a "
  "class template">;
def note_specialized_entity : Note<
  "explicitly specialized declaration is here">;
def err_template_spec_decl_function_scope : Error<
  "explicit specialization of %0 in function scope">;
def err_template_spec_decl_class_scope : Error<
  "explicit specialization of %0 in class scope">;
def err_template_spec_decl_friend : Error<
  "cannot declare an explicit specialization in a friend">;
def err_template_spec_decl_out_of_scope_global : Error<
  "%select{class template|class template partial|function template|member "
  "function|static data member|member class|member enumeration}0 "
  "specialization of %1 must originally be declared in the global scope">;
def err_template_spec_decl_out_of_scope : Error<
  "%select{class template|class template partial|function template|member "
  "function|static data member|member class|member enumeration}0 "
  "specialization of %1 must originally be declared in namespace %2">;
def ext_template_spec_decl_out_of_scope : ExtWarn<
  "first declaration of %select{class template|class template partial|"
  "function template|member function|static data member|member class|"
  "member enumeration}0 specialization of %1 outside namespace %2 is a "
  "C++11 extension">, InGroup<CXX11>;
def warn_cxx98_compat_template_spec_decl_out_of_scope : Warning<
  "%select{class template|class template partial|function template|member "
  "function|static data member|member class|member enumeration}0 "
  "specialization of %1 outside namespace %2 is incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
def err_template_spec_redecl_out_of_scope : Error<
  "%select{class template|class template partial|function template|member "
  "function|static data member|member class|member enumeration}0 "
  "specialization of %1 not in a namespace enclosing %2">;
def err_template_spec_redecl_global_scope : Error<
  "%select{class template|class template partial|function template|member "
  "function|static data member|member class|member enumeration}0 "
  "specialization of %1 must occur at global scope">;
def err_spec_member_not_instantiated : Error<
  "specialization of member %q0 does not specialize an instantiated member">;
def note_specialized_decl : Note<"attempt to specialize declaration here">;
def err_specialization_after_instantiation : Error<
  "explicit specialization of %0 after instantiation">;
def note_instantiation_required_here : Note<
  "%select{implicit|explicit}0 instantiation first required here">;
def err_template_spec_friend : Error<
  "template specialization declaration cannot be a friend">;
def err_template_spec_default_arg : Error<
  "default argument not permitted on an explicit "
  "%select{instantiation|specialization}0 of function %1">;
def err_not_class_template_specialization : Error<
  "cannot specialize a %select{dependent template|template template "
  "parameter}0">;
def err_function_specialization_in_class : Error<
  "cannot specialize a function %0 within class scope">;
def ext_function_specialization_in_class : ExtWarn<
  "explicit specialization of %0 within class scope is a Microsoft extension">,
  InGroup<Microsoft>;
def ext_explicit_specialization_storage_class : ExtWarn<
  "explicit specialization cannot have a storage class">;
def err_explicit_specialization_inconsistent_storage_class : Error<
  "explicit specialization has extraneous, inconsistent storage class "
  "'%select{none|extern|static|__private_extern__|auto|register}0'">;

// C++ class template specializations and out-of-line definitions
def err_template_spec_needs_header : Error<
  "template specialization requires 'template<>'">;
def err_template_spec_needs_template_parameters : Error<
  "template specialization or definition requires a template parameter list "
  "corresponding to the nested type %0">;
def err_template_param_list_matches_nontemplate : Error<
  "template parameter list matching the non-templated nested type %0 should "
  "be empty ('template<>')">;
def err_alias_template_extra_headers : Error<
  "extraneous template parameter list in alias template declaration">;
def err_template_spec_extra_headers : Error<
  "extraneous template parameter list in template specialization or "
  "out-of-line template definition">;
def warn_template_spec_extra_headers : Warning<
  "extraneous template parameter list in template specialization">;
def note_explicit_template_spec_does_not_need_header : Note<
  "'template<>' header not required for explicitly-specialized class %0 "
  "declared here">;
def err_template_qualified_declarator_no_match : Error<
  "nested name specifier '%0' for declaration does not refer into a class, "
  "class template or class template partial specialization">;
def err_specialize_member_of_template : Error<
  "cannot specialize (with 'template<>') a member of an unspecialized "
  "template">;

// C++ Class Template Partial Specialization
def err_default_arg_in_partial_spec : Error<
    "default template argument in a class template partial specialization">;
def err_dependent_non_type_arg_in_partial_spec : Error<
    "non-type template argument depends on a template parameter of the "
    "partial specialization">;
def err_dependent_typed_non_type_arg_in_partial_spec : Error<
    "non-type template argument specializes a template parameter with "
    "dependent type %0">;
def err_partial_spec_args_match_primary_template : Error<
    "class template partial specialization does not specialize any template "
    "argument; to %select{declare|define}0 the primary template, remove the "
    "template argument list">; 
def warn_partial_specs_not_deducible : Warning<
    "class template partial specialization contains "
    "%select{a template parameter|template parameters}0 that can not be "
    "deduced; this partial specialization will never be used">;
def note_partial_spec_unused_parameter : Note<
    "non-deducible template parameter %0">;
def err_partial_spec_ordering_ambiguous : Error<
    "ambiguous partial specializations of %0">;
def note_partial_spec_match : Note<"partial specialization matches %0">;
def err_partial_spec_redeclared : Error<
  "class template partial specialization %0 cannot be redeclared">;
def note_prev_partial_spec_here : Note<
  "previous declaration of class template partial specialization %0 is here">;
def err_partial_spec_fully_specialized : Error<
  "partial specialization of %0 does not use any of its template parameters">;
  
// C++ Function template specializations
def err_function_template_spec_no_match : Error<
    "no function template matches function template specialization %0">;
def err_function_template_spec_ambiguous : Error<
    "function template specialization %0 ambiguously refers to more than one "
    "function template; explicitly specify%select{| additional}1 template "
    "arguments to identify a particular function template">;
def note_function_template_spec_matched : Note<
    "function template matches specialization %0">;
def err_function_template_partial_spec : Error<
    "function template partial specialization is not allowed">;

// C++ Template Instantiation
def err_template_recursion_depth_exceeded : Error<
  "recursive template instantiation exceeded maximum depth of %0">,
  DefaultFatal, NoSFINAE;
def note_template_recursion_depth : Note<
  "use -ftemplate-depth=N to increase recursive template instantiation depth">;

def err_template_instantiate_within_definition : Error<
  "%select{implicit|explicit}0 instantiation of template %1 within its"
  " own definition">;
def err_template_instantiate_undefined : Error<
  "%select{implicit|explicit}0 instantiation of undefined template %1">;
def err_implicit_instantiate_member_undefined : Error<
  "implicit instantiation of undefined member %0">;
def note_template_class_instantiation_here : Note<
  "in instantiation of template class %0 requested here">;
def note_template_member_class_here : Note<
  "in instantiation of member class %0 requested here">;
def note_template_member_function_here : Note<
  "in instantiation of member function %q0 requested here">;
def note_function_template_spec_here : Note<
  "in instantiation of function template specialization %q0 requested here">;
def note_template_static_data_member_def_here : Note<
  "in instantiation of static data member %q0 requested here">;
def note_template_enum_def_here : Note<
  "in instantiation of enumeration %q0 requested here">;
def note_template_type_alias_instantiation_here : Note<
  "in instantiation of template type alias %0 requested here">;
def note_template_exception_spec_instantiation_here : Note<
  "in instantiation of exception specification for %0 requested here">;
  
def note_default_arg_instantiation_here : Note<
  "in instantiation of default argument for '%0' required here">;
def note_default_function_arg_instantiation_here : Note<
  "in instantiation of default function argument expression "
  "for '%0' required here">;
def note_explicit_template_arg_substitution_here : Note<
  "while substituting explicitly-specified template arguments into function "
  "template %0 %1">;
def note_function_template_deduction_instantiation_here : Note<
  "while substituting deduced template arguments into function template %0 "
  "%1">;
def note_partial_spec_deduct_instantiation_here : Note<
  "during template argument deduction for class template partial "
  "specialization %0 %1">;
def note_prior_template_arg_substitution : Note<
  "while substituting prior template arguments into %select{non-type|template}0"
  " template parameter%1 %2">;
def note_template_default_arg_checking : Note<
  "while checking a default template argument used here">;
def note_instantiation_contexts_suppressed : Note<
  "(skipping %0 context%s0 in backtrace; use -ftemplate-backtrace-limit=0 to "
  "see all)">;

def err_field_instantiates_to_function : Error<
  "data member instantiated with function type %0">;
def err_variable_instantiates_to_function : Error<
  "%select{variable|static data member}0 instantiated with function type %1">;
def err_nested_name_spec_non_tag : Error<
  "type %0 cannot be used prior to '::' because it has no members">;

// C++ Explicit Instantiation
def err_explicit_instantiation_duplicate : Error<
    "duplicate explicit instantiation of %0">;
def note_previous_explicit_instantiation : Note<
    "previous explicit instantiation is here">;
def ext_explicit_instantiation_after_specialization : Extension<
    "explicit instantiation of %0 that occurs after an explicit "
    "specialization will be ignored (C++11 extension)">,
    InGroup<CXX11>;
def warn_cxx98_compat_explicit_instantiation_after_specialization : Warning<
    "explicit instantiation of %0 that occurs after an explicit "
    "specialization is incompatible with C++98">,
    InGroup<CXX98CompatPedantic>, DefaultIgnore;
def note_previous_template_specialization : Note<
    "previous template specialization is here">;
def err_explicit_instantiation_nontemplate_type : Error<
    "explicit instantiation of non-templated type %0">;
def note_nontemplate_decl_here : Note<
    "non-templated declaration is here">;
def err_explicit_instantiation_in_class : Error<
  "explicit instantiation of %0 in class scope">;
def err_explicit_instantiation_out_of_scope : Error<
  "explicit instantiation of %0 not in a namespace enclosing %1">;
def err_explicit_instantiation_must_be_global : Error<
  "explicit instantiation of %0 must occur at global scope">;
def warn_explicit_instantiation_out_of_scope_0x : Warning<
  "explicit instantiation of %0 not in a namespace enclosing %1">, 
  InGroup<CXX11Compat>, DefaultIgnore;
def warn_explicit_instantiation_must_be_global_0x : Warning<
  "explicit instantiation of %0 must occur at global scope">, 
  InGroup<CXX11Compat>, DefaultIgnore;
  
def err_explicit_instantiation_requires_name : Error<
  "explicit instantiation declaration requires a name">;
def err_explicit_instantiation_of_typedef : Error<
  "explicit instantiation of typedef %0">;
def err_explicit_instantiation_storage_class : Error<
  "explicit instantiation cannot have a storage class">;
def err_explicit_instantiation_not_known : Error<
  "explicit instantiation of %0 does not refer to a function template, member "
  "function, member class, or static data member">;
def note_explicit_instantiation_here : Note<
  "explicit instantiation refers here">;
def err_explicit_instantiation_data_member_not_instantiated : Error<
  "explicit instantiation refers to static data member %q0 that is not an "
  "instantiation">;
def err_explicit_instantiation_member_function_not_instantiated : Error<
  "explicit instantiation refers to member function %q0 that is not an "
  "instantiation">;
def err_explicit_instantiation_ambiguous : Error<
  "partial ordering for explicit instantiation of %0 is ambiguous">;
def note_explicit_instantiation_candidate : Note<
  "explicit instantiation candidate function template here %0">;
def err_explicit_instantiation_inline : Error<
  "explicit instantiation cannot be 'inline'">;
def warn_explicit_instantiation_inline_0x : Warning<
  "explicit instantiation cannot be 'inline'">, InGroup<CXX11Compat>,
  DefaultIgnore;
def err_explicit_instantiation_constexpr : Error<
  "explicit instantiation cannot be 'constexpr'">;
def ext_explicit_instantiation_without_qualified_id : Extension<
  "qualifier in explicit instantiation of %q0 requires a template-id "
  "(a typedef is not permitted)">;
def err_explicit_instantiation_unqualified_wrong_namespace : Error<
  "explicit instantiation of %q0 must occur in namespace %1">;
def warn_explicit_instantiation_unqualified_wrong_namespace_0x : Warning<
  "explicit instantiation of %q0 must occur in namespace %1">,
  InGroup<CXX11Compat>, DefaultIgnore;
def err_explicit_instantiation_undefined_member : Error<
  "explicit instantiation of undefined %select{member class|member function|"
  "static data member}0 %1 of class template %2">;
def err_explicit_instantiation_undefined_func_template : Error<
  "explicit instantiation of undefined function template %0">;
def err_explicit_instantiation_declaration_after_definition : Error<
  "explicit instantiation declaration (with 'extern') follows explicit "
  "instantiation definition (without 'extern')">;
def note_explicit_instantiation_definition_here : Note<
  "explicit instantiation definition is here">;
  
// C++ typename-specifiers
def err_typename_nested_not_found : Error<"no type named %0 in %1">;
def err_typename_nested_not_found_enable_if : Error<
  "no type named 'type' in %0; 'enable_if' cannot be used to disable "
  "this declaration">;
def err_typename_nested_not_type : Error<
    "typename specifier refers to non-type member %0 in %1">;
def note_typename_refers_here : Note<
    "referenced member %0 is declared here">;
def err_typename_missing : Error<
  "missing 'typename' prior to dependent type name '%0%1'">;
def warn_typename_missing : ExtWarn<
  "missing 'typename' prior to dependent type name '%0%1'">,
  InGroup<DiagGroup<"typename-missing">>;
def ext_typename_outside_of_template : ExtWarn<
  "'typename' occurs outside of a template">, InGroup<CXX11>;
def warn_cxx98_compat_typename_outside_of_template : Warning<
  "use of 'typename' outside of a template is incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
def err_typename_refers_to_using_value_decl : Error<
  "typename specifier refers to a dependent using declaration for a value "
  "%0 in %1">;
def note_using_value_decl_missing_typename : Note<
  "add 'typename' to treat this using declaration as a type">;

def err_template_kw_refers_to_non_template : Error<
    "%0 following the 'template' keyword does not refer to a template">;
def err_template_kw_refers_to_class_template : Error<
    "'%0%1' instantiated to a class template, not a function template">;
def note_referenced_class_template : Error<
    "class template declared here">;
def err_template_kw_missing : Error<
  "missing 'template' keyword prior to dependent template name '%0%1'">;
def ext_template_outside_of_template : ExtWarn<
  "'template' keyword outside of a template">, InGroup<CXX11>;
def warn_cxx98_compat_template_outside_of_template : Warning<
  "use of 'template' keyword outside of a template is incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;

def err_non_type_template_in_nested_name_specifier : Error<
  "qualified name refers into a specialization of function template %0">;
def err_template_id_not_a_type : Error<
  "template name refers to non-type template %0">;
def note_template_declared_here : Note<
  "%select{function template|class template|type alias template|template template parameter}0 "
  "%1 declared here">;
def note_parameter_type : Note<
  "parameter of type %0 is declared here">;

// C++11 Variadic Templates
def err_template_param_pack_default_arg : Error<
  "template parameter pack cannot have a default argument">;
def err_template_param_pack_must_be_last_template_parameter : Error<
  "template parameter pack must be the last template parameter">;

def err_template_parameter_pack_non_pack : Error<
  "%select{template type|non-type template|template template}0 parameter"
  "%select{| pack}1 conflicts with previous %select{template type|"
  "non-type template|template template}0 parameter%select{ pack|}1">;
def note_template_parameter_pack_non_pack : Note<
  "%select{template type|non-type template|template template}0 parameter"
  "%select{| pack}1 does not match %select{template type|non-type template"
  "|template template}0 parameter%select{ pack|}1 in template argument">;
def note_template_parameter_pack_here : Note<
  "previous %select{template type|non-type template|template template}0 "
  "parameter%select{| pack}1 declared here">;
  
def err_unexpanded_parameter_pack_0 : Error<
  "%select{expression|base type|declaration type|data member type|bit-field "
  "size|static assertion|fixed underlying type|enumerator value|"
  "using declaration|friend declaration|qualifier|initializer|default argument|"
  "non-type template parameter type|exception type|partial specialization|"
  "__if_exists name|__if_not_exists name|lambda|block}0 "
  "contains an unexpanded parameter pack">;
def err_unexpanded_parameter_pack_1 : Error<
  "%select{expression|base type|declaration type|data member type|bit-field "
  "size|static assertion|fixed underlying type|enumerator value|"
  "using declaration|friend declaration|qualifier|initializer|default argument|"
  "non-type template parameter type|exception type|partial specialization|"
  "__if_exists name|__if_not_exists name|lambda|block}0 "
  "contains unexpanded parameter pack %1">;
def err_unexpanded_parameter_pack_2 : Error<
  "%select{expression|base type|declaration type|data member type|bit-field "
  "size|static assertion|fixed underlying type|enumerator value|"
  "using declaration|friend declaration|qualifier|initializer|default argument|"
  "non-type template parameter type|exception type|partial specialization|"
  "__if_exists name|__if_not_exists name|lambda|block}0 "
  "contains unexpanded parameter packs %1 and %2">;
def err_unexpanded_parameter_pack_3_or_more : Error<
  "%select{expression|base type|declaration type|data member type|bit-field "
  "size|static assertion|fixed underlying type|enumerator value|"
  "using declaration|friend declaration|qualifier|initializer|default argument|"
  "non-type template parameter type|exception type|partial specialization|"
  "__if_exists name|__if_not_exists name|lambda|block}0 "
  "contains unexpanded parameter packs %1, %2, ...">;

def err_pack_expansion_without_parameter_packs : Error<
  "pack expansion does not contain any unexpanded parameter packs">;
def err_pack_expansion_length_conflict : Error<
  "pack expansion contains parameter packs %0 and %1 that have different "
  "lengths (%2 vs. %3)">;
def err_pack_expansion_length_conflict_multilevel : Error<
  "pack expansion contains parameter pack %0 that has a different "
  "length (%1 vs. %2) from outer parameter packs">;
def err_pack_expansion_member_init : Error<
  "pack expansion for initialization of member %0">;

def err_function_parameter_pack_without_parameter_packs : Error<
  "type %0 of function parameter pack does not contain any unexpanded "
  "parameter packs">;
def err_ellipsis_in_declarator_not_parameter : Error<
  "only function and template parameters can be parameter packs">;

def err_sizeof_pack_no_pack_name : Error<
  "%0 does not refer to the name of a parameter pack">;

def err_unexpected_typedef : Error<
  "unexpected type name %0: expected expression">;
def err_unexpected_namespace : Error<
  "unexpected namespace name %0: expected expression">;
def err_undeclared_var_use : Error<"use of undeclared identifier %0">;
def warn_found_via_dependent_bases_lookup : ExtWarn<"use of identifier %0 "
   "found via unqualified lookup into dependent bases of class templates is a "
   "Microsoft extension">, InGroup<Microsoft>;
def note_dependent_var_use : Note<"must qualify identifier to find this "
    "declaration in dependent base class">;
def err_not_found_by_two_phase_lookup : Error<"call to function %0 that is neither "
    "visible in the template definition nor found by argument-dependent lookup">;
def note_not_found_by_two_phase_lookup : Note<"%0 should be declared prior to the "
    "call site%select{| or in %2| or in an associated namespace of one of its arguments}1">;
def err_undeclared_use : Error<"use of undeclared %0">;
def warn_deprecated : Warning<"%0 is deprecated">,
    InGroup<DeprecatedDeclarations>;
def warn_deprecated_message : Warning<"%0 is deprecated: %1">,
    InGroup<DeprecatedDeclarations>;
def warn_deprecated_fwdclass_message : Warning<
    "%0 maybe deprecated because receiver type is unknown">,
    InGroup<DeprecatedDeclarations>;
def warn_deprecated_def : Warning<
    "Implementing deprecated %select{method|class|category}0">,
    InGroup<DeprecatedImplementations>, DefaultIgnore;
def err_unavailable : Error<"%0 is unavailable">;
def err_unavailable_message : Error<"%0 is unavailable: %1">;
def warn_unavailable_fwdclass_message : Warning<
    "%0 maybe unavailable because receiver type is unknown">;
def note_unavailable_here : Note<
  "%select{declaration|function}0 has been explicitly marked "
  "%select{unavailable|deleted|deprecated}1 here">;
def note_implicitly_deleted : Note<
  "explicitly defaulted function was implicitly deleted here">;
def warn_not_enough_argument : Warning<
  "not enough variable arguments in %0 declaration to fit a sentinel">,
  InGroup<Sentinel>;
def warn_missing_sentinel : Warning <
  "missing sentinel in %select{function call|method dispatch|block call}0">,
  InGroup<Sentinel>;
def note_sentinel_here : Note<
  "%select{function|method|block}0 has been explicitly marked sentinel here">;
def warn_missing_prototype : Warning<
  "no previous prototype for function %0">,
  InGroup<DiagGroup<"missing-prototypes">>, DefaultIgnore;
def note_declaration_not_a_prototype : Note<
  "this declaration is not a prototype; add 'void' to make it a prototype for a zero-parameter function">; 
def warn_missing_variable_declarations : Warning<
  "no previous extern declaration for non-static variable %0">,
  InGroup<DiagGroup<"missing-variable-declarations">>, DefaultIgnore;
def err_redefinition : Error<"redefinition of %0">;
def err_definition_of_implicitly_declared_member : Error<
  "definition of implicitly declared %select{default constructor|copy "
  "constructor|move constructor|copy assignment operator|move assignment "
  "operator|destructor}1">;
def err_definition_of_explicitly_defaulted_member : Error<
  "definition of explicitly defaulted %select{default constructor|copy "
  "constructor|move constructor|copy assignment operator|move assignment "
  "operator|destructor}0">;
def err_redefinition_extern_inline : Error<
  "redefinition of a 'extern inline' function %0 is not supported in "
  "%select{C99 mode|C++}1">;
def warn_cxx98_compat_friend_redefinition : Warning<
  "friend function %0 would be implicitly redefined in C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;

def note_deleted_dtor_no_operator_delete : Note<
  "virtual destructor requires an unambiguous, accessible 'operator delete'">;
def note_deleted_special_member_class_subobject : Note<
  "%select{default constructor|copy constructor|move constructor|"
  "copy assignment operator|move assignment operator|destructor}0 of "
  "%1 is implicitly deleted because "
  "%select{base class %3|%select{||||variant }4field %3}2 has "
  "%select{no|a deleted|multiple|an inaccessible|a non-trivial}4 "
  "%select{%select{default constructor|copy constructor|move constructor|copy "
  "assignment operator|move assignment operator|destructor}0|destructor}5"
  "%select{||s||}4">;
def note_deleted_default_ctor_uninit_field : Note<
  "default constructor of %0 is implicitly deleted because field %1 of "
  "%select{reference|const-qualified}3 type %2 would not be initialized">;
def note_deleted_default_ctor_all_const : Note<
  "default constructor of %0 is implicitly deleted because all "
  "%select{data members|data members of an anonymous union member}1"
  " are const-qualified">;
def note_deleted_copy_ctor_rvalue_reference : Note<
  "copy constructor of %0 is implicitly deleted because field %1 is of "
  "rvalue reference type %2">;
def note_deleted_copy_user_declared_move : Note<
  "copy %select{constructor|assignment operator}0 is implicitly deleted because"
  " %1 has a user-declared move %select{constructor|assignment operator}2">;
def note_deleted_assign_field : Note<
  "%select{copy|move}0 assignment operator of %1 is implicitly deleted "
  "because field %2 is of %select{reference|const-qualified}4 type %3">;

// These should be errors.
def warn_undefined_internal : Warning<
  "%select{function|variable}0 %q1 has internal linkage but is not defined">,
  InGroup<DiagGroup<"undefined-internal">>;
def warn_undefined_inline : Warning<"inline function %q0 is not defined">,
  InGroup<DiagGroup<"undefined-inline">>;
def note_used_here : Note<"used here">;

def warn_internal_in_extern_inline : ExtWarn<
  "static %select{function|variable}0 %1 is used in an inline function with "
  "external linkage">, InGroup<StaticInInline>;
def ext_internal_in_extern_inline : Extension<
  "static %select{function|variable}0 %1 is used in an inline function with "
  "external linkage">, InGroup<StaticInInline>;
def warn_static_local_in_extern_inline : Warning<
  "non-constant static local variable in inline function may be different "
  "in different files">, InGroup<StaticLocalInInline>;
def note_convert_inline_to_static : Note<
  "use 'static' to give inline function %0 internal linkage">;
def note_internal_decl_declared_here : Note<
  "%0 declared here">;

def warn_redefinition_of_typedef : ExtWarn<
  "redefinition of typedef %0 is a C11 feature">,
  InGroup<DiagGroup<"typedef-redefinition"> >;
def err_redefinition_variably_modified_typedef : Error<
  "redefinition of %select{typedef|type alias}0 for variably-modified type %1">;

def err_inline_declaration_block_scope : Error<
  "inline declaration of %0 not allowed in block scope">;
def err_static_non_static : Error<
  "static declaration of %0 follows non-static declaration">;
def err_different_language_linkage : Error<
  "declaration of %0 has a different language linkage">;
def warn_weak_import : Warning <
  "an already-declared variable is made a weak_import declaration %0">;
def warn_static_non_static : ExtWarn<
  "static declaration of %0 follows non-static declaration">;
def err_non_static_static : Error<
  "non-static declaration of %0 follows static declaration">;
def err_extern_non_extern : Error<
  "extern declaration of %0 follows non-extern declaration">;
def err_non_extern_extern : Error<
  "non-extern declaration of %0 follows extern declaration">;
def err_non_thread_thread : Error<
  "non-thread-local declaration of %0 follows thread-local declaration">;
def err_thread_non_thread : Error<
  "thread-local declaration of %0 follows non-thread-local declaration">;
def err_thread_thread_different_kind : Error<
  "thread-local declaration of %0 with %select{static|dynamic}1 initialization "
  "follows declaration with %select{dynamic|static}1 initialization">;
def err_redefinition_different_type : Error<
  "redefinition of %0 with a different type%diff{: $ vs $|}1,2">;
def err_redefinition_different_kind : Error<
  "redefinition of %0 as different kind of symbol">;
def warn_forward_class_redefinition : Warning<
  "redefinition of forward class %0 of a typedef name of an object type is ignored">,
  InGroup<DiagGroup<"objc-forward-class-redefinition">>;
def err_redefinition_different_typedef : Error<
  "%select{typedef|type alias|type alias template}0 "
  "redefinition with different types%diff{ ($ vs $)|}1,2">;
def err_tag_reference_non_tag : Error<
  "elaborated type refers to %select{a non-tag type|a typedef|a type alias|a template|a type alias template}0">;
def err_tag_reference_conflict : Error<
  "implicit declaration introduced by elaborated type conflicts with "
  "%select{a declaration|a typedef|a type alias|a template}0 of the same name">;
def err_dependent_tag_decl : Error<
  "%select{declaration|definition}0 of "
  "%select{struct|interface|union|class|enum}1 in a dependent scope">;
def err_tag_definition_of_typedef : Error<
  "definition of type %0 conflicts with %select{typedef|type alias}1 of the same name">;
def err_conflicting_types : Error<"conflicting types for %0">;
def err_nested_redefinition : Error<"nested redefinition of %0">;
def err_use_with_wrong_tag : Error<
  "use of %0 with tag type that does not match previous declaration">;
def warn_struct_class_tag_mismatch : Warning<
    "%select{struct|interface|class}0%select{| template}1 %2 was previously "
    "declared as a %select{struct|interface|class}3%select{| template}1">,
    InGroup<MismatchedTags>, DefaultIgnore;
def warn_struct_class_previous_tag_mismatch : Warning<
    "%2 defined as %select{a struct|an interface|a class}0%select{| template}1 "
    "here but previously declared as "
    "%select{a struct|an interface|a class}3%select{| template}1">,
     InGroup<MismatchedTags>, DefaultIgnore;
def note_struct_class_suggestion : Note<
    "did you mean %select{struct|interface|class}0 here?">;
def ext_forward_ref_enum : Extension<
  "ISO C forbids forward references to 'enum' types">;
def err_forward_ref_enum : Error<
  "ISO C++ forbids forward references to 'enum' types">;
def ext_ms_forward_ref_enum : Extension<
  "forward references to 'enum' types are a Microsoft extension">, InGroup<Microsoft>;
def ext_forward_ref_enum_def : Extension<
  "redeclaration of already-defined enum %0 is a GNU extension">, InGroup<GNU>;
  
def err_redefinition_of_enumerator : Error<"redefinition of enumerator %0">;
def err_duplicate_member : Error<"duplicate member %0">;
def err_misplaced_ivar : Error<
  "instance variables may not be placed in %select{categories|class extension}0">;
def warn_ivars_in_interface : Warning<
  "declaration of instance variables in the interface is deprecated">,
  InGroup<DiagGroup<"objc-interface-ivars">>, DefaultIgnore;
def ext_enum_value_not_int : Extension<
  "ISO C restricts enumerator values to range of 'int' (%0 is too "
  "%select{small|large}1)">;
def warn_enum_too_large : Warning<
  "enumeration values exceed range of largest integer">;
def warn_enumerator_too_large : Warning<
  "enumerator value %0 is not representable in the largest integer type">;
  
def warn_illegal_constant_array_size : Extension<
  "size of static array must be an integer constant expression">;
def err_vm_decl_in_file_scope : Error<
  "variably modified type declaration not allowed at file scope">;
def err_vm_decl_has_extern_linkage : Error<
  "variably modified type declaration can not have 'extern' linkage">;
def err_typecheck_field_variable_size : Error<
  "fields must have a constant size: 'variable length array in structure' "
  "extension will never be supported">;
def err_vm_func_decl : Error<
  "function declaration cannot have variably modified type">;
def err_array_too_large : Error<
  "array is too large (%0 elements)">;
def warn_array_new_too_large : Warning<"array is too large (%0 elements)">,
  // FIXME PR11644: ", will throw std::bad_array_new_length at runtime"
  InGroup<BadArrayNewLength>;

// -Wpadded, -Wpacked
def warn_padded_struct_field : Warning<
  "padding %select{struct|interface|class}0 %1 with %2 "
  "%select{byte|bit}3%select{|s}4 to align %5">,
  InGroup<Padded>, DefaultIgnore;
def warn_padded_struct_anon_field : Warning<
  "padding %select{struct|interface|class}0 %1 with %2 "
  "%select{byte|bit}3%select{|s}4 to align anonymous bit-field">,
  InGroup<Padded>, DefaultIgnore;
def warn_padded_struct_size : Warning<
  "padding size of %0 with %1 %select{byte|bit}2%select{|s}3 "
  "to alignment boundary">, InGroup<Padded>, DefaultIgnore;
def warn_unnecessary_packed : Warning<
  "packed attribute is unnecessary for %0">, InGroup<Packed>, DefaultIgnore;

def err_typecheck_negative_array_size : Error<"array size is negative">;
def warn_typecheck_negative_array_new_size : Warning<"array size is negative">,
  // FIXME PR11644: ", will throw std::bad_array_new_length at runtime"
  InGroup<BadArrayNewLength>;
def warn_typecheck_function_qualifiers : Warning<
  "qualifier on function type %0 has unspecified behavior">;
def err_typecheck_invalid_restrict_not_pointer : Error<
  "restrict requires a pointer or reference (%0 is invalid)">;
def err_typecheck_invalid_restrict_not_pointer_noarg : Error<
  "restrict requires a pointer or reference">;
def err_typecheck_invalid_restrict_invalid_pointee : Error<
  "pointer to function type %0 may not be 'restrict' qualified">;
def ext_typecheck_zero_array_size : Extension<
  "zero size arrays are an extension">, InGroup<ZeroLengthArray>;
def err_typecheck_zero_array_size : Error<
  "zero-length arrays are not permitted in C++">;
def warn_typecheck_zero_static_array_size : Warning<
  "'static' has no effect on zero-length arrays">,
  InGroup<ArrayBounds>;
def err_array_size_non_int : Error<"size of array has non-integer type %0">;
def err_init_element_not_constant : Error<
  "initializer element is not a compile-time constant">;
def err_local_cant_init : Error<
  "'__local' variable cannot have an initializer">;
def err_block_extern_cant_init : Error<
  "'extern' variable cannot have an initializer">;
def warn_extern_init : Warning<"'extern' variable has an initializer">,
  InGroup<DiagGroup<"extern-initializer">>;
def err_variable_object_no_init : Error<
  "variable-sized object may not be initialized">;
def err_excess_initializers : Error<
  "excess elements in %select{array|vector|scalar|union|struct}0 initializer">;
def warn_excess_initializers : ExtWarn<
  "excess elements in %select{array|vector|scalar|union|struct}0 initializer">;
def err_excess_initializers_in_char_array_initializer : Error<
  "excess elements in char array initializer">;
def warn_excess_initializers_in_char_array_initializer : ExtWarn<
  "excess elements in char array initializer">;
def err_initializer_string_for_char_array_too_long : Error<
  "initializer-string for char array is too long">;
def warn_initializer_string_for_char_array_too_long : ExtWarn<
  "initializer-string for char array is too long">;
def warn_missing_field_initializers : Warning<
  "missing field '%0' initializer">,
  InGroup<MissingFieldInitializers>, DefaultIgnore;
def warn_braces_around_scalar_init : Warning<
  "braces around scalar initializer">;
def warn_many_braces_around_scalar_init : ExtWarn<
  "too many braces around scalar initializer">;
def ext_complex_component_init : Extension<
  "complex initialization specifying real and imaginary components "
  "is an extension">, InGroup<DiagGroup<"complex-component-init">>;
def err_empty_scalar_initializer : Error<"scalar initializer cannot be empty">;
def warn_cxx98_compat_empty_scalar_initializer : Warning<
  "scalar initialized from empty initializer list is incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
def warn_cxx98_compat_reference_list_init : Warning<
  "reference initialized from initializer list is incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
def warn_cxx98_compat_initializer_list_init : Warning<
  "initialization of initializer_list object is incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
def warn_cxx98_compat_ctor_list_init : Warning<
  "constructor call from initializer list is incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
def err_illegal_initializer : Error<
  "illegal initializer (only variables can be initialized)">;
def err_illegal_initializer_type : Error<"illegal initializer type %0">;
def err_init_list_type_narrowing_sfinae : Error<
  "type %0 cannot be narrowed to %1 in initializer list">;
def err_init_list_type_narrowing : ExtWarn<
  "type %0 cannot be narrowed to %1 in initializer list">, 
  InGroup<CXX11Narrowing>, DefaultError;
def err_init_list_variable_narrowing_sfinae : Error<
  "non-constant-expression cannot be narrowed from type %0 to %1 in "
  "initializer list">;
def err_init_list_variable_narrowing : ExtWarn<
  "non-constant-expression cannot be narrowed from type %0 to %1 in "
  "initializer list">, InGroup<CXX11Narrowing>, DefaultError;
def err_init_list_constant_narrowing_sfinae : Error<
  "constant expression evaluates to %0 which cannot be narrowed to type %1">;
def err_init_list_constant_narrowing : ExtWarn<
  "constant expression evaluates to %0 which cannot be narrowed to type %1">,
  InGroup<CXX11Narrowing>, DefaultError;
def warn_init_list_type_narrowing : Warning<
  "type %0 cannot be narrowed to %1 in initializer list in C++11">,
  InGroup<CXX11Narrowing>, DefaultIgnore;
def warn_init_list_variable_narrowing : Warning<
  "non-constant-expression cannot be narrowed from type %0 to %1 in "
  "initializer list in C++11">,
  InGroup<CXX11Narrowing>, DefaultIgnore;
def warn_init_list_constant_narrowing : Warning<
  "constant expression evaluates to %0 which cannot be narrowed to type %1 in "
  "C++11">,
  InGroup<CXX11Narrowing>, DefaultIgnore;
def note_init_list_narrowing_override : Note<
  "override this message by inserting an explicit cast">;
def err_init_objc_class : Error<
  "cannot initialize Objective-C class type %0">;
def err_implicit_empty_initializer : Error<
  "initializer for aggregate with no elements requires explicit braces">;
def err_bitfield_has_negative_width : Error<
  "bit-field %0 has negative width (%1)">;
def err_anon_bitfield_has_negative_width : Error<
  "anonymous bit-field has negative width (%0)">;
def err_bitfield_has_zero_width : Error<"named bit-field %0 has zero width">;
def err_bitfield_width_exceeds_type_size : Error<
  "size of bit-field %0 (%1 bits) exceeds size of its type (%2 bits)">;
def err_anon_bitfield_width_exceeds_type_size : Error<
  "size of anonymous bit-field (%0 bits) exceeds size of its type (%1 bits)">;
def err_incorrect_number_of_vector_initializers : Error<
  "number of elements must be either one or match the size of the vector">;

// Used by C++ which allows bit-fields that are wider than the type.
def warn_bitfield_width_exceeds_type_size: Warning<
  "size of bit-field %0 (%1 bits) exceeds the size of its type; value will be "
  "truncated to %2 bits">;
def warn_anon_bitfield_width_exceeds_type_size : Warning<
  "size of anonymous bit-field (%0 bits) exceeds size of its type; value will "
  "be truncated to %1 bits">;

def warn_missing_braces : Warning<
  "suggest braces around initialization of subobject">,
  InGroup<MissingBraces>, DefaultIgnore;

def err_redefinition_of_label : Error<"redefinition of label %0">;
def err_undeclared_label_use : Error<"use of undeclared label %0">;
def warn_unused_label : Warning<"unused label %0">,
  InGroup<UnusedLabel>, DefaultIgnore;

def err_goto_into_protected_scope : Error<"goto into protected scope">;
def warn_goto_into_protected_scope : ExtWarn<"goto into protected scope">,
  InGroup<Microsoft>;
def warn_cxx98_compat_goto_into_protected_scope : Warning<
  "goto would jump into protected scope in C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
def err_switch_into_protected_scope : Error<
  "switch case is in protected scope">;
def warn_cxx98_compat_switch_into_protected_scope : Warning<
  "switch case would be in a protected scope in C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
def err_indirect_goto_without_addrlabel : Error<
  "indirect goto in function with no address-of-label expressions">;
def err_indirect_goto_in_protected_scope : Error<
  "indirect goto might cross protected scopes">;
def warn_cxx98_compat_indirect_goto_in_protected_scope : Warning<
  "indirect goto might cross protected scopes in C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;
def note_indirect_goto_target : Note<"possible target of indirect goto">;
def note_protected_by_variable_init : Note<
  "jump bypasses variable initialization">;
def note_protected_by_variable_nontriv_destructor : Note<
  "jump bypasses variable with a non-trivial destructor">;
def note_protected_by_variable_non_pod : Note<
  "jump bypasses initialization of non-POD variable">;
def note_protected_by_cleanup : Note<
  "jump bypasses initialization of variable with __attribute__((cleanup))">;
def note_protected_by_vla_typedef : Note<
  "jump bypasses initialization of VLA typedef">;
def note_protected_by_vla_type_alias : Note<
  "jump bypasses initialization of VLA type alias">;
def note_protected_by_vla : Note<
  "jump bypasses initialization of variable length array">;
def note_protected_by_objc_try : Note<
  "jump bypasses initialization of @try block">;
def note_protected_by_objc_catch : Note<
  "jump bypasses initialization of @catch block">;
def note_protected_by_objc_finally : Note<
  "jump bypasses initialization of @finally block">;
def note_protected_by_objc_synchronized : Note<
  "jump bypasses initialization of @synchronized block">;
def note_protected_by_objc_autoreleasepool : Note<
  "jump bypasses auto release push of @autoreleasepool block">;
def note_protected_by_cxx_try : Note<
  "jump bypasses initialization of try block">;
def note_protected_by_cxx_catch : Note<
  "jump bypasses initialization of catch block">;
def note_protected_by___block : Note<
  "jump bypasses setup of __block variable">;
def note_protected_by_objc_ownership : Note<
  "jump bypasses initialization of retaining variable">;
def note_enters_block_captures_cxx_obj : Note<
  "jump enters lifetime of block which captures a destructible C++ object">;
def note_enters_block_captures_strong : Note<
  "jump enters lifetime of block which strongly captures a variable">;
def note_enters_block_captures_weak : Note<
  "jump enters lifetime of block which weakly captures a variable">;

def note_exits_cleanup : Note<
  "jump exits scope of variable with __attribute__((cleanup))">;
def note_exits_dtor : Note<
  "jump exits scope of variable with non-trivial destructor">;
def note_exits___block : Note<
  "jump exits scope of __block variable">;
def note_exits_objc_try : Note<
  "jump exits @try block">;
def note_exits_objc_catch : Note<
  "jump exits @catch block">;
def note_exits_objc_finally : Note<
  "jump exits @finally block">;
def note_exits_objc_synchronized : Note<
  "jump exits @synchronized block">;
def note_exits_cxx_try : Note<
  "jump exits try block">;
def note_exits_cxx_catch : Note<
  "jump exits catch block">;
def note_exits_objc_autoreleasepool : Note<
  "jump exits autoreleasepool block">;
def note_exits_objc_ownership : Note<
  "jump exits scope of retaining variable">;
def note_exits_block_captures_cxx_obj : Note<
  "jump exits lifetime of block which captures a destructible C++ object">;
def note_exits_block_captures_strong : Note<
  "jump exits lifetime of block which strongly captures a variable">;
def note_exits_block_captures_weak : Note<
  "jump exits lifetime of block which weakly captures a variable">;

def err_func_returning_array_function : Error<
  "function cannot return %select{array|function}0 type %1">;
def err_field_declared_as_function : Error<"field %0 declared as a function">;
def err_field_incomplete : Error<"field has incomplete type %0">;
def ext_variable_sized_type_in_struct : ExtWarn<
  "field %0 with variable sized type %1 not at the end of a struct or class is"
  " a GNU extension">, InGroup<GNU>;

def err_flexible_array_empty_struct : Error<
  "flexible array %0 not allowed in otherwise empty struct">;
def err_flexible_array_has_nonpod_type : Error<
  "flexible array member %0 of non-POD element type %1">;
def ext_flexible_array_in_struct : Extension<
  "%0 may not be nested in a struct due to flexible array member">,
  InGroup<FlexibleArrayExtensions>;
def ext_flexible_array_in_array : Extension<
  "%0 may not be used as an array element due to flexible array member">,
  InGroup<FlexibleArrayExtensions>;
def err_flexible_array_init : Error<
  "initialization of flexible array member is not allowed">;
def ext_flexible_array_empty_aggregate_ms : Extension<
  "flexible array member %0 in otherwise empty "
  "%select{struct|interface|union|class|enum}1 is a Microsoft extension">,
  InGroup<Microsoft>;
def ext_flexible_array_union_ms : Extension<
  "flexible array member %0 in a union is a Microsoft extension">,
  InGroup<Microsoft>;
def ext_flexible_array_empty_aggregate_gnu : Extension<
  "flexible array member %0 in otherwise empty "
  "%select{struct|interface|union|class|enum}1 is a GNU extension">,
  InGroup<GNU>;
def ext_flexible_array_union_gnu : Extension<
  "flexible array member %0 in a union is a GNU extension">, InGroup<GNU>;

let CategoryName = "ARC Semantic Issue" in {

// ARC-mode diagnostics.

let CategoryName = "ARC Weak References" in {

def err_arc_weak_no_runtime : Error<
  "the current deployment target does not support automated __weak references">;
def err_arc_unsupported_weak_class : Error<
  "class is incompatible with __weak references">;
def err_arc_weak_unavailable_assign : Error<
  "assignment of a weak-unavailable object to a __weak object">;
def err_arc_weak_unavailable_property : Error<
  "synthesizing __weak instance variable of type %0, which does not "
  "support weak references">;
def note_implemented_by_class : Note<
  "when implemented by class %0">;
def err_arc_convesion_of_weak_unavailable : Error<
  "%select{implicit conversion|cast}0 of weak-unavailable object of type %1 to"
  " a __weak object of type %2">;

} // end "ARC Weak References" category

let CategoryName = "ARC Restrictions" in {

def err_arc_illegal_explicit_message : Error<
  "ARC forbids explicit message send of %0">;
def err_arc_unused_init_message : Error<
  "the result of a delegate init call must be immediately returned "
  "or assigned to 'self'">;
def err_arc_mismatched_cast : Error<
  "%select{implicit conversion|cast}0 of "
  "%select{%2|a non-Objective-C pointer type %2|a block pointer|"
  "an Objective-C pointer|an indirect pointer to an Objective-C pointer}1"
  " to %3 is disallowed with ARC">;
def err_arc_nolifetime_behavior : Error<
  "explicit ownership qualifier on cast result has no effect">;
def err_arc_objc_object_in_tag : Error<
  "ARC forbids %select{Objective-C objects|blocks}0 in "
  "%select{struct|interface|union|<<ERROR>>|enum}1">;
def err_arc_objc_property_default_assign_on_object : Error<
  "ARC forbids synthesizing a property of an Objective-C object "
  "with unspecified ownership or storage attribute">;
def err_arc_illegal_selector : Error<
  "ARC forbids use of %0 in a @selector">;
def err_arc_illegal_method_def : Error<
  "ARC forbids %select{implementation|synthesis}0 of %1">;
def warn_arc_strong_pointer_objc_pointer : Warning<
  "method parameter of type %0 with no explicit ownership">,
  InGroup<DiagGroup<"explicit-ownership-type">>, DefaultIgnore;
  
} // end "ARC Restrictions" category
  
def err_arc_lost_method_convention : Error<
  "method was declared as %select{an 'alloc'|a 'copy'|an 'init'|a 'new'}0 "
  "method, but its implementation doesn't match because %select{"
  "its result type is not an object pointer|"
  "its result type is unrelated to its receiver type}1">;
def note_arc_lost_method_convention : Note<"declaration in interface">;
def err_arc_gained_method_convention : Error<
  "method implementation does not match its declaration">;
def note_arc_gained_method_convention : Note<
  "declaration in interface is not in the '%select{alloc|copy|init|new}0' "
  "family because %select{its result type is not an object pointer|"
  "its result type is unrelated to its receiver type}1">;
def err_typecheck_arc_assign_self : Error<
  "cannot assign to 'self' outside of a method in the init family">;
def err_typecheck_arc_assign_self_class_method : Error<
  "cannot assign to 'self' in a class method">;
def err_typecheck_arr_assign_enumeration : Error<
  "fast enumeration variables can't be modified in ARC by default; "
  "declare the variable __strong to allow this">;
def warn_arc_retained_assign : Warning<
  "assigning retained object to %select{weak|unsafe_unretained}0 "
  "%select{property|variable}1"
  "; object will be released after assignment">,
  InGroup<ARCUnsafeRetainedAssign>;
def warn_arc_retained_property_assign : Warning<
  "assigning retained object to unsafe property"
  "; object will be released after assignment">,
  InGroup<ARCUnsafeRetainedAssign>;
def warn_arc_literal_assign : Warning<
  "assigning %select{array literal|dictionary literal|numeric literal|boxed expression|<should not happen>|block literal}0"
  " to a weak %select{property|variable}1"
  "; object will be released after assignment">,
  InGroup<ARCUnsafeRetainedAssign>;
def err_arc_new_array_without_ownership : Error<
  "'new' cannot allocate an array of %0 with no explicit ownership">;
def err_arc_autoreleasing_var : Error<
  "%select{__block variables|global variables|fields|instance variables}0 cannot have "
  "__autoreleasing ownership">;
def err_arc_autoreleasing_capture : Error<
  "cannot capture __autoreleasing variable in a "
  "%select{block|lambda by copy}0">;
def err_arc_thread_ownership : Error<
  "thread-local variable has non-trivial ownership: type is %0">;
def err_arc_indirect_no_ownership : Error<
  "%select{pointer|reference}1 to non-const type %0 with no explicit ownership">;
def err_arc_array_param_no_ownership : Error<
  "must explicitly describe intended ownership of an object array parameter">;
def err_arc_pseudo_dtor_inconstant_quals : Error<
  "pseudo-destructor destroys object of type %0 with inconsistently-qualified "
  "type %1">;
def err_arc_init_method_unrelated_result_type : Error<
  "init methods must return a type related to the receiver type">;
def err_arc_nonlocal_writeback : Error<
  "passing address of %select{non-local|non-scalar}0 object to "
  "__autoreleasing parameter for write-back">;
def err_arc_method_not_found : Error<
  "no known %select{instance|class}1 method for selector %0">;
def err_arc_receiver_forward_class : Error<
  "receiver %0 for class message is a forward declaration">;
def err_arc_may_not_respond : Error<
  "no visible @interface for %0 declares the selector %1">;
def err_arc_receiver_forward_instance : Error<
  "receiver type %0 for instance message is a forward declaration">;
def warn_receiver_forward_instance : Warning<
  "receiver type %0 for instance message is a forward declaration">,
  InGroup<ForwardClassReceiver>, DefaultIgnore;
def err_arc_collection_forward : Error<
  "collection expression type %0 is a forward declaration">;
def err_arc_multiple_method_decl : Error< 
  "multiple methods named %0 found with mismatched result, "
  "parameter type or attributes">;
def warn_arc_lifetime_result_type : Warning<
  "ARC %select{unused|__unsafe_unretained|__strong|__weak|__autoreleasing}0 "
  "lifetime qualifier on return type is ignored">,
  InGroup<IgnoredQualifiers>;

let CategoryName = "ARC Retain Cycle" in {

def warn_arc_retain_cycle : Warning<
  "capturing %0 strongly in this block is likely to lead to a retain cycle">,
  InGroup<ARCRetainCycles>;
def note_arc_retain_cycle_owner : Note<
  "block will be retained by %select{the captured object|an object strongly "
  "retained by the captured object}0">;

} // end "ARC Retain Cycle" category

def warn_arc_object_memaccess : Warning<
  "%select{destination for|source of}0 this %1 call is a pointer to "
  "ownership-qualified type %2">, InGroup<ARCNonPodMemAccess>;

let CategoryName = "ARC and @properties" in {

def err_arc_strong_property_ownership : Error<
  "existing instance variable %1 for strong property %0 may not be "
  "%select{|__unsafe_unretained||__weak}2">;
def err_arc_assign_property_ownership : Error<
  "existing instance variable %1 for property %0 with %select{unsafe_unretained| assign}2 "
  "attribute must be __unsafe_unretained">;
def err_arc_inconsistent_property_ownership : Error<
  "%select{|unsafe_unretained|strong|weak}1 property %0 may not also be "
  "declared %select{|__unsafe_unretained|__strong|__weak|__autoreleasing}2">;

} // end "ARC and @properties" category

def err_arc_atomic_ownership : Error<
  "cannot perform atomic operation on a pointer to type %0: type has "
  "non-trivial ownership">;

let CategoryName = "ARC Casting Rules" in {

def err_arc_bridge_cast_incompatible : Error<
  "incompatible types casting %0 to %1 with a %select{__bridge|"
  "__bridge_transfer|__bridge_retained}2 cast">;
def err_arc_bridge_cast_wrong_kind : Error<
  "cast of %select{Objective-C|block|C}0 pointer type %1 to "
  "%select{Objective-C|block|C}2 pointer type %3 cannot use %select{__bridge|"
  "__bridge_transfer|__bridge_retained}4">;
def err_arc_cast_requires_bridge : Error<
  "%select{cast|implicit conversion}0 of %select{Objective-C|block|C}1 "
  "pointer type %2 to %select{Objective-C|block|C}3 pointer type %4 "
  "requires a bridged cast">;
def note_arc_bridge : Note<
  "use __bridge to convert directly (no change in ownership)">;
def note_arc_cstyle_bridge : Note<
  "use __bridge with C-style cast to convert directly (no change in ownership)">;
def note_arc_bridge_transfer : Note<
  "use %select{__bridge_transfer|CFBridgingRelease call}1 to transfer "
  "ownership of a +1 %0 into ARC">;
def note_arc_cstyle_bridge_transfer : Note<
  "use __bridge_transfer with C-style cast to transfer "
  "ownership of a +1 %0 into ARC">;
def note_arc_bridge_retained : Note<
  "use %select{__bridge_retained|CFBridgingRetain call}1 to make an "
  "ARC object available as a +1 %0">;
def note_arc_cstyle_bridge_retained : Note<
  "use __bridge_retained with C-style cast to make an "
  "ARC object available as a +1 %0">;

} // ARC Casting category

} // ARC category name

def err_flexible_array_init_needs_braces : Error<
  "flexible array requires brace-enclosed initializer">;
def err_illegal_decl_array_of_functions : Error<
  "'%0' declared as array of functions of type %1">;
def err_illegal_decl_array_incomplete_type : Error<
  "array has incomplete element type %0">;
def err_illegal_message_expr_incomplete_type : Error<
  "Objective-C message has incomplete result type %0">;
def err_illegal_decl_array_of_references : Error<
  "'%0' declared as array of references of type %1">;
def err_decl_negative_array_size : Error<
  "'%0' declared as an array with a negative size">;
def err_array_static_outside_prototype : Error<
  "%0 used in array declarator outside of function prototype">;
def err_array_static_not_outermost : Error<
  "%0 used in non-outermost array type derivation">;
def err_array_star_outside_prototype : Error<
  "star modifier used outside of function prototype">;
def err_illegal_decl_pointer_to_reference : Error<
  "'%0' declared as a pointer to a reference of type %1">;
def err_illegal_decl_mempointer_to_reference : Error<
  "'%0' declared as a member pointer to a reference of type %1">;
def err_illegal_decl_mempointer_to_void : Error<
  "'%0' declared as a member pointer to void">;
def err_illegal_decl_mempointer_in_nonclass : Error<
  "'%0' does not point into a class">;
def err_mempointer_in_nonclass_type : Error<
  "member pointer refers into non-class type %0">;
def err_reference_to_void : Error<"cannot form a reference to 'void'">;
def err_nonfunction_block_type : Error<
  "block pointer to non-function type is invalid">;
def err_return_block_has_expr : Error<"void block should not return a value">;
def err_block_return_missing_expr : Error<
  "non-void block should return a value">;
def err_func_def_incomplete_result : Error<
  "incomplete result type %0 in function definition">;
def err_atomic_specifier_bad_type : Error<
  "_Atomic cannot be applied to "
  "%select{incomplete |array |function |reference |atomic |qualified |}0type "
  "%1 %select{||||||which is not trivially copyable}0">;

// Expressions.
def ext_sizeof_alignof_function_type : Extension<
  "invalid application of '%select{sizeof|alignof|vec_step}0' to a "
  "function type">, InGroup<PointerArith>;
def ext_sizeof_alignof_void_type : Extension<
  "invalid application of '%select{sizeof|alignof|vec_step}0' to a void "
  "type">, InGroup<PointerArith>;
def err_sizeof_alignof_incomplete_type : Error<
  "invalid application of '%select{sizeof|alignof|vec_step}0' to an "
  "incomplete type %1">;
def err_sizeof_alignof_bitfield : Error<
  "invalid application of '%select{sizeof|alignof}0' to bit-field">;
def err_alignof_member_of_incomplete_type : Error<
  "invalid application of 'alignof' to a field of a class still being defined">;
def err_vecstep_non_scalar_vector_type : Error<
  "'vec_step' requires built-in scalar or vector type, %0 invalid">;
def err_offsetof_incomplete_type : Error<
  "offsetof of incomplete type %0">;
def err_offsetof_record_type : Error<
  "offsetof requires struct, union, or class type, %0 invalid">;
def err_offsetof_array_type : Error<"offsetof requires array type, %0 invalid">;
def ext_offsetof_extended_field_designator : Extension<
  "using extended field designator is an extension">,
  InGroup<DiagGroup<"extended-offsetof">>;
def warn_offsetof_non_pod_type : ExtWarn<"offset of on non-POD type %0">,
  InGroup<InvalidOffsetof>;
def warn_offsetof_non_standardlayout_type : ExtWarn<
  "offset of on non-standard-layout type %0">, InGroup<InvalidOffsetof>;
def err_offsetof_bitfield : Error<"cannot compute offset of bit-field %0">;

def warn_floatingpoint_eq : Warning<
  "comparing floating point with == or != is unsafe">,
  InGroup<DiagGroup<"float-equal">>, DefaultIgnore;

def warn_division_by_zero : Warning<"division by zero is undefined">,
  InGroup<DivZero>;
def warn_remainder_by_zero : Warning<"remainder by zero is undefined">,
  InGroup<DivZero>;
def warn_shift_negative : Warning<"shift count is negative">,
  InGroup<DiagGroup<"shift-count-negative">>;
def warn_shift_gt_typewidth : Warning<"shift count >= width of type">,
  InGroup<DiagGroup<"shift-count-overflow">>;
def warn_shift_result_gt_typewidth : Warning<
  "signed shift result (%0) requires %1 bits to represent, but %2 only has "
  "%3 bits">, InGroup<DiagGroup<"shift-overflow">>;
def warn_shift_result_sets_sign_bit : Warning<
  "signed shift result (%0) sets the sign bit of the shift expression's "
  "type (%1) and becomes negative">,
  InGroup<DiagGroup<"shift-sign-overflow">>, DefaultIgnore;

def warn_precedence_bitwise_rel : Warning<
  "%0 has lower precedence than %1; %1 will be evaluated first">,
  InGroup<Parentheses>;
def note_precedence_bitwise_first : Note<
  "place parentheses around the %0 expression to evaluate it first">;
def note_precedence_silence : Note<
  "place parentheses around the '%0' expression to silence this warning">;

def warn_precedence_conditional : Warning<
  "operator '?:' has lower precedence than '%0'; '%0' will be evaluated first">,
  InGroup<Parentheses>;
def note_precedence_conditional_first : Note<
  "place parentheses around the '?:' expression to evaluate it first">;

def warn_logical_instead_of_bitwise : Warning<
  "use of logical '%0' with constant operand">,
  InGroup<DiagGroup<"constant-logical-operand">>;
def note_logical_instead_of_bitwise_change_operator : Note<
  "use '%0' for a bitwise operation">;
def note_logical_instead_of_bitwise_remove_constant : Note<
  "remove constant to silence this warning">;

def warn_bitwise_and_in_bitwise_or : Warning<
  "'&' within '|'">, InGroup<BitwiseOpParentheses>;

def warn_logical_and_in_logical_or : Warning<
  "'&&' within '||'">, InGroup<LogicalOpParentheses>;

def warn_overloaded_shift_in_comparison :Warning<
  "overloaded operator %select{>>|<<}0 has lower precedence than "
  "comparison operator">,
  InGroup<OverloadedShiftOpParentheses>;
def note_evaluate_comparison_first :Note<
  "place parentheses around comparison expression to evaluate it first">;

def warn_addition_in_bitshift : Warning<
  "operator '%0' has lower precedence than '%1'; "
  "'%1' will be evaluated first">, InGroup<ShiftOpParentheses>;

def warn_self_assignment : Warning<
  "explicitly assigning a variable of type %0 to itself">,
  InGroup<SelfAssignment>, DefaultIgnore;

def warn_string_plus_int : Warning<
  "adding %0 to a string does not append to the string">,
  InGroup<StringPlusInt>;
def note_string_plus_int_silence : Note<
  "use array indexing to silence this warning">;

def warn_sizeof_array_param : Warning<
  "sizeof on array function parameter will return size of %0 instead of %1">,
  InGroup<SizeofArrayArgument>;

def warn_sizeof_array_decay : Warning<
  "sizeof on pointer operation will return size of %0 instead of %1">,
  InGroup<SizeofArrayDecay>;

def err_sizeof_nonfragile_interface : Error<
  "application of '%select{alignof|sizeof}1' to interface %0 is "
  "not supported on this architecture and platform">;
def err_atdef_nonfragile_interface : Error<
  "use of @defs is not supported on this architecture and platform">;
def err_subscript_nonfragile_interface : Error<
  "subscript requires size of interface %0, which is not constant for "
  "this architecture and platform">;

def err_arithmetic_nonfragile_interface : Error<
  "arithmetic on pointer to interface %0, which is not a constant size for "
  "this architecture and platform">;


def ext_subscript_non_lvalue : Extension<
  "ISO C90 does not allow subscripting non-lvalue array">;
def err_typecheck_subscript_value : Error<
  "subscripted value is not an array, pointer, or vector">;
def err_typecheck_subscript_not_integer : Error<
  "array subscript is not an integer">;
def err_subscript_function_type : Error<
  "subscript of pointer to function type %0">;
def err_subscript_incomplete_type : Error<
  "subscript of pointer to incomplete type %0">;
def err_dereference_incomplete_type : Error<
  "dereference of pointer to incomplete type %0">;
def ext_gnu_subscript_void_type : Extension<
  "subscript of a pointer to void is a GNU extension">, InGroup<PointerArith>;
def err_typecheck_member_reference_struct_union : Error<
  "member reference base type %0 is not a structure or union">;
def err_typecheck_member_reference_ivar : Error<
  "%0 does not have a member named %1">;
def error_arc_weak_ivar_access : Error<
  "dereferencing a __weak pointer is not allowed due to possible "
  "null value caused by race condition, assign it to strong variable first">;
def err_typecheck_member_reference_arrow : Error<
  "member reference type %0 is not a pointer">;
def err_typecheck_member_reference_suggestion : Error<
  "member reference type %0 is %select{a|not a}1 pointer; maybe you meant to use '%select{->|.}1'?">;
def err_typecheck_member_reference_type : Error<
  "cannot refer to type member %0 in %1 with '%select{.|->}2'">;
def err_typecheck_member_reference_unknown : Error<
  "cannot refer to member %0 in %1 with '%select{.|->}2'">;
def err_member_reference_needs_call : Error<
  "base of member reference is a function; perhaps you meant to call "
  "it%select{| with no arguments}0?">;
def warn_subscript_is_char : Warning<"array subscript is of type 'char'">,
  InGroup<CharSubscript>, DefaultIgnore;

def err_typecheck_incomplete_tag : Error<"incomplete definition of type %0">;
def err_no_member : Error<"no member named %0 in %1">;
def err_no_member_overloaded_arrow : Error<
  "no member named %0 in %1; did you mean to use '->' instead of '.'?">;

def err_member_not_yet_instantiated : Error<
  "no member %0 in %1; it has not yet been instantiated">;
def note_non_instantiated_member_here : Note<
  "not-yet-instantiated member is declared here">;

def err_enumerator_does_not_exist : Error<
  "enumerator %0 does not exist in instantiation of %1">;
def note_enum_specialized_here : Note<
  "enum %0 was explicitly specialized here">;

def err_member_redeclared : Error<"class member cannot be redeclared">;
def ext_member_redeclared : ExtWarn<"class member cannot be redeclared">,
  InGroup<GNU>;
def err_member_redeclared_in_instantiation : Error<
  "multiple overloads of %0 instantiate to the same signature %1">;
def err_member_name_of_class : Error<"member %0 has the same name as its class">;
def err_member_def_undefined_record : Error<
  "out-of-line definition of %0 from class %1 without definition">;
def err_member_def_does_not_match : Error<
  "out-of-line definition of %0 does not match any declaration in %1">;
def err_friend_decl_does_not_match : Error<
  "friend declaration of %0 does not match any declaration in %1">;
def err_member_def_does_not_match_suggest : Error<
  "out-of-line definition of %0 does not match any declaration in %1; "
  "did you mean %2?">;
def err_member_def_does_not_match_ret_type : Error<
  "out-of-line definition of %q0 differs from the declaration in the return type">;
def err_nonstatic_member_out_of_line : Error<
  "non-static data member defined out-of-line">;
def err_qualified_typedef_declarator : Error<
  "typedef declarator cannot be qualified">;
def err_qualified_param_declarator : Error<
  "parameter declarator cannot be qualified">;
def ext_out_of_line_declaration : ExtWarn<
  "out-of-line declaration of a member must be a definition">,
  InGroup<OutOfLineDeclaration>, DefaultError;
def warn_member_extra_qualification : Warning<
  "extra qualification on member %0">, InGroup<Microsoft>;
def err_member_extra_qualification : Error<
  "extra qualification on member %0">;
def err_member_qualification : Error<
  "non-friend class member %0 cannot have a qualified name">;  
def note_member_def_close_match : Note<"member declaration nearly matches">;
def note_member_def_close_const_match : Note<
  "member declaration does not match because "
  "it %select{is|is not}0 const qualified">;
def note_member_def_close_param_match : Note<
  "type of %ordinal0 parameter of member declaration does not match definition"
  "%diff{ ($ vs $)|}1,2">;
def err_typecheck_ivar_variable_size : Error<
  "instance variables must have a constant size">;
def err_ivar_reference_type : Error<
  "instance variables cannot be of reference type">;
def err_typecheck_illegal_increment_decrement : Error<
  "cannot %select{decrement|increment}1 value of type %0">;
def err_typecheck_arithmetic_incomplete_type : Error<
  "arithmetic on a pointer to an incomplete type %0">;
def err_typecheck_pointer_arith_function_type : Error<
  "arithmetic on%select{ a|}0 pointer%select{|s}0 to%select{ the|}2 "
  "function type%select{|s}2 %1%select{| and %3}2">;
def err_typecheck_pointer_arith_void_type : Error<
  "arithmetic on%select{ a|}0 pointer%select{|s}0 to void">;
def err_typecheck_decl_incomplete_type : Error<
  "variable has incomplete type %0">;
def ext_typecheck_decl_incomplete_type : ExtWarn<
  "tentative definition of variable with internal linkage has incomplete non-array type %0">,
  InGroup<DiagGroup<"tentative-definition-incomplete-type">>;
def err_tentative_def_incomplete_type : Error<
  "tentative definition has type %0 that is never completed">;
def err_tentative_def_incomplete_type_arr : Error<
  "tentative definition has array of type %0 that is never completed">;
def warn_tentative_incomplete_array : Warning<
  "tentative array definition assumed to have one element">;
def err_typecheck_incomplete_array_needs_initializer : Error<
  "definition of variable with array type needs an explicit size "
  "or an initializer">;
def err_array_init_not_init_list : Error<
  "array initializer must be an initializer "
  "list%select{| or string literal| or wide string literal}0">;
def err_array_init_narrow_string_into_wchar : Error<
  "initializing wide char array with non-wide string literal">;
def err_array_init_wide_string_into_char : Error<
  "initializing char array with wide string literal">;
def err_array_init_incompat_wide_string_into_wchar : Error<
  "initializing wide char array with incompatible wide string literal">;
def err_array_init_different_type : Error<
  "cannot initialize array %diff{of type $ with array of type $|"
  "with different type of array}0,1">;
def err_array_init_non_constant_array : Error<
  "cannot initialize array %diff{of type $ with non-constant array of type $|"
  "with different type of array}0,1">;
def ext_array_init_copy : Extension<
  "initialization of an array "
  "%diff{of type $ from a compound literal of type $|"
  "from a compound literal}0,1 is a GNU extension">, InGroup<GNU>;
// This is intentionally not disabled by -Wno-gnu.
def ext_array_init_parens : ExtWarn<
  "parenthesized initialization of a member array is a GNU extension">,
  InGroup<DiagGroup<"gnu-array-member-paren-init">>, DefaultError;
def warn_deprecated_string_literal_conversion : Warning<
  "conversion from string literal to %0 is deprecated">, InGroup<DeprecatedWritableStr>;
def err_realimag_invalid_type : Error<"invalid type %0 to %1 operator">;
def err_typecheck_sclass_fscope : Error<
  "illegal storage class on file-scoped variable">;
def err_unsupported_global_register : Error<
  "global register variables are not supported">;
def warn_standalone_specifier : Warning<"'%0' ignored on this declaration">,
  InGroup<MissingDeclarations>;
def ext_standalone_specifier : ExtWarn<"'%0' is not permitted on a declaration "
  "of a type">, InGroup<MissingDeclarations>;
def err_standalone_class_nested_name_specifier : Error<
  "forward declaration of %select{class|struct|interface|union|enum}0 cannot "
  "have a nested name specifier">;
def err_typecheck_sclass_func : Error<"illegal storage class on function">;
def err_static_block_func : Error<
  "function declared in block scope cannot have 'static' storage class">;
def err_typecheck_address_of : Error<"address of %select{bit-field"
  "|vector element|property expression|register variable}0 requested">;
def ext_typecheck_addrof_void : Extension<
  "ISO C forbids taking the address of an expression of type 'void'">;
def err_unqualified_pointer_member_function : Error<
  "must explicitly qualify name of member function when taking its address">;
def err_invalid_form_pointer_member_function : Error<
  "cannot create a non-constant pointer to member function">;
def err_parens_pointer_member_function : Error<
  "cannot parenthesize the name of a method when forming a member pointer">;
def err_typecheck_invalid_lvalue_addrof_addrof_function : Error<
  "extra '&' taking address of overloaded function">;
def err_typecheck_invalid_lvalue_addrof : Error<
  "cannot take the address of an rvalue of type %0">;
def ext_typecheck_addrof_temporary : ExtWarn<
  "taking the address of a temporary object of type %0">, 
  InGroup<DiagGroup<"address-of-temporary">>, DefaultError;
def err_typecheck_addrof_temporary : Error<
  "taking the address of a temporary object of type %0">;
def err_typecheck_unary_expr : Error<
  "invalid argument type %0 to unary expression">;
def err_typecheck_indirection_requires_pointer : Error<
  "indirection requires pointer operand (%0 invalid)">;
def warn_indirection_through_null : Warning<
  "indirection of non-volatile null pointer will be deleted, not trap">, InGroup<NullDereference>;
def note_indirection_through_null : Note<
  "consider using __builtin_trap() or qualifying pointer with 'volatile'">;
def warn_pointer_indirection_from_incompatible_type : Warning<
  "dereference of type %1 that was reinterpret_cast from type %0 has undefined "
  "behavior">,
  InGroup<UndefinedReinterpretCast>, DefaultIgnore;

def err_objc_object_assignment : Error<
  "cannot assign to class object (%0 invalid)">;
def err_typecheck_invalid_operands : Error<
  "invalid operands to binary expression (%0 and %1)">;
def err_typecheck_sub_ptr_compatible : Error<
  "%diff{$ and $ are not pointers to compatible types|"
  "pointers to incompatible types}0,1">;
def ext_typecheck_ordered_comparison_of_pointer_integer : ExtWarn<
  "ordered comparison between pointer and integer (%0 and %1)">;
def ext_typecheck_ordered_comparison_of_pointer_and_zero : Extension<
  "ordered comparison between pointer and zero (%0 and %1) is an extension">;
def ext_typecheck_ordered_comparison_of_function_pointers : ExtWarn<
  "ordered comparison of function pointers (%0 and %1)">;
def ext_typecheck_comparison_of_fptr_to_void : Extension<
  "equality comparison between function pointer and void pointer (%0 and %1)">;
def err_typecheck_comparison_of_fptr_to_void : Error<
  "equality comparison between function pointer and void pointer (%0 and %1)">;
def ext_typecheck_comparison_of_pointer_integer : ExtWarn<
  "comparison between pointer and integer (%0 and %1)">;
def err_typecheck_comparison_of_pointer_integer : Error<
  "comparison between pointer and integer (%0 and %1)">;
def ext_typecheck_comparison_of_distinct_pointers : ExtWarn<
  "comparison of distinct pointer types%diff{ ($ and $)|}0,1">,
  InGroup<CompareDistinctPointerType>;
def ext_typecheck_cond_incompatible_operands : ExtWarn<
  "incompatible operand types (%0 and %1)">;
def err_cond_voidptr_arc : Error <
  "operands to conditional of types%diff{ $ and $|}0,1 are incompatible "
  "in ARC mode">;
def err_typecheck_comparison_of_distinct_pointers : Error<
  "comparison of distinct pointer types%diff{ ($ and $)|}0,1">;
def ext_typecheck_comparison_of_distinct_pointers_nonstandard : ExtWarn<
  "comparison of distinct pointer types (%0 and %1) uses non-standard "
  "composite pointer type %2">, InGroup<CompareDistinctPointerType>;
def err_typecheck_assign_const : Error<"read-only variable is not assignable">;
def err_stmtexpr_file_scope : Error<
  "statement expression not allowed at file scope">;
def warn_mixed_sign_comparison : Warning<
  "comparison of integers of different signs: %0 and %1">,
  InGroup<SignCompare>, DefaultIgnore;
def warn_lunsigned_always_true_comparison : Warning<
  "comparison of unsigned%select{| enum}2 expression %0 is always %1">,
  InGroup<TautologicalCompare>;
def warn_out_of_range_compare : Warning<
  "comparison of constant %0 with expression of type %1 is always "
  "%select{false|true}2">, InGroup<TautologicalOutOfRangeCompare>;
def warn_runsigned_always_true_comparison : Warning<
  "comparison of %0 unsigned%select{| enum}2 expression is always %1">,
  InGroup<TautologicalCompare>;
def warn_comparison_of_mixed_enum_types : Warning<
  "comparison of two values with different enumeration types"
  "%diff{ ($ and $)|}0,1">,
  InGroup<DiagGroup<"enum-compare">>;
def warn_null_in_arithmetic_operation : Warning<
  "use of NULL in arithmetic operation">,
  InGroup<NullArithmetic>;
def warn_null_in_comparison_operation : Warning<
  "comparison between NULL and non-pointer "
  "%select{(%1 and NULL)|(NULL and %1)}0">,
  InGroup<NullArithmetic>;

def warn_logical_not_on_lhs_of_comparison : Warning<
  "logical not is only applied to the left hand side of this comparison">,
  InGroup<LogicalNotParentheses>;
def note_logical_not_fix : Note<
  "add parentheses after the '!' to evaluate the comparison first">;
def note_logical_not_silence_with_parens : Note<
  "add parentheses around left hand side expression to silence this warning">;

def err_invalid_this_use : Error<
  "invalid use of 'this' outside of a non-static member function">;
def err_this_static_member_func : Error<
  "'this' cannot be%select{| implicitly}0 used in a static member function "
  "declaration">;
def err_invalid_member_use_in_static_method : Error<
  "invalid use of member %0 in static member function">;
def err_invalid_qualified_function_type : Error<
  "%select{static |non-}0member function %select{of type %2 |}1"
  "cannot have '%3' qualifier">;
def err_compound_qualified_function_type : Error<
  "%select{block pointer|pointer|reference}0 to function type %select{%2 |}1"
  "cannot have '%3' qualifier">;

def err_ref_qualifier_overload : Error<
  "cannot overload a member function %select{without a ref-qualifier|with "
  "ref-qualifier '&'|with ref-qualifier '&&'}0 with a member function %select{"
  "without a ref-qualifier|with ref-qualifier '&'|with ref-qualifier '&&'}1">;

def err_invalid_non_static_member_use : Error<
  "invalid use of non-static data member %0">;
def err_nested_non_static_member_use : Error<
  "%select{call to non-static member function|use of non-static data member}0 "
  "%2 of %1 from nested type %3">;
def warn_cxx98_compat_non_static_member_use : Warning<
  "use of non-static data member %0 in an unevaluated context is "
  "incompatible with C++98">, InGroup<CXX98Compat>, DefaultIgnore;
def err_invalid_incomplete_type_use : Error<
  "invalid use of incomplete type %0">;
def err_builtin_func_cast_more_than_one_arg : Error<
  "function-style cast to a builtin type can only take one argument">;
def err_value_init_for_array_type : Error<
  "array types cannot be value-initialized">;
def warn_format_nonliteral_noargs : Warning<
  "format string is not a string literal (potentially insecure)">,
  InGroup<FormatSecurity>;
def warn_format_nonliteral : Warning<
  "format string is not a string literal">,
  InGroup<FormatNonLiteral>, DefaultIgnore;

def err_unexpected_interface : Error<
  "unexpected interface name %0: expected expression">;
def err_ref_non_value : Error<"%0 does not refer to a value">;
def err_ref_vm_type : Error<
  "cannot refer to declaration with a variably modified type inside block">;
def err_ref_flexarray_type : Error<
  "cannot refer to declaration of structure variable with flexible array member "
  "inside block">;
def err_ref_array_type : Error<
  "cannot refer to declaration with an array type inside block">;
def err_property_not_found : Error<
  "property %0 not found on object of type %1">;
def err_invalid_property_name : Error<
  "%0 is not a valid property name (accessing an object of type %1)">;
def err_getter_not_found : Error<
  "no getter method for read from property">;
def err_objc_subscript_method_not_found : Error<
  "expected method to %select{read|write}1 %select{dictionary|array}2 element not "
  "found on object of type %0">;
def err_objc_subscript_index_type : Error<
  "method index parameter type %0 is not integral type">;
def err_objc_subscript_key_type : Error<
  "method key parameter type %0 is not object type">;
def err_objc_subscript_dic_object_type : Error<
  "method object parameter type %0 is not object type">;
def err_objc_subscript_object_type : Error<
  "cannot assign to this %select{dictionary|array}1 because assigning method's "
  "2nd parameter of type %0 is not an Objective-C pointer type">;
def err_objc_subscript_base_type : Error<
  "%select{dictionary|array}1 subscript base type %0 is not an Objective-C object">;
def err_objc_multiple_subscript_type_conversion : Error<
  "indexing expression is invalid because subscript type %0 has "
  "multiple type conversion functions">;
def err_objc_subscript_type_conversion : Error<
  "indexing expression is invalid because subscript type %0 is not an integral"
  " or Objective-C pointer type">;
def err_objc_subscript_pointer : Error<
  "indexing expression is invalid because subscript type %0 is not an"
  " Objective-C pointer">;
def err_objc_indexing_method_result_type : Error<
  "method for accessing %select{dictionary|array}1 element must have Objective-C"
  " object return type instead of %0">;
def err_objc_index_incomplete_class_type : Error<
  "Objective-C index expression has incomplete class type %0">;
def err_illegal_container_subscripting_op : Error<
  "illegal operation on Objective-C container subscripting">;
def err_property_not_found_forward_class : Error<
  "property %0 cannot be found in forward class object %1">;
def err_property_not_as_forward_class : Error<
  "property %0 refers to an incomplete Objective-C class %1 "
  "(with no @interface available)">;
def note_forward_class : Note<
  "forward declaration of class here">;
def err_duplicate_property : Error<
  "property has a previous declaration">;
def ext_gnu_void_ptr : Extension<
  "arithmetic on%select{ a|}0 pointer%select{|s}0 to void is a GNU extension">,
  InGroup<PointerArith>;
def ext_gnu_ptr_func_arith : Extension<
  "arithmetic on%select{ a|}0 pointer%select{|s}0 to%select{ the|}2 function "
  "type%select{|s}2 %1%select{| and %3}2 is a GNU extension">,
  InGroup<PointerArith>;
def error_readonly_message_assignment : Error<
  "assigning to 'readonly' return result of an Objective-C message not allowed">;
def ext_integer_increment_complex : Extension<
  "ISO C does not support '++'/'--' on complex integer type %0">;
def ext_integer_complement_complex : Extension<
  "ISO C does not support '~' for complex conjugation of %0">;
def err_nosetter_property_assignment : Error<
  "%select{assignment to readonly property|"
  "no setter method %1 for assignment to property}0">;
def err_nosetter_property_incdec : Error<
  "%select{%select{increment|decrement}1 of readonly property|"
  "no setter method %2 for %select{increment|decrement}1 of property}0">;
def err_nogetter_property_compound_assignment : Error<
  "a getter method is needed to perform a compound assignment on a property">;
def err_nogetter_property_incdec : Error<
  "no getter method %1 for %select{increment|decrement}0 of property">;
def error_no_subobject_property_setting : Error<
  "expression is not assignable">;
def err_qualified_objc_access : Error<
  "%select{property|instance variable}0 access cannot be qualified with '%1'">;
  
def ext_freestanding_complex : Extension<
  "complex numbers are an extension in a freestanding C99 implementation">;

// FIXME: Remove when we support imaginary.
def err_imaginary_not_supported : Error<"imaginary types are not supported">;

// Obj-c expressions
def warn_root_inst_method_not_found : Warning<
  "instance method %0 is being used on 'Class' which is not in the root class">,
  InGroup<MethodAccess>;
def warn_class_method_not_found : Warning<
  "class method %objcclass0 not found (return type defaults to 'id')">,
  InGroup<MethodAccess>;
def warn_instance_method_on_class_found : Warning<
  "instance method %0 found instead of class method %1">,
  InGroup<MethodAccess>;
def warn_inst_method_not_found : Warning<
  "instance method %objcinstance0 not found (return type defaults to 'id')">,
  InGroup<MethodAccess>;
def error_no_super_class_message : Error<
  "no @interface declaration found in class messaging of %0">;
def error_root_class_cannot_use_super : Error<
  "%0 cannot use 'super' because it is a root class">;
def err_invalid_receiver_to_message_super : Error<
  "'super' is only valid in a method body">;
def err_invalid_receiver_class_message : Error<
  "receiver type %0 is not an Objective-C class">;
def err_missing_open_square_message_send : Error<
  "missing '[' at start of message send expression">;
def warn_bad_receiver_type : Warning<
  "receiver type %0 is not 'id' or interface pointer, consider "
  "casting it to 'id'">,InGroup<ObjCReceiver>;
def err_bad_receiver_type : Error<"bad receiver type %0">;
def err_unknown_receiver_suggest : Error<
  "unknown receiver %0; did you mean %1?">;
def error_objc_throw_expects_object : Error<
  "@throw requires an Objective-C object type (%0 invalid)">;
def error_objc_synchronized_expects_object : Error<
  "@synchronized requires an Objective-C object type (%0 invalid)">;
def error_rethrow_used_outside_catch : Error<
  "@throw (rethrow) used outside of a @catch block">;
def err_attribute_multiple_objc_gc : Error<
  "multiple garbage collection attributes specified for type">;
def err_catch_param_not_objc_type : Error<
  "@catch parameter is not a pointer to an interface type">;
def err_illegal_qualifiers_on_catch_parm : Error<
  "illegal qualifiers on @catch parameter">;
def err_storage_spec_on_catch_parm : Error<
  "@catch parameter cannot have storage specifier '%0'">;
def warn_register_objc_catch_parm : Warning<
  "'register' storage specifier on @catch parameter will be ignored">;
def err_qualified_objc_catch_parm : Error<
  "@catch parameter declarator cannot be qualified">;
def warn_objc_pointer_cxx_catch_fragile : Warning<
  "can not catch an exception thrown with @throw in C++ in the non-unified "
  "exception model">, InGroup<ObjCNonUnifiedException>;
def err_objc_object_catch : Error<
  "can't catch an Objective-C object by value">;
def err_incomplete_type_objc_at_encode : Error<
  "'@encode' of incomplete type %0">;

def warn_setter_getter_impl_required : Warning<
  "property %0 requires method %1 to be defined - "
  "use @synthesize, @dynamic or provide a method implementation "
  "in this class implementation">,
  InGroup<ObjCPropertyImpl>;
def warn_setter_getter_impl_required_in_category : Warning<
  "property %0 requires method %1 to be defined - "
  "use @dynamic or provide a method implementation in this category">,
  InGroup<ObjCPropertyImpl>;
def note_parameter_named_here : Note<
  "passing argument to parameter %0 here">;
def note_parameter_here : Note<
  "passing argument to parameter here">;

// C++ casts
// These messages adhere to the TryCast pattern: %0 is an int specifying the
// cast type, %1 is the source type, %2 is the destination type.
def err_bad_reinterpret_cast_overload : Error<
  "reinterpret_cast cannot resolve overloaded function %0 to type %1">;

def warn_reinterpret_different_from_static : Warning<
  "'reinterpret_cast' %select{from|to}3 class %0 %select{to|from}3 its "
  "%select{virtual base|base at non-zero offset}2 %1 behaves differently from "
  "'static_cast'">, InGroup<ReinterpretBaseClass>;
def note_reinterpret_updowncast_use_static: Note<
  "use 'static_cast' to adjust the pointer correctly while "
  "%select{upcasting|downcasting}0">;

def err_bad_static_cast_overload : Error<
  "address of overloaded function %0 cannot be static_cast to type %1">;

def err_bad_cstyle_cast_overload : Error<
  "address of overloaded function %0 cannot be cast to type %1">;


def err_bad_cxx_cast_generic : Error<
  "%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|"
  "functional-style cast}0 from %1 to %2 is not allowed">;
def err_bad_cxx_cast_rvalue : Error<
  "%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|"
  "functional-style cast}0 from rvalue to reference type %2">;
def err_bad_cxx_cast_bitfield : Error<
  "%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|"
  "functional-style cast}0 from bit-field lvalue to reference type %2">;
def err_bad_cxx_cast_qualifiers_away : Error<
  "%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|"
  "functional-style cast}0 from %1 to %2 casts away qualifiers">;
def err_bad_const_cast_dest : Error<
  "%select{const_cast||||C-style cast|functional-style cast}0 to %2, "
  "which is not a reference, pointer-to-object, or pointer-to-data-member">;
def ext_cast_fn_obj : Extension<
  "cast between pointer-to-function and pointer-to-object is an extension">;
def warn_cxx98_compat_cast_fn_obj : Warning<
  "cast between pointer-to-function and pointer-to-object is incompatible with C++98">,
  InGroup<CXX98CompatPedantic>, DefaultIgnore;
def err_bad_reinterpret_cast_small_int : Error<
  "cast from pointer to smaller type %2 loses information">;
def err_bad_cxx_cast_vector_to_scalar_different_size : Error<
  "%select{||reinterpret_cast||C-style cast|}0 from vector %1 " 
  "to scalar %2 of different size">;
def err_bad_cxx_cast_scalar_to_vector_different_size : Error<
  "%select{||reinterpret_cast||C-style cast|}0 from scalar %1 " 
  "to vector %2 of different size">;
def err_bad_cxx_cast_vector_to_vector_different_size : Error<
  "%select{||reinterpret_cast||C-style cast|}0 from vector %1 " 
  "to vector %2 of different size">;
def err_bad_lvalue_to_rvalue_cast : Error<
  "cannot cast from lvalue of type %1 to rvalue reference type %2; types are "
  "not compatible">;
def err_bad_static_cast_pointer_nonpointer : Error<
  "cannot cast from type %1 to pointer type %2">;
def err_bad_static_cast_member_pointer_nonmp : Error<
  "cannot cast from type %1 to member pointer type %2">;
def err_bad_cxx_cast_member_pointer_size : Error<
  "cannot %select{||reinterpret_cast||C-style cast|}0 from member pointer "
  "type %1 to member pointer type %2 of different size">;
def err_bad_reinterpret_cast_reference : Error<
  "reinterpret_cast of a %0 to %1 needs its address which is not allowed">;
def warn_undefined_reinterpret_cast : Warning<
  "reinterpret_cast from %0 to %1 has undefined behavior">,
  InGroup<UndefinedReinterpretCast>, DefaultIgnore;

// These messages don't adhere to the pattern.
// FIXME: Display the path somehow better.
def err_ambiguous_base_to_derived_cast : Error<
  "ambiguous cast from base %0 to derived %1:%2">;
def err_static_downcast_via_virtual : Error<
  "cannot cast %0 to %1 via virtual base %2">;
def err_downcast_from_inaccessible_base : Error<
  "cannot cast %select{private|protected}2 base class %1 to %0">;
def err_upcast_to_inaccessible_base : Error<
  "cannot cast %0 to its %select{private|protected}2 base class %1">;
def err_bad_dynamic_cast_not_ref_or_ptr : Error<
  "%0 is not a reference or pointer">;
def err_bad_dynamic_cast_not_class : Error<"%0 is not a class">;
def err_bad_dynamic_cast_incomplete : Error<"%0 is an incomplete type">;
def err_bad_dynamic_cast_not_ptr : Error<"%0 is not a pointer">;
def err_bad_dynamic_cast_not_polymorphic : Error<"%0 is not polymorphic">;

// Other C++ expressions
def err_need_header_before_typeid : Error<
  "you need to include <typeinfo> before using the 'typeid' operator">;
def err_need_header_before_ms_uuidof : Error<
  "you need to include <guiddef.h> before using the '__uuidof' operator">;
def err_uuidof_without_guid : Error<
  "cannot call operator __uuidof on a type with no GUID">;
def err_incomplete_typeid : Error<"'typeid' of incomplete type %0">;
def err_static_illegal_in_new : Error<
  "the 'static' modifier for the array size is not legal in new expressions">;
def err_array_new_needs_size : Error<
  "array size must be specified in new expressions">;
def err_bad_new_type : Error<
  "cannot allocate %select{function|reference}1 type %0 with new">;
def err_new_incomplete_type : Error<
  "allocation of incomplete type %0">;
def err_new_array_nonconst : Error<
  "only the first dimension of an allocated array may have dynamic size">;
def err_new_array_init_args : Error<
  "array 'new' cannot have initialization arguments">;
def ext_new_paren_array_nonconst : ExtWarn<
  "when type is in parentheses, array cannot have dynamic size">;
def err_placement_new_non_placement_delete : Error<
  "'new' expression with placement arguments refers to non-placement "
  "'operator delete'">;
def err_array_size_not_integral : Error<
  "array size expression must have integral or %select{|unscoped }0"
  "enumeration type, not %1">;
def err_array_size_incomplete_type : Error<
  "array size expression has incomplete class type %0">;
def err_array_size_explicit_conversion : Error<
  "array size expression of type %0 requires explicit conversion to type %1">;
def note_array_size_conversion : Note<
  "conversion to %select{integral|enumeration}0 type %1 declared here">;
def err_array_size_ambiguous_conversion : Error<
  "ambiguous conversion of array size expression of type %0 to an integral or "
  "enumeration type">;
def ext_array_size_conversion : Extension<
  "implicit conversion from array size expression of type %0 to "
  "%select{integral|enumeration}1 type %2 is a C++11 extension">,
  InGroup<CXX11>;
def warn_cxx98_compat_array_size_conversion : Warning<
  "implicit conversion from array size expression of type %0 to "
  "%select{integral|enumeration}1 type %2 is incompatible with C++98">,
  InGroup<CXX98CompatPedantic>, DefaultIgnore;
def err_address_space_qualified_new : Error<
  "'new' cannot allocate objects of type %0 in address space '%1'">;
def err_address_space_qualified_delete : Error<
  "'delete' cannot delete objects of type %0 in address space '%1'">;

def err_default_init_const : Error<
  "default initialization of an object of const type %0"
  "%select{| requires a user-provided default constructor}1">;
def err_delete_operand : Error<"cannot delete expression of type %0">;
def ext_delete_void_ptr_operand : ExtWarn<
  "cannot delete expression with pointer-to-'void' type %0">;
def err_ambiguous_delete_operand : Error<
  "ambiguous conversion of delete expression of type %0 to a pointer">;
def warn_delete_incomplete : Warning<
  "deleting pointer to incomplete type %0 may cause undefined behavior">,
  InGroup<DiagGroup<"delete-incomplete">>;
def err_delete_incomplete_class_type : Error<
  "deleting incomplete class type %0; no conversions to pointer type">;
def err_delete_explicit_conversion : Error<
  "converting delete expression from type %0 to type %1 invokes an explicit "
  "conversion function">;
def note_delete_conversion : Note<"conversion to pointer type %0">;
def warn_delete_array_type : Warning<
  "'delete' applied to a pointer-to-array type %0 treated as delete[]">;
def err_no_suitable_delete_member_function_found : Error<
  "no suitable member %0 in %1">;
def err_ambiguous_suitable_delete_member_function_found : Error<
  "multiple suitable %0 functions in %1">;
def note_member_declared_here : Note<
  "member %0 declared here">;
def err_decrement_bool : Error<"cannot decrement expression of type bool">;
def warn_increment_bool : Warning<
  "incrementing expression of type bool is deprecated">, InGroup<Deprecated>;
def err_catch_incomplete_ptr : Error<
  "cannot catch pointer to incomplete type %0">;
def err_catch_incomplete_ref : Error<
  "cannot catch reference to incomplete type %0">;
def err_catch_incomplete : Error<"cannot catch incomplete type %0">;
def err_catch_rvalue_ref : Error<"cannot catch exceptions by rvalue reference">;
def err_qualified_catch_declarator : Error<
  "exception declarator cannot be qualified">;
def err_early_catch_all : Error<"catch-all handler must come last">;
def err_bad_memptr_rhs : Error<
  "right hand operand to %0 has non pointer-to-member type %1">;
def err_bad_memptr_lhs : Error<
  "left hand operand to %0 must be a %select{|pointer to }1class "
  "compatible with the right hand operand, but is %2">;
def warn_exception_caught_by_earlier_handler : Warning<
  "exception of type %0 will be caught by earlier handler">;
def note_previous_exception_handler : Note<"for type %0">;
def err_exceptions_disabled : Error<
  "cannot use '%0' with exceptions disabled">;
def err_objc_exceptions_disabled : Error<
  "cannot use '%0' with Objective-C exceptions disabled">;
def warn_non_virtual_dtor : Warning<
  "%0 has virtual functions but non-virtual destructor">,
  InGroup<NonVirtualDtor>, DefaultIgnore;
def warn_delete_non_virtual_dtor : Warning<
  "delete called on %0 that has virtual functions but non-virtual destructor">,
  InGroup<DeleteNonVirtualDtor>, DefaultIgnore;
def warn_delete_abstract_non_virtual_dtor : Warning<
  "delete called on %0 that is abstract but has non-virtual destructor">,
  InGroup<DeleteNonVirtualDtor>;
def warn_overloaded_virtual : Warning<
  "%q0 hides overloaded virtual %select{function|functions}1">,
  InGroup<OverloadedVirtual>, DefaultIgnore;
def note_hidden_overloaded_virtual_declared_here : Note<
  "hidden overloaded virtual function %q0 declared here"
  "%select{|: different classes%diff{ ($ vs $)|}2,3"
  "|: different number of parameters (%2 vs %3)"
  "|: type mismatch at %ordinal2 parameter%diff{ ($ vs $)|}3,4"
  "|: different return type%diff{ ($ vs $)|}2,3"
  "|: different qualifiers ("
  "%select{none|const|restrict|const and restrict|volatile|const and volatile|"
  "volatile and restrict|const, volatile, and restrict}2 vs "
  "%select{none|const|restrict|const and restrict|volatile|const and volatile|"
  "volatile and restrict|const, volatile, and restrict}3)}1">;
def warn_using_directive_in_header : Warning<
  "using namespace directive in global context in header">,
  InGroup<HeaderHygiene>, DefaultIgnore;
def warn_overaligned_type : Warning<
  "type %0 requires %1 bytes of alignment and the default allocator only "
  "guarantees %2 bytes">,
  InGroup<OveralignedType>, DefaultIgnore;

def err_conditional_void_nonvoid : Error<
  "%select{left|right}1 operand to ? is void, but %select{right|left}1 operand "
  "is of type %0">;
def err_conditional_ambiguous : Error<
  "conditional expression is ambiguous; "
  "%diff{$ can be converted to $ and vice versa|"
  "types can be convert to each other}0,1">;
def err_conditional_ambiguous_ovl : Error<
  "conditional expression is ambiguous; %diff{$ and $|types}0,1 "
  "can be converted to several common types">;

def err_throw_incomplete : Error<
  "cannot throw object of incomplete type %0">;
def err_throw_incomplete_ptr : Error<
  "cannot throw pointer to object of incomplete type %0">;
def err_return_in_constructor_handler : Error<
  "return in the catch of a function try block of a constructor is illegal">;

let CategoryName = "Lambda Issue" in {
  def err_capture_more_than_once : Error<
    "%0 can appear only once in a capture list">;
  def err_reference_capture_with_reference_default : Error<
    "'&' cannot precede a capture when the capture default is '&'">;
  def err_this_capture_with_copy_default : Error<
    "'this' cannot be explicitly captured when the capture default is '='">;
  def err_copy_capture_with_copy_default : Error<
    "'&' must precede a capture when the capture default is '='">;
  def err_capture_does_not_name_variable : Error<
    "%0 in capture list does not name a variable">;
  def err_capture_non_automatic_variable : Error<
    "%0 cannot be captured because it does not have automatic storage "
    "duration">;
  def err_this_capture : Error<
    "'this' cannot be %select{implicitly |}0captured in this context">;
  def err_lambda_capture_anonymous_var : Error<
    "unnamed variable cannot be implicitly captured in a lambda expression">;
  def err_lambda_capture_vm_type : Error<
    "variable %0 with variably modified type cannot be captured in "
    "a lambda expression">;
  def err_lambda_capture_flexarray_type : Error<
    "variable %0 with flexible array member cannot be captured in "
    "a lambda expression">;
  def err_lambda_impcap : Error<
    "variable %0 cannot be implicitly captured in a lambda with no "
    "capture-default specified">;
  def note_lambda_decl : Note<"lambda expression begins here">;
  def err_lambda_unevaluated_operand : Error<
    "lambda expression in an unevaluated operand">;
  def err_lambda_return_init_list : Error<
    "cannot deduce lambda return type from initializer list">;
  def err_lambda_capture_default_arg : Error<
    "lambda expression in default argument cannot capture any entity">;
  def err_lambda_incomplete_result : Error<
    "incomplete result type %0 in lambda expression">;
  def err_noreturn_lambda_has_return_expr : Error<
    "lambda declared 'noreturn' should not return">;
  def warn_maybe_falloff_nonvoid_lambda : Warning<
    "control may reach end of non-void lambda">,
    InGroup<ReturnType>;
  def warn_falloff_nonvoid_lambda : Warning<
    "control reaches end of non-void lambda">,
    InGroup<ReturnType>;
  def err_access_lambda_capture : Error<
    // The ERRORs represent other special members that aren't constructors, in
    // hopes that someone will bother noticing and reporting if they appear
    "capture of variable '%0' as type %1 calls %select{private|protected}3 "
    "%select{default |copy |move |*ERROR* |*ERROR* |*ERROR* |}2constructor">,
    AccessControl;
  def note_lambda_to_block_conv : Note<
    "implicit capture of lambda object due to conversion to block pointer "
    "here">;

  // C++1y lambda init-captures.
  def err_init_capture_no_expression : Error<
    "initializer missing for lambda capture %0">;
  def err_init_capture_multiple_expressions : Error<
    "initializer for lambda capture %0 contains multiple expressions">;
  def err_init_capture_deduction_failure : Error<
    "cannot deduce type for lambda capture %0 from initializer of type %1">;
  def err_init_capture_deduction_failure_from_init_list : Error<
    "cannot deduce type for lambda capture %0 from initializer list">;
}

def err_return_in_captured_stmt : Error<
  "cannot return from %0">;
def err_capture_block_variable : Error<
  "__block variable %0 cannot be captured in a "
  "%select{lambda expression|captured statement}1">;

def err_operator_arrow_circular : Error<
  "circular pointer delegation detected">;
def err_pseudo_dtor_base_not_scalar : Error<
  "object expression of non-scalar type %0 cannot be used in a "
  "pseudo-destructor expression">;
def ext_pseudo_dtor_on_void : ExtWarn<
  "pseudo-destructors on type void are a Microsoft extension">,
  InGroup<Microsoft>;
def err_pseudo_dtor_type_mismatch : Error<
  "the type of object expression "
  "%diff{($) does not match the type being destroyed ($)|"
  "does not match the type being destroyed}0,1 "
  "in pseudo-destructor expression">;
def err_pseudo_dtor_call_with_args : Error<
  "call to pseudo-destructor cannot have any arguments">;
def err_dtor_expr_without_call : Error<
  "%select{destructor reference|pseudo-destructor expression}0 must be "
  "called immediately with '()'">;
def err_pseudo_dtor_destructor_non_type : Error<
  "%0 does not refer to a type name in pseudo-destructor expression; expected "
  "the name of type %1">;
def err_invalid_use_of_function_type : Error<
  "a function type is not allowed here">;
def err_invalid_use_of_array_type : Error<"an array type is not allowed here">;
def err_type_defined_in_condition : Error<
  "types may not be defined in conditions">;
def err_typecheck_bool_condition : Error<
  "value of type %0 is not contextually convertible to 'bool'">;
def err_typecheck_ambiguous_condition : Error<
  "conversion %diff{from $ to $|between types}0,1 is ambiguous">;
def err_typecheck_nonviable_condition : Error<
  "no viable conversion%diff{ from $ to $|}0,1">;
def err_typecheck_deleted_function : Error<
  "conversion function %diff{from $ to $|between types}0,1 "
  "invokes a deleted function">;
  
def err_expected_class_or_namespace : Error<"expected a class or namespace">;
def err_expected_class : Error<"%0 is not a class%select{ or namespace|, "
  "namespace, or scoped enumeration}1">;
def err_invalid_declarator_scope : Error<"cannot define or redeclare %0 here "
  "because namespace %1 does not enclose namespace %2">;
def err_invalid_declarator_global_scope : Error<
  "definition or redeclaration of %0 cannot name the global scope">;
def err_invalid_declarator_in_function : Error<
  "definition or redeclaration of %0 not allowed inside a function">;
def err_not_tag_in_scope : Error<
  "no %select{struct|interface|union|class|enum}0 named %1 in %2">;

def err_no_typeid_with_fno_rtti : Error<
  "cannot use typeid with -fno-rtti">;

def err_cannot_form_pointer_to_member_of_reference_type : Error<
  "cannot form a pointer-to-member to member %0 of reference type %1">;
def err_incomplete_object_call : Error<
  "incomplete type in call to object of type %0">;

def warn_condition_is_assignment : Warning<"using the result of an "
  "assignment as a condition without parentheses">,
  InGroup<Parentheses>;
// Completely identical except off by default.
def warn_condition_is_idiomatic_assignment : Warning<"using the result "
  "of an assignment as a condition without parentheses">,
  InGroup<DiagGroup<"idiomatic-parentheses">>, DefaultIgnore;
def note_condition_assign_to_comparison : Note<
  "use '==' to turn this assignment into an equality comparison">;
def note_condition_or_assign_to_comparison : Note<
  "use '!=' to turn this compound assignment into an inequality comparison">;
def note_condition_assign_silence : Note<
  "place parentheses around the assignment to silence this warning">;

def warn_equality_with_extra_parens : Warning<"equality comparison with "
  "extraneous parentheses">, InGroup<ParenthesesOnEquality>;
def note_equality_comparison_to_assign : Note<
  "use '=' to turn this equality comparison into an assignment">;
def note_equality_comparison_silence : Note<
  "remove extraneous parentheses around the comparison to silence this warning">;

// assignment related diagnostics (also for argument passing, returning, etc).
// In most of these diagnostics the %2 is a value from the
// Sema::AssignmentAction enumeration
def err_typecheck_convert_incompatible : Error<
  "%select{%diff{assigning to $ from incompatible type $|"
  "assigning to type from incompatible type}0,1"
  "|%diff{passing $ to parameter of incompatible type $|"
  "passing type to parameter of incompatible type}0,1"
  "|%diff{returning $ from a function with incompatible result type $|"
  "returning type from a function with incompatible result type}0,1"
  "|%diff{converting $ to incompatible type $|"
  "converting type to incompatible type}0,1"
  "|%diff{initializing $ with an expression of incompatible type $|"
  "initializing type with an expression of incompatible type}0,1"
  "|%diff{sending $ to parameter of incompatible type $|"
  "sending type to parameter of incompatible type}0,1"
  "|%diff{casting $ to incompatible type $|"
  "casting type to incompatible type}0,1}2"
  "%select{|; dereference with *|"
  "; take the address with &|"
  "; remove *|"
  "; remove &}3"
  "%select{|: different classes%diff{ ($ vs $)|}5,6"
  "|: different number of parameters (%5 vs %6)"
  "|: type mismatch at %ordinal5 parameter%diff{ ($ vs $)|}6,7"
  "|: different return type%diff{ ($ vs $)|}5,6"
  "|: different qualifiers ("
  "%select{none|const|restrict|const and restrict|volatile|const and volatile|"
  "volatile and restrict|const, volatile, and restrict}5 vs "
  "%select{none|const|restrict|const and restrict|volatile|const and volatile|"
  "volatile and restrict|const, volatile, and restrict}6)}4">;
def err_typecheck_missing_return_type_incompatible : Error<
  "%diff{return type $ must match previous return type $|"
  "return type must match previous return type}0,1 when %select{block "
  "literal|lambda expression}2 has unspecified explicit return type">;

def warn_incompatible_qualified_id : Warning<
  "%select{%diff{assigning to $ from incompatible type $|"
  "assigning to type from incompatible type}0,1"
  "|%diff{passing $ to parameter of incompatible type $|"
  "passing type to parameter of incompatible type}0,1"
  "|%diff{returning $ from a function with incompatible result type $|"
  "returning type from a function with incompatible result type}0,1"
  "|%diff{converting $ to incompatible type $|"
  "converting type to incompatible type}0,1"
  "|%diff{initializing $ with an expression of incompatible type $|"
  "initializing type with an expression of incompatible type}0,1"
  "|%diff{sending $ to parameter of incompatible type $|"
  "sending type to parameter of incompatible type}0,1"
  "|%diff{casting $ to incompatible type $|"
  "casting type to incompatible type}0,1}2">;
def ext_typecheck_convert_pointer_int : ExtWarn<
  "incompatible pointer to integer conversion "
  "%select{%diff{assigning to $ from $|assigning to different types}0,1"
  "|%diff{passing $ to parameter of type $|"
  "passing to parameter of different type}0,1"
  "|%diff{returning $ from a function with result type $|"
  "returning from function with different return type}0,1"
  "|%diff{converting $ to type $|converting between types}0,1"
  "|%diff{initializing $ with an expression of type $|"
  "initializing with expression of different type}0,1"
  "|%diff{sending $ to parameter of type $|"
  "sending to parameter of different type}0,1"
  "|%diff{casting $ to type $|casting between types}0,1}2"
  "%select{|; dereference with *|"
  "; take the address with &|"
  "; remove *|"
  "; remove &}3">,
  InGroup<IntConversion>;
def ext_typecheck_convert_int_pointer : ExtWarn<
  "incompatible integer to pointer conversion "
  "%select{%diff{assigning to $ from $|assigning to different types}0,1"
  "|%diff{passing $ to parameter of type $|"
  "passing to parameter of different type}0,1"
  "|%diff{returning $ from a function with result type $|"
  "returning from function with different return type}0,1"
  "|%diff{converting $ to type $|converting between types}0,1"
  "|%diff{initializing $ with an expression of type $|"
  "initializing with expression of different type}0,1"
  "|%diff{sending $ to parameter of type $|"
  "sending to parameter of different type}0,1"
  "|%diff{casting $ to type $|casting between types}0,1}2"
  "%select{|; dereference with *|"
  "; take the address with &|"
  "; remove *|"
  "; remove &}3">,
  InGroup<IntConversion>;
def ext_typecheck_convert_pointer_void_func : Extension<
  "%select{%diff{assigning to $ from $|assigning to different types}0,1"
  "|%diff{passing $ to parameter of type $|"
  "passing to parameter of different type}0,1"
  "|%diff{returning $ from a function with result type $|"
  "returning from function with different return type}0,1"
  "|%diff{converting $ to type $|converting between types}0,1"
  "|%diff{initializing $ with an expression of type $|"
  "initializing with expression of different type}0,1"
  "|%diff{sending $ to parameter of type $|"
  "sending to parameter of different type}0,1"
  "|%diff{casting $ to type $|casting between types}0,1}2"
  " converts between void pointer and function pointer">;
def ext_typecheck_convert_incompatible_pointer_sign : ExtWarn<
  "%select{%diff{assigning to $ from $|assigning to different types}0,1"
  "|%diff{passing $ to parameter of type $|"
  "passing to parameter of different type}0,1"
  "|%diff{returning $ from a function with result type $|"
  "returning from function with different return type}0,1"
  "|%diff{converting $ to type $|converting between types}0,1"
  "|%diff{initializing $ with an expression of type $|"
  "initializing with expression of different type}0,1"
  "|%diff{sending $ to parameter of type $|"
  "sending to parameter of different type}0,1"
  "|%diff{casting $ to type $|casting between types}0,1}2"
  " converts between pointers to integer types with different sign">,
  InGroup<DiagGroup<"pointer-sign">>;
def ext_typecheck_convert_incompatible_pointer : ExtWarn<
  "incompatible pointer types "
  "%select{%diff{assigning to $ from $|assigning to different types}0,1"
  "|%diff{passing $ to parameter of type $|"
  "passing to parameter of different type}0,1"
  "|%diff{returning $ from a function with result type $|"
  "returning from function with different return type}0,1"
  "|%diff{converting $ to type $|converting between types}0,1"
  "|%diff{initializing $ with an expression of type $|"
  "initializing with expression of different type}0,1"
  "|%diff{sending $ to parameter of type $|"
  "sending to parameter of different type}0,1"
  "|%diff{casting $ to type $|casting between types}0,1}2"
  "%select{|; dereference with *|"
  "; take the address with &|"
  "; remove *|"
  "; remove &}3">,
  InGroup<IncompatiblePointerTypes>;
def ext_typecheck_convert_discards_qualifiers : ExtWarn<
  "%select{%diff{assigning to $ from $|assigning to different types}0,1"
  "|%diff{passing $ to parameter of type $|"
  "passing to parameter of different type}0,1"
  "|%diff{returning $ from a function with result type $|"
  "returning from function with different return type}0,1"
  "|%diff{converting $ to type $|converting between types}0,1"
  "|%diff{initializing $ with an expression of type $|"
  "initializing with expression of different type}0,1"
  "|%diff{sending $ to parameter of type $|"
  "sending to parameter of different type}0,1"
  "|%diff{casting $ to type $|casting between types}0,1}2"
  " discards qualifiers">,
  InGroup<IncompatiblePointerTypesDiscardsQualifiers>;
def ext_nested_pointer_qualifier_mismatch : ExtWarn<
  "%select{%diff{assigning to $ from $|assigning to different types}0,1"
  "|%diff{passing $ to parameter of type $|"
  "passing to parameter of different type}0,1"
  "|%diff{returning $ from a function with result type $|"
  "returning from function with different return type}0,1"
  "|%diff{converting $ to type $|converting between types}0,1"
  "|%diff{initializing $ with an expression of type $|"
  "initializing with expression of different type}0,1"
  "|%diff{sending $ to parameter of type $|"
  "sending to parameter of different type}0,1"
  "|%diff{casting $ to type $|casting between types}0,1}2"
  " discards qualifiers in nested pointer types">,
  InGroup<IncompatiblePointerTypesDiscardsQualifiers>;
def warn_incompatible_vectors : Warning<
  "incompatible vector types "
  "%select{%diff{assigning to $ from $|assigning to different types}0,1"
  "|%diff{passing $ to parameter of type $|"
  "passing to parameter of different type}0,1"
  "|%diff{returning $ from a function with result type $|"
  "returning from function with different return type}0,1"
  "|%diff{converting $ to type $|converting between types}0,1"
  "|%diff{initializing $ with an expression of type $|"
  "initializing with expression of different type}0,1"
  "|%diff{sending $ to parameter of type $|"
  "sending to parameter of different type}0,1"
  "|%diff{casting $ to type $|casting between types}0,1}2">,
  InGroup<VectorConversion>, DefaultIgnore;
def err_int_to_block_pointer : Error<
  "invalid block pointer conversion "
  "%select{%diff{assigning to $ from $|assigning to different types}0,1"
  "|%diff{passing $ to parameter of type $|"
  "passing to parameter of different type}0,1"
  "|%diff{returning $ from a function with result type $|"
  "returning from function with different return type}0,1"
  "|%diff{converting $ to type $|converting between types}0,1"
  "|%diff{initializing $ with an expression of type $|"
  "initializing with expression of different type}0,1"
  "|%diff{sending $ to parameter of type $|"
  "sending to parameter of different type}0,1"
  "|%diff{casting $ to type $|casting between types}0,1}2">;
def err_typecheck_convert_incompatible_block_pointer : Error<
  "incompatible block pointer types "
  "%select{%diff{assigning to $ from $|assigning to different types}0,1"
  "|%diff{passing $ to parameter of type $|"
  "passing to parameter of different type}0,1"
  "|%diff{returning $ from a function with result type $|"
  "returning from function with different return type}0,1"
  "|%diff{converting $ to type $|converting between types}0,1"
  "|%diff{initializing $ with an expression of type $|"
  "initializing with expression of different type}0,1"
  "|%diff{sending $ to parameter of type $|"
  "sending to parameter of different type}0,1"
  "|%diff{casting $ to type $|casting between types}0,1}2">;
def err_typecheck_incompatible_address_space : Error<
  "%select{%diff{assigning $ to $|assigning to different types}1,0"
  "|%diff{passing $ to parameter of type $|"
  "passing to parameter of different type}0,1"
  "|%diff{returning $ from a function with result type $|"
  "returning from function with different return type}0,1"
  "|%diff{converting $ to type $|converting between types}0,1"
  "|%diff{initializing $ with an expression of type $|"
  "initializing with expression of different type}0,1"
  "|%diff{sending $ to parameter of type $|"
  "sending to parameter of different type}0,1"
  "|%diff{casting $ to type $|casting between types}0,1}2"
  " changes address space of pointer">;
def err_typecheck_incompatible_ownership : Error<
  "%select{%diff{assigning $ to $|assigning to different types}1,0"
  "|%diff{passing $ to parameter of type $|"
  "passing to parameter of different type}0,1"
  "|%diff{returning $ from a function with result type $|"
  "returning from function with different return type}0,1"
  "|%diff{converting $ to type $|converting between types}0,1"
  "|%diff{initializing $ with an expression of type $|"
  "initializing with expression of different type}0,1"
  "|%diff{sending $ to parameter of type $|"
  "sending to parameter of different type}0,1"
  "|%diff{casting $ to type $|casting between types}0,1}2"
  " changes retain/release properties of pointer">;
def err_typecheck_comparison_of_distinct_blocks : Error<
  "comparison of distinct block types%diff{ ($ and $)|}0,1">;

def err_typecheck_array_not_modifiable_lvalue : Error<
  "array type %0 is not assignable">;
def err_typecheck_non_object_not_modifiable_lvalue : Error<
  "non-object type %0 is not assignable">;
def err_typecheck_expression_not_modifiable_lvalue : Error<
  "expression is not assignable">;
def err_typecheck_incomplete_type_not_modifiable_lvalue : Error<
  "incomplete type %0 is not assignable">;
def err_typecheck_lvalue_casts_not_supported : Error<
  "assignment to cast is illegal, lvalue casts are not supported">;

def err_typecheck_duplicate_vector_components_not_mlvalue : Error<
  "vector is not assignable (contains duplicate components)">;
def err_block_decl_ref_not_modifiable_lvalue : Error<
  "variable is not assignable (missing __block type specifier)">;
def err_lambda_decl_ref_not_modifiable_lvalue : Error<
  "cannot assign to a variable captured by copy in a non-mutable lambda">;
def err_typecheck_call_not_function : Error<
  "called object type %0 is not a function or function pointer">;
def err_call_incomplete_return : Error<
  "calling function with incomplete return type %0">;
def err_call_function_incomplete_return : Error<
  "calling %0 with incomplete return type %1">;
def note_function_with_incomplete_return_type_declared_here : Note<
  "%0 declared here">;
def err_call_incomplete_argument : Error<
  "argument type %0 is incomplete">;
def err_typecheck_call_too_few_args : Error<
  "too few %select{|||execution configuration }0arguments to "
  "%select{function|block|method|kernel function}0 call, "
  "expected %1, have %2">;
def err_typecheck_call_too_few_args_one : Error<
  "too few %select{|||execution configuration }0arguments to "
  "%select{function|block|method|kernel function}0 call, "
  "single argument %1 was not specified">;
def err_typecheck_call_too_few_args_at_least : Error<
  "too few %select{|||execution configuration }0arguments to "
  "%select{function|block|method|kernel function}0 call, "
  "expected at least %1, have %2">;
def err_typecheck_call_too_few_args_at_least_one : Error<
  "too few %select{|||execution configuration }0arguments to "
  "%select{function|block|method|kernel function}0 call, "
  "at least argument %1 must be specified">;
def err_typecheck_call_too_many_args : Error<
  "too many %select{|||execution configuration }0arguments to "
  "%select{function|block|method|kernel function}0 call, "
  "expected %1, have %2">;
def err_typecheck_call_too_many_args_one : Error<
  "too many %select{|||execution configuration }0arguments to "
  "%select{function|block|method|kernel function}0 call, "
  "expected single argument %1, have %2 arguments">;
def err_typecheck_call_too_many_args_at_most : Error<
  "too many %select{|||execution configuration }0arguments to "
  "%select{function|block|method|kernel function}0 call, "
  "expected at most %1, have %2">;
def err_typecheck_call_too_many_args_at_most_one : Error<
  "too many %select{|||execution configuration }0arguments to "
  "%select{function|block|method|kernel function}0 call, "
  "expected at most single argument %1, have %2 arguments">;
def note_callee_decl : Note<
  "%0 declared here">;
def note_defined_here : Note<"%0 defined here">;

def err_builtin_fn_use : Error<"builtin functions must be directly called">;

def warn_call_wrong_number_of_arguments : Warning<
  "too %select{few|many}0 arguments in call to %1">;
def err_atomic_builtin_must_be_pointer : Error<
  "first argument to atomic builtin must be a pointer (%0 invalid)">;
def err_atomic_builtin_must_be_pointer_intptr : Error<
  "first argument to atomic builtin must be a pointer to integer or pointer"
  " (%0 invalid)">;
def err_atomic_builtin_pointer_size : Error<
  "first argument to atomic builtin must be a pointer to 1,2,4,8 or 16 byte "
  "type (%0 invalid)">;
def err_atomic_op_needs_atomic : Error<
  "first argument to atomic operation must be a pointer to _Atomic "
  "type (%0 invalid)">;
def err_atomic_op_needs_non_const_atomic : Error<
  "first argument to atomic operation must be a pointer to non-const _Atomic "
  "type (%0 invalid)">;
def err_atomic_op_needs_trivial_copy : Error<
  "first argument to atomic operation must be a pointer to a trivially-copyable"
  " type (%0 invalid)">;
def err_atomic_op_needs_atomic_int_or_ptr : Error<
  "first argument to atomic operation must be a pointer to %select{|atomic }0"
  "integer or pointer (%1 invalid)">;
def err_atomic_op_bitwise_needs_atomic_int : Error<
  "first argument to bitwise atomic operation must be a pointer to "
  "%select{|atomic }0integer (%1 invalid)">;
  
def err_atomic_load_store_uses_lib : Error<
  "atomic %select{load|store}0 requires runtime support that is not "
  "available for this target">;

def err_deleted_function_use : Error<"attempt to use a deleted function">;

def err_kern_type_not_void_return : Error<
  "kernel function type %0 must have void return type">;
def err_config_scalar_return : Error<
  "CUDA special function 'cudaConfigureCall' must have scalar return type">;
def err_kern_call_not_global_function : Error<
  "kernel call to non-global function %0">;
def err_global_call_not_config : Error<
  "call to global function %0 not configured">;
def err_ref_bad_target : Error<
  "reference to %select{__device__|__global__|__host__|__host__ __device__}0 "
  "function %1 in %select{__device__|__global__|__host__|__host__ __device__}2 function">;

def warn_non_pod_vararg_with_format_string : Warning<
  "cannot pass %select{non-POD|non-trivial}0 object of type %1 to variadic "
  "%select{function|block|method|constructor}2; expected type from format "
  "string was %3">, InGroup<NonPODVarargs>, DefaultError;
// The arguments to this diagnostic should match the warning above.
def err_cannot_pass_objc_interface_to_vararg_format : Error<
  "cannot pass object with interface type %1 by value to variadic "
  "%select{function|block|method|constructor}2; expected type from format "
  "string was %3">;

def err_cannot_pass_objc_interface_to_vararg : Error<
  "cannot pass object with interface type %0 by value through variadic "
  "%select{function|block|method|constructor}1">;
def warn_cannot_pass_non_pod_arg_to_vararg : Warning<
  "cannot pass object of %select{non-POD|non-trivial}0 type %1 through variadic"
  " %select{function|block|method|constructor}2; call will abort at runtime">,
  InGroup<NonPODVarargs>, DefaultError;
def warn_cxx98_compat_pass_non_pod_arg_to_vararg : Warning<
  "passing object of trivial but non-POD type %0 through variadic"
  " %select{function|block|method|constructor}1 is incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;

def err_typecheck_call_invalid_ordered_compare : Error<
  "ordered compare requires two args of floating point type"
  "%diff{ ($ and $)|}0,1">;
def err_typecheck_call_invalid_unary_fp : Error<
  "floating point classification requires argument of floating point type "
  "(passed in %0)">;
def err_typecheck_cond_expect_scalar : Error<
  "used type %0 where arithmetic or pointer type is required">;
def ext_typecheck_cond_one_void : Extension<
  "C99 forbids conditional expressions with only one void side">;
def err_typecheck_cond_expect_scalar_or_vector : Error<
  "used type %0 where arithmetic, pointer, or vector type is required">;
def err_typecheck_cast_to_incomplete : Error<
  "cast to incomplete type %0">;
def ext_typecheck_cast_nonscalar : Extension<
  "C99 forbids casting nonscalar type %0 to the same type">;
def ext_typecheck_cast_to_union : Extension<
  "cast to union type is a GNU extension">,
  InGroup<GNU>;
def err_typecheck_cast_to_union_no_type : Error<
  "cast to union type from type %0 not present in union">;
def err_cast_pointer_from_non_pointer_int : Error<
  "operand of type %0 cannot be cast to a pointer type">;
def warn_cast_pointer_from_sel : Warning<
  "cast of type %0 to %1 is deprecated; use sel_getName instead">,
  InGroup<SelTypeCast>;
def warn_bad_function_cast : Warning<
  "cast from function call of type %0 to non-matching type %1">,
  InGroup<BadFunctionCast>, DefaultIgnore;
def err_cast_pointer_to_non_pointer_int : Error<
  "pointer cannot be cast to type %0">;
def err_typecheck_expect_scalar_operand : Error<
  "operand of type %0 where arithmetic or pointer type is required">;
def err_typecheck_cond_incompatible_operands : Error<
  "incompatible operand types%diff{ ($ and $)|}0,1">;
def ext_typecheck_cond_incompatible_operands_nonstandard : ExtWarn<
  "incompatible operand types%diff{ ($ and $)|}0,1 use non-standard composite "
  "pointer type %2">;
def err_cast_selector_expr : Error<
  "cannot type cast @selector expression">;
def warn_typecheck_cond_incompatible_pointers : ExtWarn<
  "pointer type mismatch%diff{ ($ and $)|}0,1">,
  InGroup<DiagGroup<"pointer-type-mismatch">>;
def warn_typecheck_cond_pointer_integer_mismatch : ExtWarn<
  "pointer/integer type mismatch in conditional expression"
  "%diff{ ($ and $)|}0,1">,
  InGroup<DiagGroup<"conditional-type-mismatch">>;
def err_typecheck_choose_expr_requires_constant : Error<
  "'__builtin_choose_expr' requires a constant expression">;
def warn_unused_expr : Warning<"expression result unused">,
  InGroup<UnusedValue>;
def warn_unused_voidptr : Warning<
  "expression result unused; should this cast be to 'void'?">,
  InGroup<UnusedValue>;
def warn_unused_property_expr : Warning<
 "property access result unused - getters should not be used for side effects">,
  InGroup<UnusedValue>;
def warn_unused_container_subscript_expr : Warning<
 "container access result unused - container access should not be used for side effects">,
  InGroup<UnusedValue>;
def warn_unused_call : Warning<
  "ignoring return value of function declared with %0 attribute">,
  InGroup<UnusedValue>;
def warn_unused_result : Warning<
  "ignoring return value of function declared with warn_unused_result "
  "attribute">, InGroup<DiagGroup<"unused-result">>;
def warn_unused_volatile : Warning<
  "expression result unused; assign into a variable to force a volatile load">,
  InGroup<DiagGroup<"unused-volatile-lvalue">>;

def warn_unused_comparison : Warning<
  "%select{equality|inequality}0 comparison result unused">,
  InGroup<UnusedComparison>;
def note_inequality_comparison_to_or_assign : Note<
  "use '|=' to turn this inequality comparison into an or-assignment">;

def err_incomplete_type_used_in_type_trait_expr : Error<
  "incomplete type %0 used in type trait expression">;
def err_type_trait_arity : Error<
  "type trait requires %0%select{| or more}1 argument%select{|s}2; have "
  "%3 argument%s3">;
  
def err_dimension_expr_not_constant_integer : Error<
  "dimension expression does not evaluate to a constant unsigned int">;
def err_expected_ident_or_lparen : Error<"expected identifier or '('">;

def err_typecheck_cond_incompatible_operands_null : Error<
  "non-pointer operand type %0 incompatible with %select{NULL|nullptr}1">;
def ext_empty_struct_union : Extension<
  "empty %select{struct|union}0 is a GNU extension">, InGroup<GNU>;
def ext_no_named_members_in_struct_union : Extension<
  "%select{struct|union}0 without named members is a GNU extension">, InGroup<GNU>;
def warn_empty_struct_union_compat : Warning<"empty %select{struct|union}0 "
  "has size 0 in C, size 1 in C++">, InGroup<CXXCompat>, DefaultIgnore;
def warn_zero_size_struct_union_compat : Warning<"%select{struct|union}0 "
  "with only bit-fields of width 0 has size 0 in C, size 1 in C++">,
  InGroup<CXXCompat>, DefaultIgnore;
} // End of general sema category.

// inline asm.
let CategoryName = "Inline Assembly Issue" in {
  def err_asm_wide_character : Error<"wide string is invalid in 'asm'">;
  def err_asm_invalid_lvalue_in_output : Error<"invalid lvalue in asm output">;
  def err_asm_invalid_output_constraint : Error<
    "invalid output constraint '%0' in asm">;
  def err_asm_invalid_lvalue_in_input : Error<
    "invalid lvalue in asm input for constraint '%0'">;
  def err_asm_invalid_input_constraint : Error<
    "invalid input constraint '%0' in asm">;
  def err_asm_invalid_type_in_input : Error<
    "invalid type %0 in asm input for constraint '%1'">;
  def err_asm_tying_incompatible_types : Error<
    "unsupported inline asm: input with type "
    "%diff{$ matching output with type $|}0,1">;
  def err_asm_incomplete_type : Error<"asm operand has incomplete type %0">;
  def err_asm_unknown_register_name : Error<"unknown register name '%0' in asm">;
  def err_asm_invalid_input_size : Error<
    "invalid input size for constraint '%0'">;
  def err_invalid_asm_cast_lvalue : Error<
    "invalid use of a cast in a inline asm context requiring an l-value: "
    "remove the cast or build with -fheinous-gnu-extensions">;

  def warn_asm_label_on_auto_decl : Warning<
    "ignored asm label '%0' on automatic variable">;
  def warn_invalid_asm_cast_lvalue : Warning<
    "invalid use of a cast in an inline asm context requiring an l-value: "
    "accepted due to -fheinous-gnu-extensions, but clang may remove support "
    "for this in the future">;
  def warn_asm_mismatched_size_modifier : Warning<
    "value size does not match register size specified by the constraint "
    "and modifier">,
    InGroup<ASMOperandWidths>;
}

let CategoryName = "Semantic Issue" in {

def err_invalid_conversion_between_vectors : Error<
  "invalid conversion between vector type%diff{ $ and $|}0,1 of different "
  "size">;
def err_invalid_conversion_between_vector_and_integer : Error<
  "invalid conversion between vector type %0 and integer type %1 "
  "of different size">;

def err_invalid_conversion_between_vector_and_scalar : Error<
  "invalid conversion between vector type %0 and scalar type %1">;

// C++ member initializers.
def err_only_constructors_take_base_inits : Error<
  "only constructors take base initializers">;

def err_multiple_mem_initialization : Error <
  "multiple initializations given for non-static member %0">;
def err_multiple_mem_union_initialization : Error <
  "initializing multiple members of union">;
def err_multiple_base_initialization : Error <
  "multiple initializations given for base %0">;

def err_mem_init_not_member_or_class : Error<
  "member initializer %0 does not name a non-static data member or base "
  "class">;

def warn_initializer_out_of_order : Warning<
  "%select{field|base class}0 %1 will be initialized after "
  "%select{field|base}2 %3">,
  InGroup<Reorder>, DefaultIgnore;

def err_base_init_does_not_name_class : Error<
  "constructor initializer %0 does not name a class">;
def err_base_init_direct_and_virtual : Error<
  "base class initializer %0 names both a direct base class and an "
  "inherited virtual base class">;
def err_not_direct_base_or_virtual : Error<
  "type %0 is not a direct or virtual base of %1">;

def err_in_class_initializer_non_const : Error<
  "non-const static data member must be initialized out of line">;
def err_in_class_initializer_volatile : Error<
  "static const volatile data member must be initialized out of line">;
def err_in_class_initializer_bad_type : Error<
  "static data member of type %0 must be initialized out of line">;
def ext_in_class_initializer_float_type : ExtWarn<
  "in-class initializer for static data member of type %0 is a GNU extension">,
  InGroup<GNUStaticFloatInit>;
def ext_in_class_initializer_float_type_cxx11 : ExtWarn<
  "in-class initializer for static data member of type %0 requires "
  "'constexpr' specifier">, InGroup<StaticFloatInit>, DefaultError;
def note_in_class_initializer_float_type_cxx11 : Note<"add 'constexpr'">;
def err_in_class_initializer_literal_type : Error<
  "in-class initializer for static data member of type %0 requires "
  "'constexpr' specifier">;
def err_in_class_initializer_non_constant : Error<
  "in-class initializer for static data member is not a constant expression">;
def err_in_class_initializer_references_def_ctor : Error<
  "defaulted default constructor of %0 cannot be used by non-static data "
  "member initializer which appears before end of class definition">;

def ext_in_class_initializer_non_constant : Extension<
  "in-class initializer for static data member is not a constant expression; "
  "folding it to a constant is a GNU extension">, InGroup<GNU>;

def err_thread_dynamic_init : Error<
  "initializer for thread-local variable must be a constant expression">;
def err_thread_nontrivial_dtor : Error<
  "type of thread-local variable has non-trivial destruction">;
def note_use_thread_local : Note<
  "use 'thread_local' to allow this">;

// C++ anonymous unions and GNU anonymous structs/unions
def ext_anonymous_union : Extension<
  "anonymous unions are a C11 extension">, InGroup<C11>;
def ext_gnu_anonymous_struct : Extension<
  "anonymous structs are a GNU extension">, InGroup<GNU>;
def ext_c11_anonymous_struct : Extension<
  "anonymous structs are a C11 extension">, InGroup<C11>;
def err_anonymous_union_not_static : Error<
  "anonymous unions at namespace or global scope must be declared 'static'">;
def err_anonymous_union_with_storage_spec : Error<
  "anonymous union at class scope must not have a storage specifier">;
def err_anonymous_struct_not_member : Error<
  "anonymous %select{structs|structs and classes}0 must be "
  "%select{struct or union|class}0 members">;
def err_anonymous_union_member_redecl : Error<
  "member of anonymous union redeclares %0">;
def err_anonymous_struct_member_redecl : Error<
  "member of anonymous struct redeclares %0">;
def err_anonymous_record_with_type : Error<
  "types cannot be declared in an anonymous %select{struct|union}0">;
def ext_anonymous_record_with_type : Extension<
  "types declared in an anonymous %select{struct|union}0 are a Microsoft "
  "extension">, InGroup<Microsoft>;
def ext_anonymous_record_with_anonymous_type : Extension<
  "anonymous types declared in an anonymous %select{struct|union}0 "
  "are an extension">, InGroup<DiagGroup<"nested-anon-types">>;
def err_anonymous_record_with_function : Error<
  "functions cannot be declared in an anonymous %select{struct|union}0">;
def err_anonymous_record_with_static : Error<
  "static members cannot be declared in an anonymous %select{struct|union}0">;
def err_anonymous_record_bad_member : Error<
  "anonymous %select{struct|union}0 can only contain non-static data members">;
def err_anonymous_record_nonpublic_member : Error<
  "anonymous %select{struct|union}0 cannot contain a "
  "%select{private|protected}1 data member">;
def ext_ms_anonymous_struct : ExtWarn<
  "anonymous structs are a Microsoft extension">, InGroup<Microsoft>;

// C++ local classes
def err_reference_to_local_var_in_enclosing_function : Error<
  "reference to local variable %0 declared in enclosing function %1">;
def err_reference_to_local_var_in_enclosing_block : Error<
  "reference to local variable %0 declared in enclosing block literal">;
def err_reference_to_local_var_in_enclosing_lambda : Error<
  "reference to local variable %0 declared in enclosing lambda expression">;
def err_reference_to_local_var_in_enclosing_context : Error<
  "reference to local variable %0 declared in enclosing context">;

def note_local_variable_declared_here : Note<
  "%0 declared here">;
def err_static_data_member_not_allowed_in_local_class : Error<
  "static data member %0 not allowed in local class %1">; 
  
// C++ derived classes
def err_base_clause_on_union : Error<"unions cannot have base classes">;
def err_base_must_be_class : Error<"base specifier must name a class">;
def err_union_as_base_class : Error<"unions cannot be base classes">;
def err_circular_inheritance : Error<
  "circular inheritance between %0 and %1">;
def err_incomplete_base_class : Error<"base class has incomplete type">;
def err_duplicate_base_class : Error<
  "base class %0 specified more than once as a direct base class">;
// FIXME: better way to display derivation?  Pass entire thing into diagclient?
def err_ambiguous_derived_to_base_conv : Error<
  "ambiguous conversion from derived class %0 to base class %1:%2">;
def err_ambiguous_memptr_conv : Error<
  "ambiguous conversion from pointer to member of %select{base|derived}0 "
  "class %1 to pointer to member of %select{derived|base}0 class %2:%3">;

def err_memptr_conv_via_virtual : Error<
  "conversion from pointer to member of class %0 to pointer to member "
  "of class %1 via virtual base %2 is not allowed">;

// C++ member name lookup
def err_ambiguous_member_multiple_subobjects : Error<
  "non-static member %0 found in multiple base-class subobjects of type %1:%2">;
def err_ambiguous_member_multiple_subobject_types : Error<
  "member %0 found in multiple base classes of different types">;
def note_ambiguous_member_found : Note<"member found by ambiguous name lookup">;
def err_ambiguous_reference : Error<"reference to %0 is ambiguous">;
def note_ambiguous_candidate : Note<"candidate found by name lookup is %q0">;
def err_ambiguous_tag_hiding : Error<"a type named %0 is hidden by a "
  "declaration in a different namespace">;
def note_hidden_tag : Note<"type declaration hidden">;
def note_hiding_object : Note<"declaration hides type">;

// C++ operator overloading
def err_operator_overload_needs_class_or_enum : Error<
  "overloaded %0 must have at least one parameter of class "
  "or enumeration type">;

def err_operator_overload_variadic : Error<"overloaded %0 cannot be variadic">;
def err_operator_overload_static : Error<
  "overloaded %0 cannot be a static member function">;
def err_operator_overload_default_arg : Error<
  "parameter of overloaded %0 cannot have a default argument">;
def err_operator_overload_must_be : Error<
  "overloaded %0 must be a %select{unary|binary|unary or binary}2 operator "
  "(has %1 parameter%s1)">;

def err_operator_overload_must_be_member : Error<
  "overloaded %0 must be a non-static member function">;
def err_operator_overload_post_incdec_must_be_int : Error<
  "parameter of overloaded post-%select{increment|decrement}1 operator must "
  "have type 'int' (not %0)">;

// C++ allocation and deallocation functions.
def err_operator_new_delete_declared_in_namespace : Error<
  "%0 cannot be declared inside a namespace">;
def err_operator_new_delete_declared_static : Error<
  "%0 cannot be declared static in global scope">;
def err_operator_new_delete_invalid_result_type : Error<
  "%0 must return type %1">;
def err_operator_new_delete_dependent_result_type : Error<
  "%0 cannot have a dependent return type; use %1 instead">;
def err_operator_new_delete_too_few_parameters : Error<
  "%0 must have at least one parameter">;
def err_operator_new_delete_template_too_few_parameters : Error<
  "%0 template must have at least two parameters">;

def err_operator_new_dependent_param_type : Error<
  "%0 cannot take a dependent type as first parameter; "
  "use size_t (%1) instead">;
def err_operator_new_param_type : Error<
  "%0 takes type size_t (%1) as first parameter">;
def err_operator_new_default_arg: Error<
  "parameter of %0 cannot have a default argument">;
def err_operator_delete_dependent_param_type : Error<
  "%0 cannot take a dependent type as first parameter; use %1 instead">;
def err_operator_delete_param_type : Error<
  "first parameter of %0 must have type %1">;

// C++ literal operators
def err_literal_operator_outside_namespace : Error<
  "literal operator %0 must be in a namespace or global scope">;
def err_literal_operator_default_argument : Error<
  "literal operator cannot have a default argument">;
// FIXME: This diagnostic sucks
def err_literal_operator_params : Error<
  "parameter declaration for literal operator %0 is not valid">;
def err_literal_operator_extern_c : Error<
  "literal operator must have C++ linkage">;
def warn_user_literal_reserved : Warning<
  "user-defined literal suffixes not starting with '_' are reserved; "
  "no literal will invoke this operator">,
  InGroup<UserDefinedLiterals>;

// C++ conversion functions
def err_conv_function_not_member : Error<
  "conversion function must be a non-static member function">;
def err_conv_function_return_type : Error<
  "conversion function cannot have a return type">;
def err_conv_function_with_params : Error<
  "conversion function cannot have any parameters">;
def err_conv_function_variadic : Error<
  "conversion function cannot be variadic">;
def err_conv_function_to_array : Error<
  "conversion function cannot convert to an array type">;
def err_conv_function_to_function : Error<
  "conversion function cannot convert to a function type">;
def err_conv_function_with_complex_decl : Error<
  "must use a typedef to declare a conversion to %0">;
def err_conv_function_redeclared : Error<
  "conversion function cannot be redeclared">;
def warn_conv_to_self_not_used : Warning<
  "conversion function converting %0 to itself will never be used">;
def warn_conv_to_base_not_used : Warning<
  "conversion function converting %0 to its base class %1 will never be used">;
def warn_conv_to_void_not_used : Warning<
  "conversion function converting %0 to %1 will never be used">;

def warn_not_compound_assign : Warning<
  "use of unary operator that may be intended as compound assignment (%0=)">;

// C++11 explicit conversion operators
def ext_explicit_conversion_functions : ExtWarn<
  "explicit conversion functions are a C++11 extension">, InGroup<CXX11>;
def warn_cxx98_compat_explicit_conversion_functions : Warning<
  "explicit conversion functions are incompatible with C++98">,
  InGroup<CXX98Compat>, DefaultIgnore;

// C++11 defaulted functions
def err_defaulted_special_member_params : Error<
  "an explicitly-defaulted %select{|copy |move }0constructor cannot "
  "have default arguments">;
def err_defaulted_special_member_variadic : Error<
  "an explicitly-defaulted %select{|copy |move }0constructor cannot "
  "be variadic">;
def err_defaulted_special_member_return_type : Error<
  "explicitly-defaulted %select{copy|move}0 assignment operator must "
  "return %1">;
def err_defaulted_special_member_quals : Error<
  "an explicitly-defaulted %select{copy|move}0 assignment operator may not "
  "have 'const'%select{, 'constexpr'|}1 or 'volatile' qualifiers">;
def err_defaulted_special_member_volatile_param : Error<
  "the parameter for an explicitly-defaulted %select{<<ERROR>>|"
  "copy constructor|move constructor|copy assignment operator|"
  "move assignment operator|<<ERROR>>}0 may not be volatile">;
def err_defaulted_special_member_move_const_param : Error<
  "the parameter for an explicitly-defaulted move "
  "%select{constructor|assignment operator}0 may not be const">;
def err_defaulted_special_member_copy_const_param : Error<
  "the parameter for this explicitly-defaulted copy "
  "%select{constructor|assignment operator}0 is const, but a member or base "
  "requires it to be non-const">;
def err_defaulted_copy_assign_not_ref : Error<
  "the parameter for an explicitly-defaulted copy assignment operator must be an "
  "lvalue reference type">;
def err_incorrect_defaulted_exception_spec : Error<
  "exception specification of explicitly defaulted %select{default constructor|"
  "copy constructor|move constructor|copy assignment operator|move assignment "
  "operator|destructor}0 does not match the "
  "calculated one">;
def err_incorrect_defaulted_constexpr : Error<
  "defaulted definition of %select{default constructor|copy constructor|"
  "move constructor|copy assignment operator|move assignment operator}0 "
  "is not constexpr">;
def err_out_of_line_default_deletes : Error<
  "defaulting this %select{default constructor|copy constructor|move "
  "constructor|copy assignment operator|move assignment operator|destructor}0 "
  "would delete it after its first declaration">;
def ext_implicit_exception_spec_mismatch : ExtWarn<
  "function previously declared with an %select{explicit|implicit}0 exception "
  "specification redeclared with an %select{implicit|explicit}0 exception "
  "specification">, InGroup<DiagGroup<"implicit-exception-spec-mismatch">>;

def warn_ptr_arith_precedes_bounds : Warning<
  "the pointer decremented by %0 refers before the beginning of the array">,
  InGroup<ArrayBoundsPointerArithmetic>, DefaultIgnore;
def warn_ptr_arith_exceeds_bounds : Warning<
  "the pointer incremented by %0 refers past the end of the array (that "
  "contains %1 element%s2)">,
  InGroup<ArrayBoundsPointerArithmetic>, DefaultIgnore;
def warn_array_index_precedes_bounds : Warning<
  "array index %0 is before the beginning of the array">,
  InGroup<ArrayBounds>;
def warn_array_index_exceeds_bounds : Warning<
  "array index %0 is past the end of the array (which contains %1 "
  "element%s2)">, InGroup<ArrayBounds>;
def note_array_index_out_of_bounds : Note<
  "array %0 declared here">;

def warn_printf_insufficient_data_args : Warning<
  "more '%%' conversions than data arguments">, InGroup<Format>;
def warn_printf_data_arg_not_used : Warning<
  "data argument not used by format string">, InGroup<FormatExtraArgs>;
def warn_format_invalid_conversion : Warning<
  "invalid conversion specifier '%0'">, InGroup<FormatInvalidSpecifier>;
def warn_printf_incomplete_specifier : Warning<
  "incomplete format specifier">, InGroup<Format>;
def warn_missing_format_string : Warning<
  "format string missing">, InGroup<Format>;
def warn_scanf_nonzero_width : Warning<
  "zero field width in scanf format string is unused">,
  InGroup<Format>;
def warn_printf_conversion_argument_type_mismatch : Warning<
  "format specifies type %0 but the argument has type %1">,
  InGroup<Format>;
def warn_format_argument_needs_cast : Warning<
  "values of type '%0' should not be used as format arguments; add an explicit "
  "cast to %1 instead">,
  InGroup<Format>;
def warn_printf_positional_arg_exceeds_data_args : Warning <
  "data argument position '%0' exceeds the number of data arguments (%1)">,
  InGroup<Format>;
def warn_format_zero_positional_specifier : Warning<
  "position arguments in format strings start counting at 1 (not 0)">,
  InGroup<Format>;
def warn_format_invalid_positional_specifier : Warning<
  "invalid position specified for %select{field width|field precision}0">,
  InGroup<Format>;
def warn_format_mix_positional_nonpositional_args : Warning<
  "cannot mix positional and non-positional arguments in format string">,
  InGroup<Format>;
def warn_static_array_too_small : Warning<
  "array argument is too small; contains %0 elements, callee requires at least %1">,
  InGroup<ArrayBounds>;
def note_callee_static_array : Note<
  "callee declares array parameter as static here">;
def warn_empty_format_string : Warning<
  "format string is empty">, InGroup<FormatZeroLength>;
def warn_format_string_is_wide_literal : Warning<
  "format string should not be a wide string">, InGroup<Format>;
def warn_printf_format_string_contains_null_char : Warning<
  "format string contains '\\0' within the string body">, InGroup<Format>;
def warn_printf_asterisk_missing_arg : Warning<
  "'%select{*|.*}0' specified field %select{width|precision}0 is missing a matching 'int' argument">,
  InGroup<Format>;
def warn_printf_asterisk_wrong_type : Warning<
  "field %select{width|precision}0 should have type %1, but argument has type %2">,
  InGroup<Format>;
def warn_printf_nonsensical_optional_amount: Warning<
  "%select{field width|precision}0 used with '%1' conversion specifier, resulting in undefined behavior">,
  InGroup<Format>;
def warn_printf_nonsensical_flag: Warning<
  "flag '%0' results in undefined behavior with '%1' conversion specifier">,
  InGroup<Format>;
def warn_format_nonsensical_length: Warning<
  "length modifier '%0' results in undefined behavior or no effect with '%1' conversion specifier">,
  InGroup<Format>;
def warn_format_non_standard_positional_arg: ExtWarn<
  "positional arguments are not supported by ISO C">, InGroup<FormatNonStandard>, DefaultIgnore;
def warn_format_non_standard: ExtWarn<
  "'%0' %select{length modifier|conversion specifier}1 is not supported by ISO C">,
  InGroup<FormatNonStandard>, DefaultIgnore;
def warn_format_non_standard_conversion_spec: ExtWarn<
  "using length modifier '%0' with conversion specifier '%1' is not supported by ISO C">,
  InGroup<FormatNonStandard>, DefaultIgnore;
def warn_printf_ignored_flag: Warning<
  "flag '%0' is ignored when flag '%1' is present">,
  InGroup<Format>;
def warn_scanf_scanlist_incomplete : Warning<
  "no closing ']' for '%%[' in scanf format string">,
  InGroup<Format>;
def note_format_string_defined : Note<"format string is defined here">;
def note_format_fix_specifier : Note<"did you mean to use '%0'?">;
def note_printf_c_str: Note<"did you mean to call the %0 method?">;

def warn_null_arg : Warning<
  "null passed to a callee which requires a non-null argument">,
  InGroup<NonNull>;

// CHECK: returning address/reference of stack memory
def warn_ret_stack_addr : Warning<
  "address of stack memory associated with local variable %0 returned">,
  InGroup<ReturnStackAddress>;
def warn_ret_stack_ref : Warning<
  "reference to stack memory associated with local variable %0 returned">,
  InGroup<ReturnStackAddress>;
def warn_ret_local_temp_addr : Warning<
  "returning address of local temporary object">,
  InGroup<ReturnStackAddress>;
def warn_ret_local_temp_ref : Warning<
  "returning reference to local temporary object">,
  InGroup<ReturnStackAddress>;
def warn_ret_addr_label : Warning<
  "returning address of label, which is local">,
  InGroup<ReturnStackAddress>;
def err_ret_local_block : Error<
  "returning block that lives on the local stack">;
def note_ref_var_local_bind : Note<
  "binding reference variable %0 here">;

// Check for initializing a member variable with the address or a reference to
// a constructor parameter.
def warn_bind_ref_member_to_parameter : Warning<
  "binding reference member %0 to stack allocated parameter %1">,
  InGroup<DanglingField>;
def warn_init_ptr_member_to_parameter_addr : Warning<
  "initializing pointer member %0 with the stack address of parameter %1">,
  InGroup<DanglingField>;
def warn_bind_ref_member_to_temporary : Warning<
  "binding reference %select{|subobject of }1member %0 to a temporary value">,
  InGroup<DanglingField>;
def note_ref_or_ptr_member_declared_here : Note<
  "%select{reference|pointer}0 member declared here">;
def note_ref_subobject_of_member_declared_here : Note<
  "member with reference subobject declared here">;

// For non-floating point, expressions of the form x == x or x != x
// should result in a warning, since these always evaluate to a constant.
// Array comparisons have similar warnings
def warn_comparison_always : Warning<
  "%select{self-|array }0comparison always evaluates to %select{false|true|a constant}1">,
  InGroup<TautologicalCompare>;

def warn_stringcompare : Warning<
  "result of comparison against %select{a string literal|@encode}0 is "
  "unspecified (use strncmp instead)">,
  InGroup<DiagGroup<"string-compare">>;

def warn_identity_field_assign : Warning<
  "assigning %select{field|instance variable}0 to itself">,
  InGroup<SelfAssignmentField>;

// Type safety attributes
def err_type_tag_for_datatype_not_ice : Error<
  "'type_tag_for_datatype' attribute requires the initializer to be "
  "an %select{integer|integral}0 constant expression">;
def err_type_tag_for_datatype_too_large : Error<
  "'type_tag_for_datatype' attribute requires the initializer to be "
  "an %select{integer|integral}0 constant expression "
  "that can be represented by a 64 bit integer">;
def warn_type_tag_for_datatype_wrong_kind : Warning<
  "this type tag was not designed to be used with this function">,
  InGroup<TypeSafety>;
def warn_type_safety_type_mismatch : Warning<
  "argument type %0 doesn't match specified '%1' type tag "
  "%select{that requires %3|}2">, InGroup<TypeSafety>;
def warn_type_safety_null_pointer_required : Warning<
  "specified %0 type tag requires a null pointer">, InGroup<TypeSafety>;

// Generic selections.
def err_assoc_type_incomplete : Error<
  "type %0 in generic association incomplete">;
def err_assoc_type_nonobject : Error<
  "type %0 in generic association not an object type">;
def err_assoc_type_variably_modified : Error<
  "type %0 in generic association is a variably modified type">;
def err_assoc_compatible_types : Error<
  "type %0 in generic association compatible with previously specified type %1">;
def note_compat_assoc : Note<
  "compatible type %0 specified here">;
def err_generic_sel_no_match : Error<
  "controlling expression type %0 not compatible with any generic association type">;
def err_generic_sel_multi_match : Error<
  "controlling expression type %0 compatible with %1 generic association types">;


// Blocks
def err_blocks_disable : Error<"blocks support disabled - compile with -fblocks"
  " or pick a deployment target that supports them">;
def err_block_returning_array_function : Error<
  "block cannot return %select{array|function}0 type %1">;

// Builtin annotation
def err_builtin_annotation_first_arg : Error<
  "first argument to __builtin_annotation must be an integer">;
def err_builtin_annotation_second_arg : Error<
  "second argument to __builtin_annotation must be a non-wide string constant">;

// CFString checking
def err_cfstring_literal_not_string_constant : Error<
  "CFString literal is not a string constant">;
def warn_cfstring_truncated : Warning<
  "input conversion stopped due to an input byte that does not "
  "belong to the input codeset UTF-8">,
  InGroup<DiagGroup<"CFString-literal">>;

// Statements.
def err_continue_not_in_loop : Error<
  "'continue' statement not in loop statement">;
def err_break_not_in_loop_or_switch : Error<
  "'break' statement not in loop or switch statement">;
def err_default_not_in_switch : Error<
  "'default' statement not in switch statement">;
def err_case_not_in_switch : Error<"'case' statement not in switch statement">;
def warn_bool_switch_condition : Warning<
  "switch condition has boolean value">;
def warn_case_value_overflow : Warning<
  "overflow converting case value to switch condition type (%0 to %1)">,
  InGroup<Switch>;
def err_duplicate_case : Error<"duplicate case value '%0'">;
def err_duplicate_case_differing_expr : Error<
  "duplicate case value: '%0' and '%1' both equal '%2'">;
def warn_case_empty_range : Warning<"empty case range specified">;
def warn_missing_case_for_condition :
  Warning<"no case matching constant switch condition '%0'">;

def warn_def_missing_case1 : Warning<
  "enumeration value %0 not explicitly handled in switch">,
  InGroup<SwitchEnum>, DefaultIgnore;
def warn_def_missing_case2 : Warning<
  "enumeration values %0 and %1 not explicitly handled in switch">,
  InGroup<SwitchEnum>, DefaultIgnore;
def warn_def_missing_case3 : Warning<
  "enumeration values %0, %1, and %2 not explicitly handled in switch">,
  InGroup<SwitchEnum>, DefaultIgnore;
def warn_def_missing_cases : Warning<
  "%0 enumeration values not explicitly handled in switch: %1, %2, %3...">,
  InGroup<SwitchEnum>, DefaultIgnore;

def warn_missing_case1 : Warning<"enumeration value %0 not handled in switch">,
  InGroup<Switch>;
def warn_missing_case2 : Warning<
  "enumeration values %0 and %1 not handled in switch">,
  InGroup<Switch>;
def warn_missing_case3 : Warning<
  "enumeration values %0, %1, and %2 not handled in switch">,
  InGroup<Switch>;
def warn_missing_cases : Warning<
  "%0 enumeration values not handled in switch: %1, %2, %3...">,
  InGroup<Switch>;

def warn_unannotated_fallthrough : Warning<
  "unannotated fall-through between switch labels">,
  InGroup<ImplicitFallthrough>, DefaultIgnore;
def warn_unannotated_fallthrough_per_function : Warning<
  "unannotated fall-through between switch labels in partly-annotated "
  "function">, InGroup<ImplicitFallthroughPerFunction>, DefaultIgnore;
def note_insert_fallthrough_fixit : Note<
  "insert '%0;' to silence this warning">;
def note_insert_break_fixit : Note<
  "insert 'break;' to avoid fall-through">;
def err_fallthrough_attr_wrong_target : Error<
  "clang::fallthrough attribute is only allowed on empty statements">;
def note_fallthrough_insert_semi_fixit : Note<"did you forget ';'?">;
def err_fallthrough_attr_outside_switch : Error<
  "fallthrough annotation is outside switch statement">;
def warn_fallthrough_attr_invalid_placement : Warning<
  "fallthrough annotation does not directly precede switch label">,
  InGroup<ImplicitFallthrough>;
def warn_fallthrough_attr_unreachable : Warning<
  "fallthrough annotation in unreachable code">,
  InGroup<ImplicitFallthrough>;

def warn_unreachable_default : Warning<
  "default label in switch which covers all enumeration values">,
  InGroup<CoveredSwitchDefault>, DefaultIgnore;
def warn_not_in_enum : Warning<"case value not in enumerated type %0">,
  InGroup<Switch>;
def warn_not_in_enum_assignment : Warning<"integer constant not in range "
  "of enumerated type %0">, InGroup<DiagGroup<"assign-enum">>, DefaultIgnore;
def err_typecheck_statement_requires_scalar : Error<
  "statement requires expression of scalar type (%0 invalid)">;
def err_typecheck_statement_requires_integer : Error<
  "statement requires expression of integer type (%0 invalid)">;
def err_multiple_default_labels_defined : Error<
  "multiple default labels in one switch">;
def err_switch_multiple_conversions : Error<
  "multiple conversions from switch condition type %0 to an integral or "
  "enumeration type">;
def note_switch_conversion : Note<
  "conversion to %select{integral|enumeration}0 type %1">;
def err_switch_explicit_conversion : Error<
  "switch condition type %0 requires explicit conversion to %1">;
def err_switch_incomplete_class_type : Error<
  "switch condition has incomplete class type %0">;

def warn_empty_if_body : Warning<
  "if statement has empty body">, InGroup<EmptyBody>;
def warn_empty_for_body : Warning<
  "for loop has empty body">, InGroup<EmptyBody>;
def warn_empty_range_based_for_body : Warning<
  "range-based for loop has empty body">, InGroup<EmptyBody>;
def warn_empty_while_body : Warning<
  "while loop has empty body">, InGroup<EmptyBody>;
def warn_empty_switch_body : Warning<
  "switch statement has empty body">, InGroup<EmptyBody>;
def note_empty_body_on_separate_line : Note<
  "put the semicolon on a separate line to silence this warning">;

def err_va_start_used_in_non_variadic_function : Error<
  "'va_start' used in function with fixed args">;
def warn_second_parameter_of_va_start_not_last_named_argument : Warning<
  "second parameter of 'va_start' not last named argument">, InGroup<Varargs>;
def warn_va_start_of_reference_type_is_undefined : Warning<
  "'va_start' has undefined behavior with reference types">, InGroup<Varargs>;
def err_first_argument_to_va_arg_not_of_type_va_list : Error<
  "first argument to 'va_arg' is of type %0 and not 'va_list'">;
def err_second_parameter_to_va_arg_incomplete: Error<
  "second argument to 'va_arg' is of incomplete type %0">;
def err_second_parameter_to_va_arg_abstract: Error<
  "second argument to 'va_arg' is of abstract type %0">;
def warn_second_parameter_to_va_arg_not_pod : Warning<
  "second argument to 'va_arg' is of non-POD type %0">,
  InGroup<NonPODVarargs>, DefaultError;
def warn_second_parameter_to_va_arg_ownership_qualified : Warning<
  "second argument to 'va_arg' is of ARC ownership-qualified type %0">,
  InGroup<NonPODVarargs>, DefaultError;
def warn_second_parameter_to_va_arg_never_compatible : Warning<
  "second argument to 'va_arg' is of promotable type %0; this va_arg has "
  "undefined behavior because arguments will be promoted to %1">, InGroup<Varargs>;

def warn_return_missing_expr : Warning<
  "non-void %select{function|method}1 %0 should return a value">, DefaultError,
  InGroup<ReturnType>;
def ext_return_missing_expr : ExtWarn<
  "non-void %select{function|method}1 %0 should return a value">, DefaultError,
  InGroup<ReturnType>;
def ext_return_has_expr : ExtWarn<
  "%select{void function|void method|constructor|destructor}1 %0 "
  "should not return a value">,
  DefaultError, InGroup<ReturnType>;
def ext_return_has_void_expr : Extension<
  "void %select{function|method|block}1 %0 should not return void expression">;
def err_return_init_list : Error<
  "%select{void function|void method|constructor|destructor}1 %0 "
  "must not return a value">;
def warn_noreturn_function_has_return_expr : Warning<
  "function %0 declared 'noreturn' should not return">,
  InGroup<InvalidNoreturn>;
def warn_falloff_noreturn_function : Warning<
  "function declared 'noreturn' should not return">,
  InGroup<InvalidNoreturn>;
def err_noreturn_block_has_return_expr : Error<
  "block declared 'noreturn' should not return">;
def err_noreturn_missing_on_first_decl : Error<
  "function declared '[[noreturn]]' after its first declaration">;
def note_noreturn_missing_first_decl : Note<
  "declaration missing '[[noreturn]]' attribute is here">;
def err_carries_dependency_missing_on_first_decl : Error<
  "%select{function|parameter}0 declared '[[carries_dependency]]' "
  "after its first declaration">;
def note_carries_dependency_missing_first_decl : Note<
  "declaration missing '[[carries_dependency]]' attribute is here">;
def err_carries_dependency_param_not_function_decl : Error<
  "'[[carries_dependency]]' attribute only allowed on parameter in a function "
  "declaration or lambda">;
def err_block_on_nonlocal : Error<
  "__block attribute not allowed, only allowed on local variables">;
def err_block_on_vm : Error<
  "__block attribute not allowed on declaration with a variably modified type">;

def err_shufflevector_non_vector : Error<
  "first two arguments to __builtin_shufflevector must be vectors">;
def err_shufflevector_incompatible_vector : Error<
  "first two arguments to __builtin_shufflevector must have the same type">;
def err_shufflevector_nonconstant_argument : Error<
  "index for __builtin_shufflevector must be a constant integer">;
def err_shufflevector_argument_too_large : Error<
  "index for __builtin_shufflevector must be less than the total number "
  "of vector elements">;

def err_vector_incorrect_num_initializers : Error<
  "%select{too many|too few}0 elements in vector initialization (expected %1 elements, have %2)">;
def err_altivec_empty_initializer : Error<"expected initializer">;

def err_invalid_neon_type_code : Error<
  "incompatible constant for this __builtin_neon function">; 
def err_argument_invalid_range : Error<
  "argument should be a value from %0 to %1">;

def err_builtin_longjmp_invalid_val : Error<
  "argument to __builtin_longjmp must be a constant 1">;

def err_constant_integer_arg_type : Error<
  "argument to %0 must be a constant integer">;

def ext_mixed_decls_code : Extension<
  "ISO C90 forbids mixing declarations and code">,
  InGroup<DiagGroup<"declaration-after-statement">>;
  
def err_non_local_variable_decl_in_for : Error<
  "declaration of non-local variable in 'for' loop">;
def err_non_variable_decl_in_for : Error<
  "non-variable declaration in 'for' loop">;
def err_toomany_element_decls : Error<
  "only one element declaration is allowed">;
def err_selector_element_not_lvalue : Error<
  "selector element is not a valid lvalue">;
def err_selector_element_type : Error<
  "selector element type %0 is not a valid object">;
def err_collection_expr_type : Error<
  "the type %0 is not a pointer to a fast-enumerable object">;
def warn_collection_expr_type : Warning<
  "collection expression type %0 may not respond to %1">;

def err_invalid_conversion_between_ext_vectors : Error<
  "invalid conversion between ext-vector type %0 and %1">;

def warn_duplicate_attribute_exact : Warning<
  "attribute %0 is already applied">, InGroup<IgnoredAttributes>;

def warn_duplicate_attribute : Warning<
  "attribute %0 is already applied with different parameters">,
  InGroup<IgnoredAttributes>;

// Type
def ext_invalid_sign_spec : Extension<"'%0' cannot be signed or unsigned">;
def warn_receiver_forward_class : Warning<
    "receiver %0 is a forward class and corresponding @interface may not exist">,
    InGroup<ForwardClassReceiver>;
def note_method_sent_forward_class : Note<"method %0 is used for the forward class">;
def ext_missing_declspec : ExtWarn<
  "declaration specifier missing, defaulting to 'int'">;
def ext_missing_type_specifier : ExtWarn<
  "type specifier missing, defaults to 'int'">,
  InGroup<ImplicitInt>;
def err_decimal_unsupported : Error<
  "GNU decimal type extension not supported">;
def err_missing_type_specifier : Error<
  "C++ requires a type specifier for all declarations">;
def err_objc_array_of_interfaces : Error<
  "array of interface %0 is invalid (probably should be an array of pointers)">;
def ext_c99_array_usage : Extension<
  "%select{qualifier in |static |}0array size %select{||'[*] '}0is a C99 "
  "feature">, InGroup<C99>;
def err_c99_array_usage_cxx : Error<
  "%select{qualifier in |static |}0array size %select{||'[*] '}0is a C99 "
  "feature, not permitted in C++">;
def err_double_requires_fp64 : Error<
  "use of type 'double' requires cl_khr_fp64 extension to be enabled">;
def err_int128_unsupported : Error<
  "__int128 is not supported on this target">;
def err_nsconsumed_attribute_mismatch : Error<
  "overriding method has mismatched ns_consumed attribute on its"
  " parameter">;
def err_nsreturns_retained_attribute_mismatch : Error<
  "overriding method has mismatched ns_returns_%select{not_retained|retained}0"
  " attributes">;
  
def note_getter_unavailable : Note<
  "or because setter is declared here, but no getter method %0 is found">;
def err_invalid_protocol_qualifiers : Error<
  "invalid protocol qualifiers on non-ObjC type">;
def warn_ivar_use_hidden : Warning<
  "local declaration of %0 hides instance variable">,
   InGroup<DiagGroup<"shadow-ivar">>;
def error_ivar_use_in_class_method : Error<
  "instance variable %0 accessed in class method">;
def error_implicit_ivar_access : Error<
  "instance variable %0 cannot be accessed because 'self' has been redeclared">;
def error_private_ivar_access : Error<"instance variable %0 is private">,
  AccessControl;
def error_protected_ivar_access : Error<"instance variable %0 is protected">,
  AccessControl;
def warn_maynot_respond : Warning<"%0 may not respond to %1">;
def warn_attribute_method_def : Warning<
  "attributes on method implementation and its declaration must match">,
  InGroup<DiagGroup<"mismatched-method-attributes">>;
def ext_typecheck_base_super : Warning<
  "method parameter type "
  "%diff{$ does not match super class method parameter type $|"
  "does not match super class method parameter type}0,1">,
   InGroup<SuperSubClassMismatch>, DefaultIgnore;
def warn_missing_method_return_type : Warning<
  "method has no return type specified; defaults to 'id'">,
  InGroup<MissingMethodReturnType>, DefaultIgnore;
def warn_direct_ivar_access : Warning<"instance variable %0 is being "
  "directly accessed">, InGroup<DiagGroup<"direct-ivar-access">>, DefaultIgnore;

// Spell-checking diagnostics
def err_unknown_type_or_class_name_suggest : Error<
  "unknown %select{type|class}2 name %0; did you mean %1?">;
def err_unknown_typename_suggest : Error<
  "unknown type name %0; did you mean %1?">;
def err_unknown_nested_typename_suggest : Error<
  "no type named %0 in %1; did you mean %2?">;
def err_no_member_suggest : Error<"no member named %0 in %1; did you mean %2?">;
def err_undeclared_use_suggest : Error<
  "use of undeclared %0; did you mean %1?">;
def err_undeclared_var_use_suggest : Error<
  "use of undeclared identifier %0; did you mean %1?">;
def err_no_template_suggest : Error<"no template named %0; did you mean %1?">;
def err_no_member_template_suggest : Error<
  "no template named %0 in %1; did you mean %2?">;
def err_mem_init_not_member_or_class_suggest : Error<
  "initializer %0 does not name a non-static data member or base "
  "class; did you mean the %select{base class|member}1 %2?">;
def err_field_designator_unknown_suggest : Error<
  "field designator %0 does not refer to any field in type %1; did you mean "
  "%2?">;
def err_typecheck_member_reference_ivar_suggest : Error<
  "%0 does not have a member named %1; did you mean %2?">;
def err_property_not_found_suggest : Error<
  "property %0 not found on object of type %1; did you mean %2?">;
def err_ivar_access_using_property_syntax_suggest : Error<
  "property %0 not found on object of type %1; did you mean to access instance variable %2?">;
def err_property_found_suggest : Error<
  "property %0 found on object of type %1; did you mean to access "
  "it with the \".\" operator?">;
def err_undef_interface_suggest : Error<
  "cannot find interface declaration for %0; did you mean %1?">;
def warn_undef_interface_suggest : Warning<
  "cannot find interface declaration for %0; did you mean %1?">;
def err_undef_superclass_suggest : Error<
  "cannot find interface declaration for %0, superclass of %1; did you mean "
  "%2?">;
def err_undeclared_protocol_suggest : Error<
  "cannot find protocol declaration for %0; did you mean %1?">;
def note_base_class_specified_here : Note<
  "base class %0 specified here">;
def err_using_directive_suggest : Error<
  "no namespace named %0; did you mean %1?">;
def err_using_directive_member_suggest : Error<
  "no namespace named %0 in %1; did you mean %2?">;
def note_namespace_defined_here : Note<"namespace %0 defined here">;
def err_sizeof_pack_no_pack_name_suggest : Error<
  "%0 does not refer to the name of a parameter pack; did you mean %1?">;
def note_parameter_pack_here : Note<"parameter pack %0 declared here">;

def err_uncasted_use_of_unknown_any : Error<
  "%0 has unknown type; cast it to its declared type to use it">;
def err_uncasted_call_of_unknown_any : Error<
  "%0 has unknown return type; cast the call to its declared return type">;
def err_uncasted_send_to_unknown_any_method : Error<
  "no known method %select{%objcinstance1|%objcclass1}0; cast the "
  "message send to the method's return type">;
def err_unsupported_unknown_any_decl : Error<
  "%0 has unknown type, which is unsupported for this kind of declaration">;
def err_unsupported_unknown_any_expr : Error<
  "unsupported expression with unknown type">;
def err_unsupported_unknown_any_call : Error<
  "call to unsupported expression with unknown type">;
def err_unknown_any_addrof : Error<
  "the address of a declaration with unknown type "
  "can only be cast to a pointer type">;
def err_unknown_any_var_function_type : Error<
  "variable %0 with unknown type cannot be given a function type">;
def err_unknown_any_function : Error<
  "function %0 with unknown type must be given a function type">;

def err_filter_expression_integral : Error<
  "filter expression type should be an integral value not %0">;

// OpenCL warnings and errors.
def err_invalid_astype_of_different_size : Error<
  "invalid reinterpretation: sizes of %0 and %1 must match">;
def err_static_kernel : Error<
  "kernel functions cannot be declared static">;
def err_opencl_ptrptr_kernel_arg : Error<
  "kernel argument cannot be declared as a pointer to a pointer">;
def err_static_function_scope : Error<
  "variables in function scope cannot be declared static">;
def err_opencl_bitfields : Error<
  "bitfields are not supported in OpenCL">;
def err_opencl_vla : Error<
  "variable length arrays are not supported in OpenCL">;
def err_event_t_kernel_arg : Error<
  "the event_t type cannot be used to declare a kernel function argument">;
def err_event_t_global_var : Error<
  "the event_t type cannot be used to declare a program scope variable">;
def err_event_t_struct_field : Error<
  "the event_t type cannot be used to declare a structure or union field">;
def err_event_t_addr_space_qual : Error<
  "the event_t type can only be used with __private address space qualifier">;
def err_expected_kernel_void_return_type : Error<
  "kernel must have void return type">;
def err_sampler_argument_required : Error<
  "sampler_t variable required - got %0">;
def err_wrong_sampler_addressspace: Error<
  "sampler type cannot be used with the __local and __global address space qualifiers">;
def err_opencl_global_invalid_addr_space : Error<
  "global variables must have a constant address space qualifier">;

} // end of sema category

let CategoryName = "OpenMP Issue" in {
// OpenMP support.
def err_omp_expected_var_arg_suggest : Error<
  "%0 is not a global variable, static local variable or static data member%select{|; did you mean %2?}1">;
def err_omp_global_var_arg : Error<
  "arguments of '#pragma omp %0' must have %select{global storage|static storage duration}1">;
def err_omp_ref_type_arg : Error<
  "arguments of '#pragma omp %0' cannot be of reference type">;
def err_omp_var_scope : Error<
  "'#pragma omp %0' must appear in the scope of the %q1 variable declaration">;
def err_omp_var_used : Error<
  "'#pragma omp %0' must precede all references to variable %q1">;
def err_omp_var_thread_local : Error<
  "variable %0 cannot be threadprivate because it is thread-local">;
def err_omp_threadprivate_incomplete_type : Error<
  "threadprivate variable with incomplete type %0">;
} // end of OpenMP category

let CategoryName = "Related Result Type Issue" in {
// Objective-C related result type compatibility
def warn_related_result_type_compatibility_class : Warning<
  "method is expected to return an instance of its class type "
  "%diff{$, but is declared to return $|"
  ", but is declared to return different type}0,1">;
def warn_related_result_type_compatibility_protocol : Warning<
  "protocol method is expected to return an instance of the implementing "
  "class, but is declared to return %0">;
def note_related_result_type_family : Note<
  "%select{overridden|current}0 method is part of the '%select{|alloc|copy|init|"
  "mutableCopy|new|autorelease|dealloc|finalize|release|retain|retainCount|"
  "self}1' method family%select{| and is expected to return an instance of its "
  "class type}0">;
def note_related_result_type_overridden : Note<
  "overridden method returns an instance of its class type">;
def note_related_result_type_inferred : Note<
  "%select{class|instance}0 method %1 is assumed to return an instance of "
  "its receiver type (%2)">;
def note_related_result_type_explicit : Note<
  "%select{overridden|current}0 method is explicitly declared 'instancetype'"
  "%select{| and is expected to return an instance of its class type}0">;

}

let CategoryName = "Modules Issue" in {
def err_module_private_specialization : Error<
  "%select{template|partial|member}0 specialization cannot be "
  "declared __module_private__">;
def err_module_private_local : Error<
  "%select{local variable|parameter|typedef}0 %1 cannot be declared "
  "__module_private__">;
def err_module_private_local_class : Error<
  "local %select{struct|interface|union|class|enum}0 cannot be declared "
  "__module_private__">;
def err_module_private_definition : Error<
  "definition of %0 must be imported from module '%1' before it is required">;
}

let CategoryName = "Documentation Issue" in {
def warn_not_a_doxygen_trailing_member_comment : Warning<
  "not a Doxygen trailing comment">, InGroup<Documentation>, DefaultIgnore;
} // end of documentation issue category

} // end of sema component.
//===-- X86InstrSSE.td - SSE Instruction Set ---------------*- tablegen -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file describes the X86 SSE instruction set, defining the instructions,
// and properties of the instructions which are needed for code generation,
// machine code emission, and analysis.
//
//===----------------------------------------------------------------------===//

class OpndItins<InstrItinClass arg_rr, InstrItinClass arg_rm> {
  InstrItinClass rr = arg_rr;
  InstrItinClass rm = arg_rm;
  // InstrSchedModel info.
  X86FoldableSchedWrite Sched = WriteFAdd;
}

class SizeItins<OpndItins arg_s, OpndItins arg_d> {
  OpndItins s = arg_s;
  OpndItins d = arg_d;
}


class ShiftOpndItins<InstrItinClass arg_rr, InstrItinClass arg_rm,
  InstrItinClass arg_ri> {
  InstrItinClass rr = arg_rr;
  InstrItinClass rm = arg_rm;
  InstrItinClass ri = arg_ri;
}


// scalar
let Sched = WriteFAdd in {
def SSE_ALU_F32S : OpndItins<
  IIC_SSE_ALU_F32S_RR, IIC_SSE_ALU_F32S_RM
>;

def SSE_ALU_F64S : OpndItins<
  IIC_SSE_ALU_F64S_RR, IIC_SSE_ALU_F64S_RM
>;
}

def SSE_ALU_ITINS_S : SizeItins<
  SSE_ALU_F32S, SSE_ALU_F64S
>;

let Sched = WriteFMul in {
def SSE_MUL_F32S : OpndItins<
  IIC_SSE_MUL_F32S_RR, IIC_SSE_MUL_F64S_RM
>;

def SSE_MUL_F64S : OpndItins<
  IIC_SSE_MUL_F64S_RR, IIC_SSE_MUL_F64S_RM
>;
}

def SSE_MUL_ITINS_S : SizeItins<
  SSE_MUL_F32S, SSE_MUL_F64S
>;

let Sched = WriteFDiv in {
def SSE_DIV_F32S : OpndItins<
  IIC_SSE_DIV_F32S_RR, IIC_SSE_DIV_F64S_RM
>;

def SSE_DIV_F64S : OpndItins<
  IIC_SSE_DIV_F64S_RR, IIC_SSE_DIV_F64S_RM
>;
}

def SSE_DIV_ITINS_S : SizeItins<
  SSE_DIV_F32S, SSE_DIV_F64S
>;

// parallel
let Sched = WriteFAdd in {
def SSE_ALU_F32P : OpndItins<
  IIC_SSE_ALU_F32P_RR, IIC_SSE_ALU_F32P_RM
>;

def SSE_ALU_F64P : OpndItins<
  IIC_SSE_ALU_F64P_RR, IIC_SSE_ALU_F64P_RM
>;
}

def SSE_ALU_ITINS_P : SizeItins<
  SSE_ALU_F32P, SSE_ALU_F64P
>;

let Sched = WriteFMul in {
def SSE_MUL_F32P : OpndItins<
  IIC_SSE_MUL_F32P_RR, IIC_SSE_MUL_F64P_RM
>;

def SSE_MUL_F64P : OpndItins<
  IIC_SSE_MUL_F64P_RR, IIC_SSE_MUL_F64P_RM
>;
}

def SSE_MUL_ITINS_P : SizeItins<
  SSE_MUL_F32P, SSE_MUL_F64P
>;

let Sched = WriteFDiv in {
def SSE_DIV_F32P : OpndItins<
  IIC_SSE_DIV_F32P_RR, IIC_SSE_DIV_F64P_RM
>;

def SSE_DIV_F64P : OpndItins<
  IIC_SSE_DIV_F64P_RR, IIC_SSE_DIV_F64P_RM
>;
}

def SSE_DIV_ITINS_P : SizeItins<
  SSE_DIV_F32P, SSE_DIV_F64P
>;

def SSE_BIT_ITINS_P : OpndItins<
  IIC_SSE_BIT_P_RR, IIC_SSE_BIT_P_RM
>;

let Sched = WriteVecALU in {
def SSE_INTALU_ITINS_P : OpndItins<
  IIC_SSE_INTALU_P_RR, IIC_SSE_INTALU_P_RM
>;

def SSE_INTALUQ_ITINS_P : OpndItins<
  IIC_SSE_INTALUQ_P_RR, IIC_SSE_INTALUQ_P_RM
>;
}

let Sched = WriteVecIMul in
def SSE_INTMUL_ITINS_P : OpndItins<
  IIC_SSE_INTMUL_P_RR, IIC_SSE_INTMUL_P_RM
>;

def SSE_INTSHIFT_ITINS_P : ShiftOpndItins<
  IIC_SSE_INTSH_P_RR, IIC_SSE_INTSH_P_RM, IIC_SSE_INTSH_P_RI
>;

def SSE_MOVA_ITINS : OpndItins<
  IIC_SSE_MOVA_P_RR, IIC_SSE_MOVA_P_RM
>;

def SSE_MOVU_ITINS : OpndItins<
  IIC_SSE_MOVU_P_RR, IIC_SSE_MOVU_P_RM
>;

//===----------------------------------------------------------------------===//
// SSE 1 & 2 Instructions Classes
//===----------------------------------------------------------------------===//

/// sse12_fp_scalar - SSE 1 & 2 scalar instructions class
multiclass sse12_fp_scalar<bits<8> opc, string OpcodeStr, SDNode OpNode,
                           RegisterClass RC, X86MemOperand x86memop,
                           OpndItins itins,
                           bit Is2Addr = 1> {
  let isCommutable = 1 in {
    def rr : SI<opc, MRMSrcReg, (outs RC:$dst), (ins RC:$src1, RC:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (OpNode RC:$src1, RC:$src2))], itins.rr>,
       Sched<[itins.Sched]>;
  }
  def rm : SI<opc, MRMSrcMem, (outs RC:$dst), (ins RC:$src1, x86memop:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (OpNode RC:$src1, (load addr:$src2)))], itins.rm>,
       Sched<[itins.Sched.Folded, ReadAfterLd]>;
}

/// sse12_fp_scalar_int - SSE 1 & 2 scalar instructions intrinsics class
multiclass sse12_fp_scalar_int<bits<8> opc, string OpcodeStr, RegisterClass RC,
                             string asm, string SSEVer, string FPSizeStr,
                             Operand memopr, ComplexPattern mem_cpat,
                             OpndItins itins,
                             bit Is2Addr = 1> {
  def rr_Int : SI<opc, MRMSrcReg, (outs RC:$dst), (ins RC:$src1, RC:$src2),
       !if(Is2Addr,
           !strconcat(asm, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(asm, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (!cast<Intrinsic>(
                 !strconcat("int_x86_sse", SSEVer, "_", OpcodeStr, FPSizeStr))
             RC:$src1, RC:$src2))], itins.rr>,
       Sched<[itins.Sched]>;
  def rm_Int : SI<opc, MRMSrcMem, (outs RC:$dst), (ins RC:$src1, memopr:$src2),
       !if(Is2Addr,
           !strconcat(asm, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(asm, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (!cast<Intrinsic>(!strconcat("int_x86_sse",
                                          SSEVer, "_", OpcodeStr, FPSizeStr))
             RC:$src1, mem_cpat:$src2))], itins.rm>,
       Sched<[itins.Sched.Folded, ReadAfterLd]>;
}

/// sse12_fp_packed - SSE 1 & 2 packed instructions class
multiclass sse12_fp_packed<bits<8> opc, string OpcodeStr, SDNode OpNode,
                           RegisterClass RC, ValueType vt,
                           X86MemOperand x86memop, PatFrag mem_frag,
                           Domain d, OpndItins itins, bit Is2Addr = 1> {
  let isCommutable = 1 in
    def rr : PI<opc, MRMSrcReg, (outs RC:$dst), (ins RC:$src1, RC:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (vt (OpNode RC:$src1, RC:$src2)))], itins.rr, d>,
       Sched<[itins.Sched]>;
  let mayLoad = 1 in
    def rm : PI<opc, MRMSrcMem, (outs RC:$dst), (ins RC:$src1, x86memop:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (OpNode RC:$src1, (mem_frag addr:$src2)))],
          itins.rm, d>,
       Sched<[itins.Sched.Folded, ReadAfterLd]>;
}

/// sse12_fp_packed_logical_rm - SSE 1 & 2 packed instructions class
multiclass sse12_fp_packed_logical_rm<bits<8> opc, RegisterClass RC, Domain d,
                                      string OpcodeStr, X86MemOperand x86memop,
                                      list<dag> pat_rr, list<dag> pat_rm,
                                      bit Is2Addr = 1> {
  let isCommutable = 1, hasSideEffects = 0 in
    def rr : PI<opc, MRMSrcReg, (outs RC:$dst), (ins RC:$src1, RC:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       pat_rr, NoItinerary, d>,
       Sched<[WriteVecLogic]>;
  def rm : PI<opc, MRMSrcMem, (outs RC:$dst), (ins RC:$src1, x86memop:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       pat_rm, NoItinerary, d>,
       Sched<[WriteVecLogicLd, ReadAfterLd]>;
}

//===----------------------------------------------------------------------===//
//  Non-instruction patterns
//===----------------------------------------------------------------------===//

// A vector extract of the first f32/f64 position is a subregister copy
def : Pat<(f32 (vector_extract (v4f32 VR128:$src), (iPTR 0))),
          (COPY_TO_REGCLASS (v4f32 VR128:$src), FR32)>;
def : Pat<(f64 (vector_extract (v2f64 VR128:$src), (iPTR 0))),
          (COPY_TO_REGCLASS (v2f64 VR128:$src), FR64)>;

// A 128-bit subvector extract from the first 256-bit vector position
// is a subregister copy that needs no instruction.
def : Pat<(v4i32 (extract_subvector (v8i32 VR256:$src), (iPTR 0))),
          (v4i32 (EXTRACT_SUBREG (v8i32 VR256:$src), sub_xmm))>;
def : Pat<(v4f32 (extract_subvector (v8f32 VR256:$src), (iPTR 0))),
          (v4f32 (EXTRACT_SUBREG (v8f32 VR256:$src), sub_xmm))>;

def : Pat<(v2i64 (extract_subvector (v4i64 VR256:$src), (iPTR 0))),
          (v2i64 (EXTRACT_SUBREG (v4i64 VR256:$src), sub_xmm))>;
def : Pat<(v2f64 (extract_subvector (v4f64 VR256:$src), (iPTR 0))),
          (v2f64 (EXTRACT_SUBREG (v4f64 VR256:$src), sub_xmm))>;

def : Pat<(v8i16 (extract_subvector (v16i16 VR256:$src), (iPTR 0))),
          (v8i16 (EXTRACT_SUBREG (v16i16 VR256:$src), sub_xmm))>;
def : Pat<(v16i8 (extract_subvector (v32i8 VR256:$src), (iPTR 0))),
          (v16i8 (EXTRACT_SUBREG (v32i8 VR256:$src), sub_xmm))>;

// A 128-bit subvector insert to the first 256-bit vector position
// is a subregister copy that needs no instruction.
let AddedComplexity = 25 in { // to give priority over vinsertf128rm
def : Pat<(insert_subvector undef, (v2i64 VR128:$src), (iPTR 0)),
          (INSERT_SUBREG (v4i64 (IMPLICIT_DEF)), VR128:$src, sub_xmm)>;
def : Pat<(insert_subvector undef, (v2f64 VR128:$src), (iPTR 0)),
          (INSERT_SUBREG (v4f64 (IMPLICIT_DEF)), VR128:$src, sub_xmm)>;
def : Pat<(insert_subvector undef, (v4i32 VR128:$src), (iPTR 0)),
          (INSERT_SUBREG (v8i32 (IMPLICIT_DEF)), VR128:$src, sub_xmm)>;
def : Pat<(insert_subvector undef, (v4f32 VR128:$src), (iPTR 0)),
          (INSERT_SUBREG (v8f32 (IMPLICIT_DEF)), VR128:$src, sub_xmm)>;
def : Pat<(insert_subvector undef, (v8i16 VR128:$src), (iPTR 0)),
          (INSERT_SUBREG (v16i16 (IMPLICIT_DEF)), VR128:$src, sub_xmm)>;
def : Pat<(insert_subvector undef, (v16i8 VR128:$src), (iPTR 0)),
          (INSERT_SUBREG (v32i8 (IMPLICIT_DEF)), VR128:$src, sub_xmm)>;
}

// Implicitly promote a 32-bit scalar to a vector.
def : Pat<(v4f32 (scalar_to_vector FR32:$src)),
          (COPY_TO_REGCLASS FR32:$src, VR128)>;
def : Pat<(v8f32 (scalar_to_vector FR32:$src)),
          (COPY_TO_REGCLASS FR32:$src, VR128)>;
// Implicitly promote a 64-bit scalar to a vector.
def : Pat<(v2f64 (scalar_to_vector FR64:$src)),
          (COPY_TO_REGCLASS FR64:$src, VR128)>;
def : Pat<(v4f64 (scalar_to_vector FR64:$src)),
          (COPY_TO_REGCLASS FR64:$src, VR128)>;

// Bitcasts between 128-bit vector types. Return the original type since
// no instruction is needed for the conversion
let Predicates = [HasSSE2] in {
  def : Pat<(v2i64 (bitconvert (v4i32 VR128:$src))), (v2i64 VR128:$src)>;
  def : Pat<(v2i64 (bitconvert (v8i16 VR128:$src))), (v2i64 VR128:$src)>;
  def : Pat<(v2i64 (bitconvert (v16i8 VR128:$src))), (v2i64 VR128:$src)>;
  def : Pat<(v2i64 (bitconvert (v2f64 VR128:$src))), (v2i64 VR128:$src)>;
  def : Pat<(v2i64 (bitconvert (v4f32 VR128:$src))), (v2i64 VR128:$src)>;
  def : Pat<(v4i32 (bitconvert (v2i64 VR128:$src))), (v4i32 VR128:$src)>;
  def : Pat<(v4i32 (bitconvert (v8i16 VR128:$src))), (v4i32 VR128:$src)>;
  def : Pat<(v4i32 (bitconvert (v16i8 VR128:$src))), (v4i32 VR128:$src)>;
  def : Pat<(v4i32 (bitconvert (v2f64 VR128:$src))), (v4i32 VR128:$src)>;
  def : Pat<(v4i32 (bitconvert (v4f32 VR128:$src))), (v4i32 VR128:$src)>;
  def : Pat<(v8i16 (bitconvert (v2i64 VR128:$src))), (v8i16 VR128:$src)>;
  def : Pat<(v8i16 (bitconvert (v4i32 VR128:$src))), (v8i16 VR128:$src)>;
  def : Pat<(v8i16 (bitconvert (v16i8 VR128:$src))), (v8i16 VR128:$src)>;
  def : Pat<(v8i16 (bitconvert (v2f64 VR128:$src))), (v8i16 VR128:$src)>;
  def : Pat<(v8i16 (bitconvert (v4f32 VR128:$src))), (v8i16 VR128:$src)>;
  def : Pat<(v16i8 (bitconvert (v2i64 VR128:$src))), (v16i8 VR128:$src)>;
  def : Pat<(v16i8 (bitconvert (v4i32 VR128:$src))), (v16i8 VR128:$src)>;
  def : Pat<(v16i8 (bitconvert (v8i16 VR128:$src))), (v16i8 VR128:$src)>;
  def : Pat<(v16i8 (bitconvert (v2f64 VR128:$src))), (v16i8 VR128:$src)>;
  def : Pat<(v16i8 (bitconvert (v4f32 VR128:$src))), (v16i8 VR128:$src)>;
  def : Pat<(v4f32 (bitconvert (v2i64 VR128:$src))), (v4f32 VR128:$src)>;
  def : Pat<(v4f32 (bitconvert (v4i32 VR128:$src))), (v4f32 VR128:$src)>;
  def : Pat<(v4f32 (bitconvert (v8i16 VR128:$src))), (v4f32 VR128:$src)>;
  def : Pat<(v4f32 (bitconvert (v16i8 VR128:$src))), (v4f32 VR128:$src)>;
  def : Pat<(v4f32 (bitconvert (v2f64 VR128:$src))), (v4f32 VR128:$src)>;
  def : Pat<(v2f64 (bitconvert (v2i64 VR128:$src))), (v2f64 VR128:$src)>;
  def : Pat<(v2f64 (bitconvert (v4i32 VR128:$src))), (v2f64 VR128:$src)>;
  def : Pat<(v2f64 (bitconvert (v8i16 VR128:$src))), (v2f64 VR128:$src)>;
  def : Pat<(v2f64 (bitconvert (v16i8 VR128:$src))), (v2f64 VR128:$src)>;
  def : Pat<(v2f64 (bitconvert (v4f32 VR128:$src))), (v2f64 VR128:$src)>;
}

// Bitcasts between 256-bit vector types. Return the original type since
// no instruction is needed for the conversion
let Predicates = [HasAVX] in {
  def : Pat<(v4f64  (bitconvert (v8f32 VR256:$src))),  (v4f64 VR256:$src)>;
  def : Pat<(v4f64  (bitconvert (v8i32 VR256:$src))),  (v4f64 VR256:$src)>;
  def : Pat<(v4f64  (bitconvert (v4i64 VR256:$src))),  (v4f64 VR256:$src)>;
  def : Pat<(v4f64  (bitconvert (v16i16 VR256:$src))), (v4f64 VR256:$src)>;
  def : Pat<(v4f64  (bitconvert (v32i8 VR256:$src))),  (v4f64 VR256:$src)>;
  def : Pat<(v8f32  (bitconvert (v8i32 VR256:$src))),  (v8f32 VR256:$src)>;
  def : Pat<(v8f32  (bitconvert (v4i64 VR256:$src))),  (v8f32 VR256:$src)>;
  def : Pat<(v8f32  (bitconvert (v4f64 VR256:$src))),  (v8f32 VR256:$src)>;
  def : Pat<(v8f32  (bitconvert (v32i8 VR256:$src))),  (v8f32 VR256:$src)>;
  def : Pat<(v8f32  (bitconvert (v16i16 VR256:$src))), (v8f32 VR256:$src)>;
  def : Pat<(v4i64  (bitconvert (v8f32 VR256:$src))),  (v4i64 VR256:$src)>;
  def : Pat<(v4i64  (bitconvert (v8i32 VR256:$src))),  (v4i64 VR256:$src)>;
  def : Pat<(v4i64  (bitconvert (v4f64 VR256:$src))),  (v4i64 VR256:$src)>;
  def : Pat<(v4i64  (bitconvert (v32i8 VR256:$src))),  (v4i64 VR256:$src)>;
  def : Pat<(v4i64  (bitconvert (v16i16 VR256:$src))), (v4i64 VR256:$src)>;
  def : Pat<(v32i8  (bitconvert (v4f64 VR256:$src))),  (v32i8 VR256:$src)>;
  def : Pat<(v32i8  (bitconvert (v4i64 VR256:$src))),  (v32i8 VR256:$src)>;
  def : Pat<(v32i8  (bitconvert (v8f32 VR256:$src))),  (v32i8 VR256:$src)>;
  def : Pat<(v32i8  (bitconvert (v8i32 VR256:$src))),  (v32i8 VR256:$src)>;
  def : Pat<(v32i8  (bitconvert (v16i16 VR256:$src))), (v32i8 VR256:$src)>;
  def : Pat<(v8i32  (bitconvert (v32i8 VR256:$src))),  (v8i32 VR256:$src)>;
  def : Pat<(v8i32  (bitconvert (v16i16 VR256:$src))), (v8i32 VR256:$src)>;
  def : Pat<(v8i32  (bitconvert (v8f32 VR256:$src))),  (v8i32 VR256:$src)>;
  def : Pat<(v8i32  (bitconvert (v4i64 VR256:$src))),  (v8i32 VR256:$src)>;
  def : Pat<(v8i32  (bitconvert (v4f64 VR256:$src))),  (v8i32 VR256:$src)>;
  def : Pat<(v16i16 (bitconvert (v8f32 VR256:$src))),  (v16i16 VR256:$src)>;
  def : Pat<(v16i16 (bitconvert (v8i32 VR256:$src))),  (v16i16 VR256:$src)>;
  def : Pat<(v16i16 (bitconvert (v4i64 VR256:$src))),  (v16i16 VR256:$src)>;
  def : Pat<(v16i16 (bitconvert (v4f64 VR256:$src))),  (v16i16 VR256:$src)>;
  def : Pat<(v16i16 (bitconvert (v32i8 VR256:$src))),  (v16i16 VR256:$src)>;
}

// Alias instructions that map fld0 to xorps for sse or vxorps for avx.
// This is expanded by ExpandPostRAPseudos.
let isReMaterializable = 1, isAsCheapAsAMove = 1, canFoldAsLoad = 1,
    isPseudo = 1, SchedRW = [WriteZero] in {
  def FsFLD0SS : I<0, Pseudo, (outs FR32:$dst), (ins), "",
                   [(set FR32:$dst, fp32imm0)]>, Requires<[HasSSE1]>;
  def FsFLD0SD : I<0, Pseudo, (outs FR64:$dst), (ins), "",
                   [(set FR64:$dst, fpimm0)]>, Requires<[HasSSE2]>;
}

//===----------------------------------------------------------------------===//
// AVX & SSE - Zero/One Vectors
//===----------------------------------------------------------------------===//

// Alias instruction that maps zero vector to pxor / xorp* for sse.
// This is expanded by ExpandPostRAPseudos to an xorps / vxorps, and then
// swizzled by ExecutionDepsFix to pxor.
// We set canFoldAsLoad because this can be converted to a constant-pool
// load of an all-zeros value if folding it would be beneficial.
let isReMaterializable = 1, isAsCheapAsAMove = 1, canFoldAsLoad = 1,
    isPseudo = 1, SchedRW = [WriteZero] in {
def V_SET0 : I<0, Pseudo, (outs VR128:$dst), (ins), "",
               [(set VR128:$dst, (v4f32 immAllZerosV))]>;
}

def : Pat<(v2f64 immAllZerosV), (V_SET0)>;
def : Pat<(v4i32 immAllZerosV), (V_SET0)>;
def : Pat<(v2i64 immAllZerosV), (V_SET0)>;
def : Pat<(v8i16 immAllZerosV), (V_SET0)>;
def : Pat<(v16i8 immAllZerosV), (V_SET0)>;


// The same as done above but for AVX.  The 256-bit AVX1 ISA doesn't support PI,
// and doesn't need it because on sandy bridge the register is set to zero
// at the rename stage without using any execution unit, so SET0PSY
// and SET0PDY can be used for vector int instructions without penalty
let isReMaterializable = 1, isAsCheapAsAMove = 1, canFoldAsLoad = 1,
    isPseudo = 1, Predicates = [HasAVX], SchedRW = [WriteZero] in {
def AVX_SET0 : I<0, Pseudo, (outs VR256:$dst), (ins), "",
                 [(set VR256:$dst, (v8f32 immAllZerosV))]>;
}

let Predicates = [HasAVX] in
  def : Pat<(v4f64 immAllZerosV), (AVX_SET0)>;

let Predicates = [HasAVX2] in {
  def : Pat<(v4i64 immAllZerosV), (AVX_SET0)>;
  def : Pat<(v8i32 immAllZerosV), (AVX_SET0)>;
  def : Pat<(v16i16 immAllZerosV), (AVX_SET0)>;
  def : Pat<(v32i8 immAllZerosV), (AVX_SET0)>;
}

// AVX1 has no support for 256-bit integer instructions, but since the 128-bit
// VPXOR instruction writes zero to its upper part, it's safe build zeros.
let Predicates = [HasAVX1Only] in {
def : Pat<(v32i8 immAllZerosV), (SUBREG_TO_REG (i8 0), (V_SET0), sub_xmm)>;
def : Pat<(bc_v32i8 (v8f32 immAllZerosV)),
          (SUBREG_TO_REG (i8 0), (V_SET0), sub_xmm)>;

def : Pat<(v16i16 immAllZerosV), (SUBREG_TO_REG (i16 0), (V_SET0), sub_xmm)>;
def : Pat<(bc_v16i16 (v8f32 immAllZerosV)),
          (SUBREG_TO_REG (i16 0), (V_SET0), sub_xmm)>;

def : Pat<(v8i32 immAllZerosV), (SUBREG_TO_REG (i32 0), (V_SET0), sub_xmm)>;
def : Pat<(bc_v8i32 (v8f32 immAllZerosV)),
          (SUBREG_TO_REG (i32 0), (V_SET0), sub_xmm)>;

def : Pat<(v4i64 immAllZerosV), (SUBREG_TO_REG (i64 0), (V_SET0), sub_xmm)>;
def : Pat<(bc_v4i64 (v8f32 immAllZerosV)),
          (SUBREG_TO_REG (i64 0), (V_SET0), sub_xmm)>;
}

// We set canFoldAsLoad because this can be converted to a constant-pool
// load of an all-ones value if folding it would be beneficial.
let isReMaterializable = 1, isAsCheapAsAMove = 1, canFoldAsLoad = 1,
    isPseudo = 1, SchedRW = [WriteZero] in {
  def V_SETALLONES : I<0, Pseudo, (outs VR128:$dst), (ins), "",
                       [(set VR128:$dst, (v4i32 immAllOnesV))]>;
  let Predicates = [HasAVX2] in
  def AVX2_SETALLONES : I<0, Pseudo, (outs VR256:$dst), (ins), "",
                          [(set VR256:$dst, (v8i32 immAllOnesV))]>;
}


//===----------------------------------------------------------------------===//
// SSE 1 & 2 - Move FP Scalar Instructions
//
// Move Instructions. Register-to-register movss/movsd is not used for FR32/64
// register copies because it's a partial register update; FsMOVAPSrr/FsMOVAPDrr
// is used instead. Register-to-register movss/movsd is not modeled as an
// INSERT_SUBREG because INSERT_SUBREG requires that the insert be implementable
// in terms of a copy, and just mentioned, we don't use movss/movsd for copies.
//===----------------------------------------------------------------------===//

multiclass sse12_move_rr<RegisterClass RC, SDNode OpNode, ValueType vt,
                         X86MemOperand x86memop, string base_opc,
                         string asm_opr> {
  def rr : SI<0x10, MRMSrcReg, (outs VR128:$dst),
              (ins VR128:$src1, RC:$src2),
              !strconcat(base_opc, asm_opr),
              [(set VR128:$dst, (vt (OpNode VR128:$src1,
                                 (scalar_to_vector RC:$src2))))],
              IIC_SSE_MOV_S_RR>, Sched<[WriteMove]>;

  // For the disassembler
  let isCodeGenOnly = 1, hasSideEffects = 0 in
  def rr_REV : SI<0x11, MRMDestReg, (outs VR128:$dst),
                  (ins VR128:$src1, RC:$src2),
                  !strconcat(base_opc, asm_opr),
                  [], IIC_SSE_MOV_S_RR>, Sched<[WriteMove]>;
}

multiclass sse12_move<RegisterClass RC, SDNode OpNode, ValueType vt,
                      X86MemOperand x86memop, string OpcodeStr> {
  // AVX
  defm V#NAME : sse12_move_rr<RC, OpNode, vt, x86memop, OpcodeStr,
                              "\t{$src2, $src1, $dst|$dst, $src1, $src2}">,
                              VEX_4V, VEX_LIG;

  def V#NAME#mr : SI<0x11, MRMDestMem, (outs), (ins x86memop:$dst, RC:$src),
                     !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                     [(store RC:$src, addr:$dst)], IIC_SSE_MOV_S_MR>,
                     VEX, VEX_LIG, Sched<[WriteStore]>;
  // SSE1 & 2
  let Constraints = "$src1 = $dst" in {
    defm NAME : sse12_move_rr<RC, OpNode, vt, x86memop, OpcodeStr,
                              "\t{$src2, $dst|$dst, $src2}">;
  }

  def NAME#mr   : SI<0x11, MRMDestMem, (outs), (ins x86memop:$dst, RC:$src),
                     !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                     [(store RC:$src, addr:$dst)], IIC_SSE_MOV_S_MR>,
                  Sched<[WriteStore]>;
}

// Loading from memory automatically zeroing upper bits.
multiclass sse12_move_rm<RegisterClass RC, X86MemOperand x86memop,
                         PatFrag mem_pat, string OpcodeStr> {
  def V#NAME#rm : SI<0x10, MRMSrcMem, (outs RC:$dst), (ins x86memop:$src),
                     !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                     [(set RC:$dst, (mem_pat addr:$src))],
                     IIC_SSE_MOV_S_RM>, VEX, VEX_LIG, Sched<[WriteLoad]>;
  def NAME#rm   : SI<0x10, MRMSrcMem, (outs RC:$dst), (ins x86memop:$src),
                     !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                     [(set RC:$dst, (mem_pat addr:$src))],
                     IIC_SSE_MOV_S_RM>, Sched<[WriteLoad]>;
}

defm MOVSS : sse12_move<FR32, X86Movss, v4f32, f32mem, "movss">, XS;
defm MOVSD : sse12_move<FR64, X86Movsd, v2f64, f64mem, "movsd">, XD;

let canFoldAsLoad = 1, isReMaterializable = 1 in {
  defm MOVSS : sse12_move_rm<FR32, f32mem, loadf32, "movss">, XS;

  let AddedComplexity = 20 in
    defm MOVSD : sse12_move_rm<FR64, f64mem, loadf64, "movsd">, XD;
}

// Patterns
let Predicates = [HasAVX] in {
  let AddedComplexity = 15 in {
  // Move scalar to XMM zero-extended, zeroing a VR128 then do a
  // MOVS{S,D} to the lower bits.
  def : Pat<(v4f32 (X86vzmovl (v4f32 (scalar_to_vector FR32:$src)))),
            (VMOVSSrr (v4f32 (V_SET0)), FR32:$src)>;
  def : Pat<(v4f32 (X86vzmovl (v4f32 VR128:$src))),
            (VMOVSSrr (v4f32 (V_SET0)), (COPY_TO_REGCLASS VR128:$src, FR32))>;
  def : Pat<(v4i32 (X86vzmovl (v4i32 VR128:$src))),
            (VMOVSSrr (v4i32 (V_SET0)), (COPY_TO_REGCLASS VR128:$src, FR32))>;
  def : Pat<(v2f64 (X86vzmovl (v2f64 (scalar_to_vector FR64:$src)))),
            (VMOVSDrr (v2f64 (V_SET0)), FR64:$src)>;

  // Move low f32 and clear high bits.
  def : Pat<(v8f32 (X86vzmovl (v8f32 VR256:$src))),
            (SUBREG_TO_REG (i32 0),
             (VMOVSSrr (v4f32 (V_SET0)),
                       (EXTRACT_SUBREG (v8f32 VR256:$src), sub_xmm)), sub_xmm)>;
  def : Pat<(v8i32 (X86vzmovl (v8i32 VR256:$src))),
            (SUBREG_TO_REG (i32 0),
             (VMOVSSrr (v4i32 (V_SET0)),
                       (EXTRACT_SUBREG (v8i32 VR256:$src), sub_xmm)), sub_xmm)>;
  }

  let AddedComplexity = 20 in {
  // MOVSSrm zeros the high parts of the register; represent this
  // with SUBREG_TO_REG. The AVX versions also write: DST[255:128] <- 0
  def : Pat<(v4f32 (X86vzmovl (v4f32 (scalar_to_vector (loadf32 addr:$src))))),
            (COPY_TO_REGCLASS (VMOVSSrm addr:$src), VR128)>;
  def : Pat<(v4f32 (scalar_to_vector (loadf32 addr:$src))),
            (COPY_TO_REGCLASS (VMOVSSrm addr:$src), VR128)>;
  def : Pat<(v4f32 (X86vzmovl (loadv4f32 addr:$src))),
            (COPY_TO_REGCLASS (VMOVSSrm addr:$src), VR128)>;

  // MOVSDrm zeros the high parts of the register; represent this
  // with SUBREG_TO_REG. The AVX versions also write: DST[255:128] <- 0
  def : Pat<(v2f64 (X86vzmovl (v2f64 (scalar_to_vector (loadf64 addr:$src))))),
            (COPY_TO_REGCLASS (VMOVSDrm addr:$src), VR128)>;
  def : Pat<(v2f64 (scalar_to_vector (loadf64 addr:$src))),
            (COPY_TO_REGCLASS (VMOVSDrm addr:$src), VR128)>;
  def : Pat<(v2f64 (X86vzmovl (loadv2f64 addr:$src))),
            (COPY_TO_REGCLASS (VMOVSDrm addr:$src), VR128)>;
  def : Pat<(v2f64 (X86vzmovl (bc_v2f64 (loadv4f32 addr:$src)))),
            (COPY_TO_REGCLASS (VMOVSDrm addr:$src), VR128)>;
  def : Pat<(v2f64 (X86vzload addr:$src)),
            (COPY_TO_REGCLASS (VMOVSDrm addr:$src), VR128)>;

  // Represent the same patterns above but in the form they appear for
  // 256-bit types
  def : Pat<(v8i32 (X86vzmovl (insert_subvector undef,
                   (v4i32 (scalar_to_vector (loadi32 addr:$src))), (iPTR 0)))),
            (SUBREG_TO_REG (i32 0), (VMOVSSrm addr:$src), sub_xmm)>;
  def : Pat<(v8f32 (X86vzmovl (insert_subvector undef,
                   (v4f32 (scalar_to_vector (loadf32 addr:$src))), (iPTR 0)))),
            (SUBREG_TO_REG (i32 0), (VMOVSSrm addr:$src), sub_xmm)>;
  def : Pat<(v4f64 (X86vzmovl (insert_subvector undef,
                   (v2f64 (scalar_to_vector (loadf64 addr:$src))), (iPTR 0)))),
            (SUBREG_TO_REG (i32 0), (VMOVSDrm addr:$src), sub_xmm)>;
  }
  def : Pat<(v8f32 (X86vzmovl (insert_subvector undef,
                   (v4f32 (scalar_to_vector FR32:$src)), (iPTR 0)))),
            (SUBREG_TO_REG (i32 0),
                           (v4f32 (VMOVSSrr (v4f32 (V_SET0)), FR32:$src)),
                           sub_xmm)>;
  def : Pat<(v4f64 (X86vzmovl (insert_subvector undef,
                   (v2f64 (scalar_to_vector FR64:$src)), (iPTR 0)))),
            (SUBREG_TO_REG (i64 0),
                           (v2f64 (VMOVSDrr (v2f64 (V_SET0)), FR64:$src)),
                           sub_xmm)>;
  def : Pat<(v4i64 (X86vzmovl (insert_subvector undef,
                   (v2i64 (scalar_to_vector (loadi64 addr:$src))), (iPTR 0)))),
            (SUBREG_TO_REG (i64 0), (VMOVSDrm addr:$src), sub_xmm)>;

  // Move low f64 and clear high bits.
  def : Pat<(v4f64 (X86vzmovl (v4f64 VR256:$src))),
            (SUBREG_TO_REG (i32 0),
             (VMOVSDrr (v2f64 (V_SET0)),
                       (EXTRACT_SUBREG (v4f64 VR256:$src), sub_xmm)), sub_xmm)>;

  def : Pat<(v4i64 (X86vzmovl (v4i64 VR256:$src))),
            (SUBREG_TO_REG (i32 0),
             (VMOVSDrr (v2i64 (V_SET0)),
                       (EXTRACT_SUBREG (v4i64 VR256:$src), sub_xmm)), sub_xmm)>;

  // Extract and store.
  def : Pat<(store (f32 (vector_extract (v4f32 VR128:$src), (iPTR 0))),
                   addr:$dst),
            (VMOVSSmr addr:$dst, (COPY_TO_REGCLASS (v4f32 VR128:$src), FR32))>;
  def : Pat<(store (f64 (vector_extract (v2f64 VR128:$src), (iPTR 0))),
                   addr:$dst),
            (VMOVSDmr addr:$dst, (COPY_TO_REGCLASS (v2f64 VR128:$src), FR64))>;

  // Shuffle with VMOVSS
  def : Pat<(v4i32 (X86Movss VR128:$src1, VR128:$src2)),
            (VMOVSSrr (v4i32 VR128:$src1),
                      (COPY_TO_REGCLASS (v4i32 VR128:$src2), FR32))>;
  def : Pat<(v4f32 (X86Movss VR128:$src1, VR128:$src2)),
            (VMOVSSrr (v4f32 VR128:$src1),
                      (COPY_TO_REGCLASS (v4f32 VR128:$src2), FR32))>;

  // 256-bit variants
  def : Pat<(v8i32 (X86Movss VR256:$src1, VR256:$src2)),
            (SUBREG_TO_REG (i32 0),
              (VMOVSSrr (EXTRACT_SUBREG (v8i32 VR256:$src1), sub_xmm),
                        (EXTRACT_SUBREG (v8i32 VR256:$src2), sub_xmm)),
              sub_xmm)>;
  def : Pat<(v8f32 (X86Movss VR256:$src1, VR256:$src2)),
            (SUBREG_TO_REG (i32 0),
              (VMOVSSrr (EXTRACT_SUBREG (v8f32 VR256:$src1), sub_xmm),
                        (EXTRACT_SUBREG (v8f32 VR256:$src2), sub_xmm)),
              sub_xmm)>;

  // Shuffle with VMOVSD
  def : Pat<(v2i64 (X86Movsd VR128:$src1, VR128:$src2)),
            (VMOVSDrr VR128:$src1, (COPY_TO_REGCLASS VR128:$src2, FR64))>;
  def : Pat<(v2f64 (X86Movsd VR128:$src1, VR128:$src2)),
            (VMOVSDrr VR128:$src1, (COPY_TO_REGCLASS VR128:$src2, FR64))>;
  def : Pat<(v4f32 (X86Movsd VR128:$src1, VR128:$src2)),
            (VMOVSDrr VR128:$src1, (COPY_TO_REGCLASS VR128:$src2, FR64))>;
  def : Pat<(v4i32 (X86Movsd VR128:$src1, VR128:$src2)),
            (VMOVSDrr VR128:$src1, (COPY_TO_REGCLASS VR128:$src2, FR64))>;

  // 256-bit variants
  def : Pat<(v4i64 (X86Movsd VR256:$src1, VR256:$src2)),
            (SUBREG_TO_REG (i32 0),
              (VMOVSDrr (EXTRACT_SUBREG (v4i64 VR256:$src1), sub_xmm),
                        (EXTRACT_SUBREG (v4i64 VR256:$src2), sub_xmm)),
              sub_xmm)>;
  def : Pat<(v4f64 (X86Movsd VR256:$src1, VR256:$src2)),
            (SUBREG_TO_REG (i32 0),
              (VMOVSDrr (EXTRACT_SUBREG (v4f64 VR256:$src1), sub_xmm),
                        (EXTRACT_SUBREG (v4f64 VR256:$src2), sub_xmm)),
              sub_xmm)>;


  // FIXME: Instead of a X86Movlps there should be a X86Movsd here, the problem
  // is during lowering, where it's not possible to recognize the fold cause
  // it has two uses through a bitcast. One use disappears at isel time and the
  // fold opportunity reappears.
  def : Pat<(v2f64 (X86Movlpd VR128:$src1, VR128:$src2)),
            (VMOVSDrr VR128:$src1, (COPY_TO_REGCLASS VR128:$src2, FR64))>;
  def : Pat<(v2i64 (X86Movlpd VR128:$src1, VR128:$src2)),
            (VMOVSDrr VR128:$src1, (COPY_TO_REGCLASS VR128:$src2, FR64))>;
  def : Pat<(v4f32 (X86Movlps VR128:$src1, VR128:$src2)),
            (VMOVSDrr VR128:$src1, (COPY_TO_REGCLASS VR128:$src2, FR64))>;
  def : Pat<(v4i32 (X86Movlps VR128:$src1, VR128:$src2)),
            (VMOVSDrr VR128:$src1, (COPY_TO_REGCLASS VR128:$src2, FR64))>;
}

let Predicates = [UseSSE1] in {
  let AddedComplexity = 15 in {
  // Move scalar to XMM zero-extended, zeroing a VR128 then do a
  // MOVSS to the lower bits.
  def : Pat<(v4f32 (X86vzmovl (v4f32 (scalar_to_vector FR32:$src)))),
            (MOVSSrr (v4f32 (V_SET0)), FR32:$src)>;
  def : Pat<(v4f32 (X86vzmovl (v4f32 VR128:$src))),
            (MOVSSrr (v4f32 (V_SET0)), (COPY_TO_REGCLASS VR128:$src, FR32))>;
  def : Pat<(v4i32 (X86vzmovl (v4i32 VR128:$src))),
            (MOVSSrr (v4i32 (V_SET0)), (COPY_TO_REGCLASS VR128:$src, FR32))>;
  }

  let AddedComplexity = 20 in {
  // MOVSSrm already zeros the high parts of the register.
  def : Pat<(v4f32 (X86vzmovl (v4f32 (scalar_to_vector (loadf32 addr:$src))))),
            (COPY_TO_REGCLASS (MOVSSrm addr:$src), VR128)>;
  def : Pat<(v4f32 (scalar_to_vector (loadf32 addr:$src))),
            (COPY_TO_REGCLASS (MOVSSrm addr:$src), VR128)>;
  def : Pat<(v4f32 (X86vzmovl (loadv4f32 addr:$src))),
            (COPY_TO_REGCLASS (MOVSSrm addr:$src), VR128)>;
  }

  // Extract and store.
  def : Pat<(store (f32 (vector_extract (v4f32 VR128:$src), (iPTR 0))),
                   addr:$dst),
            (MOVSSmr addr:$dst, (COPY_TO_REGCLASS VR128:$src, FR32))>;

  // Shuffle with MOVSS
  def : Pat<(v4i32 (X86Movss VR128:$src1, VR128:$src2)),
            (MOVSSrr VR128:$src1, (COPY_TO_REGCLASS VR128:$src2, FR32))>;
  def : Pat<(v4f32 (X86Movss VR128:$src1, VR128:$src2)),
            (MOVSSrr VR128:$src1, (COPY_TO_REGCLASS VR128:$src2, FR32))>;
}

let Predicates = [UseSSE2] in {
  let AddedComplexity = 15 in {
  // Move scalar to XMM zero-extended, zeroing a VR128 then do a
  // MOVSD to the lower bits.
  def : Pat<(v2f64 (X86vzmovl (v2f64 (scalar_to_vector FR64:$src)))),
            (MOVSDrr (v2f64 (V_SET0)), FR64:$src)>;
  }

  let AddedComplexity = 20 in {
  // MOVSDrm already zeros the high parts of the register.
  def : Pat<(v2f64 (X86vzmovl (v2f64 (scalar_to_vector (loadf64 addr:$src))))),
            (COPY_TO_REGCLASS (MOVSDrm addr:$src), VR128)>;
  def : Pat<(v2f64 (scalar_to_vector (loadf64 addr:$src))),
            (COPY_TO_REGCLASS (MOVSDrm addr:$src), VR128)>;
  def : Pat<(v2f64 (X86vzmovl (loadv2f64 addr:$src))),
            (COPY_TO_REGCLASS (MOVSDrm addr:$src), VR128)>;
  def : Pat<(v2f64 (X86vzmovl (bc_v2f64 (loadv4f32 addr:$src)))),
            (COPY_TO_REGCLASS (MOVSDrm addr:$src), VR128)>;
  def : Pat<(v2f64 (X86vzload addr:$src)),
            (COPY_TO_REGCLASS (MOVSDrm addr:$src), VR128)>;
  }

  // Extract and store.
  def : Pat<(store (f64 (vector_extract (v2f64 VR128:$src), (iPTR 0))),
                   addr:$dst),
            (MOVSDmr addr:$dst, (COPY_TO_REGCLASS VR128:$src, FR64))>;

  // Shuffle with MOVSD
  def : Pat<(v2i64 (X86Movsd VR128:$src1, VR128:$src2)),
            (MOVSDrr VR128:$src1, (COPY_TO_REGCLASS VR128:$src2, FR64))>;
  def : Pat<(v2f64 (X86Movsd VR128:$src1, VR128:$src2)),
            (MOVSDrr VR128:$src1, (COPY_TO_REGCLASS VR128:$src2, FR64))>;
  def : Pat<(v4f32 (X86Movsd VR128:$src1, VR128:$src2)),
            (MOVSDrr VR128:$src1, (COPY_TO_REGCLASS VR128:$src2, FR64))>;
  def : Pat<(v4i32 (X86Movsd VR128:$src1, VR128:$src2)),
            (MOVSDrr VR128:$src1, (COPY_TO_REGCLASS VR128:$src2, FR64))>;

  // FIXME: Instead of a X86Movlps there should be a X86Movsd here, the problem
  // is during lowering, where it's not possible to recognize the fold cause
  // it has two uses through a bitcast. One use disappears at isel time and the
  // fold opportunity reappears.
  def : Pat<(v2f64 (X86Movlpd VR128:$src1, VR128:$src2)),
            (MOVSDrr VR128:$src1, (COPY_TO_REGCLASS VR128:$src2, FR64))>;
  def : Pat<(v2i64 (X86Movlpd VR128:$src1, VR128:$src2)),
            (MOVSDrr VR128:$src1, (COPY_TO_REGCLASS VR128:$src2, FR64))>;
  def : Pat<(v4f32 (X86Movlps VR128:$src1, VR128:$src2)),
            (MOVSDrr VR128:$src1, (COPY_TO_REGCLASS VR128:$src2, FR64))>;
  def : Pat<(v4i32 (X86Movlps VR128:$src1, VR128:$src2)),
            (MOVSDrr VR128:$src1, (COPY_TO_REGCLASS VR128:$src2, FR64))>;
}

//===----------------------------------------------------------------------===//
// SSE 1 & 2 - Move Aligned/Unaligned FP Instructions
//===----------------------------------------------------------------------===//

multiclass sse12_mov_packed<bits<8> opc, RegisterClass RC,
                            X86MemOperand x86memop, PatFrag ld_frag,
                            string asm, Domain d,
                            OpndItins itins,
                            bit IsReMaterializable = 1> {
let neverHasSideEffects = 1 in
  def rr : PI<opc, MRMSrcReg, (outs RC:$dst), (ins RC:$src),
              !strconcat(asm, "\t{$src, $dst|$dst, $src}"), [], itins.rr, d>,
           Sched<[WriteMove]>;
let canFoldAsLoad = 1, isReMaterializable = IsReMaterializable in
  def rm : PI<opc, MRMSrcMem, (outs RC:$dst), (ins x86memop:$src),
              !strconcat(asm, "\t{$src, $dst|$dst, $src}"),
                   [(set RC:$dst, (ld_frag addr:$src))], itins.rm, d>,
           Sched<[WriteLoad]>;
}

defm VMOVAPS : sse12_mov_packed<0x28, VR128, f128mem, alignedloadv4f32,
                              "movaps", SSEPackedSingle, SSE_MOVA_ITINS>,
                              TB, VEX;
defm VMOVAPD : sse12_mov_packed<0x28, VR128, f128mem, alignedloadv2f64,
                              "movapd", SSEPackedDouble, SSE_MOVA_ITINS>,
                              TB, OpSize, VEX;
defm VMOVUPS : sse12_mov_packed<0x10, VR128, f128mem, loadv4f32,
                              "movups", SSEPackedSingle, SSE_MOVU_ITINS>,
                              TB, VEX;
defm VMOVUPD : sse12_mov_packed<0x10, VR128, f128mem, loadv2f64,
                              "movupd", SSEPackedDouble, SSE_MOVU_ITINS, 0>,
                              TB, OpSize, VEX;

defm VMOVAPSY : sse12_mov_packed<0x28, VR256, f256mem, alignedloadv8f32,
                              "movaps", SSEPackedSingle, SSE_MOVA_ITINS>,
                              TB, VEX, VEX_L;
defm VMOVAPDY : sse12_mov_packed<0x28, VR256, f256mem, alignedloadv4f64,
                              "movapd", SSEPackedDouble, SSE_MOVA_ITINS>,
                              TB, OpSize, VEX, VEX_L;
defm VMOVUPSY : sse12_mov_packed<0x10, VR256, f256mem, loadv8f32,
                              "movups", SSEPackedSingle, SSE_MOVU_ITINS>,
                              TB, VEX, VEX_L;
defm VMOVUPDY : sse12_mov_packed<0x10, VR256, f256mem, loadv4f64,
                              "movupd", SSEPackedDouble, SSE_MOVU_ITINS, 0>,
                              TB, OpSize, VEX, VEX_L;
defm MOVAPS : sse12_mov_packed<0x28, VR128, f128mem, alignedloadv4f32,
                              "movaps", SSEPackedSingle, SSE_MOVA_ITINS>,
                              TB;
defm MOVAPD : sse12_mov_packed<0x28, VR128, f128mem, alignedloadv2f64,
                              "movapd", SSEPackedDouble, SSE_MOVA_ITINS>,
                              TB, OpSize;
defm MOVUPS : sse12_mov_packed<0x10, VR128, f128mem, loadv4f32,
                              "movups", SSEPackedSingle, SSE_MOVU_ITINS>,
                              TB;
defm MOVUPD : sse12_mov_packed<0x10, VR128, f128mem, loadv2f64,
                              "movupd", SSEPackedDouble, SSE_MOVU_ITINS, 0>,
                              TB, OpSize;

let SchedRW = [WriteStore] in {
def VMOVAPSmr : VPSI<0x29, MRMDestMem, (outs), (ins f128mem:$dst, VR128:$src),
                   "movaps\t{$src, $dst|$dst, $src}",
                   [(alignedstore (v4f32 VR128:$src), addr:$dst)],
                   IIC_SSE_MOVA_P_MR>, VEX;
def VMOVAPDmr : VPDI<0x29, MRMDestMem, (outs), (ins f128mem:$dst, VR128:$src),
                   "movapd\t{$src, $dst|$dst, $src}",
                   [(alignedstore (v2f64 VR128:$src), addr:$dst)],
                   IIC_SSE_MOVA_P_MR>, VEX;
def VMOVUPSmr : VPSI<0x11, MRMDestMem, (outs), (ins f128mem:$dst, VR128:$src),
                   "movups\t{$src, $dst|$dst, $src}",
                   [(store (v4f32 VR128:$src), addr:$dst)],
                   IIC_SSE_MOVU_P_MR>, VEX;
def VMOVUPDmr : VPDI<0x11, MRMDestMem, (outs), (ins f128mem:$dst, VR128:$src),
                   "movupd\t{$src, $dst|$dst, $src}",
                   [(store (v2f64 VR128:$src), addr:$dst)],
                   IIC_SSE_MOVU_P_MR>, VEX;
def VMOVAPSYmr : VPSI<0x29, MRMDestMem, (outs), (ins f256mem:$dst, VR256:$src),
                   "movaps\t{$src, $dst|$dst, $src}",
                   [(alignedstore256 (v8f32 VR256:$src), addr:$dst)],
                   IIC_SSE_MOVA_P_MR>, VEX, VEX_L;
def VMOVAPDYmr : VPDI<0x29, MRMDestMem, (outs), (ins f256mem:$dst, VR256:$src),
                   "movapd\t{$src, $dst|$dst, $src}",
                   [(alignedstore256 (v4f64 VR256:$src), addr:$dst)],
                   IIC_SSE_MOVA_P_MR>, VEX, VEX_L;
def VMOVUPSYmr : VPSI<0x11, MRMDestMem, (outs), (ins f256mem:$dst, VR256:$src),
                   "movups\t{$src, $dst|$dst, $src}",
                   [(store (v8f32 VR256:$src), addr:$dst)],
                   IIC_SSE_MOVU_P_MR>, VEX, VEX_L;
def VMOVUPDYmr : VPDI<0x11, MRMDestMem, (outs), (ins f256mem:$dst, VR256:$src),
                   "movupd\t{$src, $dst|$dst, $src}",
                   [(store (v4f64 VR256:$src), addr:$dst)],
                   IIC_SSE_MOVU_P_MR>, VEX, VEX_L;
} // SchedRW

// For disassembler
let isCodeGenOnly = 1, hasSideEffects = 0, SchedRW = [WriteMove] in {
  def VMOVAPSrr_REV : VPSI<0x29, MRMDestReg, (outs VR128:$dst),
                          (ins VR128:$src),
                          "movaps\t{$src, $dst|$dst, $src}", [],
                          IIC_SSE_MOVA_P_RR>, VEX;
  def VMOVAPDrr_REV : VPDI<0x29, MRMDestReg, (outs VR128:$dst),
                           (ins VR128:$src),
                           "movapd\t{$src, $dst|$dst, $src}", [],
                           IIC_SSE_MOVA_P_RR>, VEX;
  def VMOVUPSrr_REV : VPSI<0x11, MRMDestReg, (outs VR128:$dst),
                           (ins VR128:$src),
                           "movups\t{$src, $dst|$dst, $src}", [],
                           IIC_SSE_MOVU_P_RR>, VEX;
  def VMOVUPDrr_REV : VPDI<0x11, MRMDestReg, (outs VR128:$dst),
                           (ins VR128:$src),
                           "movupd\t{$src, $dst|$dst, $src}", [],
                           IIC_SSE_MOVU_P_RR>, VEX;
  def VMOVAPSYrr_REV : VPSI<0x29, MRMDestReg, (outs VR256:$dst),
                            (ins VR256:$src),
                            "movaps\t{$src, $dst|$dst, $src}", [],
                            IIC_SSE_MOVA_P_RR>, VEX, VEX_L;
  def VMOVAPDYrr_REV : VPDI<0x29, MRMDestReg, (outs VR256:$dst),
                            (ins VR256:$src),
                            "movapd\t{$src, $dst|$dst, $src}", [],
                            IIC_SSE_MOVA_P_RR>, VEX, VEX_L;
  def VMOVUPSYrr_REV : VPSI<0x11, MRMDestReg, (outs VR256:$dst),
                            (ins VR256:$src),
                            "movups\t{$src, $dst|$dst, $src}", [],
                            IIC_SSE_MOVU_P_RR>, VEX, VEX_L;
  def VMOVUPDYrr_REV : VPDI<0x11, MRMDestReg, (outs VR256:$dst),
                            (ins VR256:$src),
                            "movupd\t{$src, $dst|$dst, $src}", [],
                            IIC_SSE_MOVU_P_RR>, VEX, VEX_L;
}

let Predicates = [HasAVX] in {
def : Pat<(v8i32 (X86vzmovl
                  (insert_subvector undef, (v4i32 VR128:$src), (iPTR 0)))),
          (SUBREG_TO_REG (i32 0), (VMOVAPSrr VR128:$src), sub_xmm)>;
def : Pat<(v4i64 (X86vzmovl
                  (insert_subvector undef, (v2i64 VR128:$src), (iPTR 0)))),
          (SUBREG_TO_REG (i32 0), (VMOVAPSrr VR128:$src), sub_xmm)>;
def : Pat<(v8f32 (X86vzmovl
                  (insert_subvector undef, (v4f32 VR128:$src), (iPTR 0)))),
          (SUBREG_TO_REG (i32 0), (VMOVAPSrr VR128:$src), sub_xmm)>;
def : Pat<(v4f64 (X86vzmovl
                  (insert_subvector undef, (v2f64 VR128:$src), (iPTR 0)))),
          (SUBREG_TO_REG (i32 0), (VMOVAPSrr VR128:$src), sub_xmm)>;
}


def : Pat<(int_x86_avx_storeu_ps_256 addr:$dst, VR256:$src),
          (VMOVUPSYmr addr:$dst, VR256:$src)>;
def : Pat<(int_x86_avx_storeu_pd_256 addr:$dst, VR256:$src),
          (VMOVUPDYmr addr:$dst, VR256:$src)>;

let SchedRW = [WriteStore] in {
def MOVAPSmr : PSI<0x29, MRMDestMem, (outs), (ins f128mem:$dst, VR128:$src),
                   "movaps\t{$src, $dst|$dst, $src}",
                   [(alignedstore (v4f32 VR128:$src), addr:$dst)],
                   IIC_SSE_MOVA_P_MR>;
def MOVAPDmr : PDI<0x29, MRMDestMem, (outs), (ins f128mem:$dst, VR128:$src),
                   "movapd\t{$src, $dst|$dst, $src}",
                   [(alignedstore (v2f64 VR128:$src), addr:$dst)],
                   IIC_SSE_MOVA_P_MR>;
def MOVUPSmr : PSI<0x11, MRMDestMem, (outs), (ins f128mem:$dst, VR128:$src),
                   "movups\t{$src, $dst|$dst, $src}",
                   [(store (v4f32 VR128:$src), addr:$dst)],
                   IIC_SSE_MOVU_P_MR>;
def MOVUPDmr : PDI<0x11, MRMDestMem, (outs), (ins f128mem:$dst, VR128:$src),
                   "movupd\t{$src, $dst|$dst, $src}",
                   [(store (v2f64 VR128:$src), addr:$dst)],
                   IIC_SSE_MOVU_P_MR>;
} // SchedRW

// For disassembler
let isCodeGenOnly = 1, hasSideEffects = 0, SchedRW = [WriteMove] in {
  def MOVAPSrr_REV : PSI<0x29, MRMDestReg, (outs VR128:$dst), (ins VR128:$src),
                         "movaps\t{$src, $dst|$dst, $src}", [],
                         IIC_SSE_MOVA_P_RR>;
  def MOVAPDrr_REV : PDI<0x29, MRMDestReg, (outs VR128:$dst), (ins VR128:$src),
                         "movapd\t{$src, $dst|$dst, $src}", [],
                         IIC_SSE_MOVA_P_RR>;
  def MOVUPSrr_REV : PSI<0x11, MRMDestReg, (outs VR128:$dst), (ins VR128:$src),
                         "movups\t{$src, $dst|$dst, $src}", [],
                         IIC_SSE_MOVU_P_RR>;
  def MOVUPDrr_REV : PDI<0x11, MRMDestReg, (outs VR128:$dst), (ins VR128:$src),
                         "movupd\t{$src, $dst|$dst, $src}", [],
                         IIC_SSE_MOVU_P_RR>;
}

let Predicates = [HasAVX] in {
  def : Pat<(int_x86_sse_storeu_ps addr:$dst, VR128:$src),
            (VMOVUPSmr addr:$dst, VR128:$src)>;
  def : Pat<(int_x86_sse2_storeu_pd addr:$dst, VR128:$src),
            (VMOVUPDmr addr:$dst, VR128:$src)>;
}

let Predicates = [UseSSE1] in
  def : Pat<(int_x86_sse_storeu_ps addr:$dst, VR128:$src),
            (MOVUPSmr addr:$dst, VR128:$src)>;
let Predicates = [UseSSE2] in
  def : Pat<(int_x86_sse2_storeu_pd addr:$dst, VR128:$src),
            (MOVUPDmr addr:$dst, VR128:$src)>;

// Use vmovaps/vmovups for AVX integer load/store.
let Predicates = [HasAVX] in {
  // 128-bit load/store
  def : Pat<(alignedloadv2i64 addr:$src),
            (VMOVAPSrm addr:$src)>;
  def : Pat<(loadv2i64 addr:$src),
            (VMOVUPSrm addr:$src)>;

  def : Pat<(alignedstore (v2i64 VR128:$src), addr:$dst),
            (VMOVAPSmr addr:$dst, VR128:$src)>;
  def : Pat<(alignedstore (v4i32 VR128:$src), addr:$dst),
            (VMOVAPSmr addr:$dst, VR128:$src)>;
  def : Pat<(alignedstore (v8i16 VR128:$src), addr:$dst),
            (VMOVAPSmr addr:$dst, VR128:$src)>;
  def : Pat<(alignedstore (v16i8 VR128:$src), addr:$dst),
            (VMOVAPSmr addr:$dst, VR128:$src)>;
  def : Pat<(store (v2i64 VR128:$src), addr:$dst),
            (VMOVUPSmr addr:$dst, VR128:$src)>;
  def : Pat<(store (v4i32 VR128:$src), addr:$dst),
            (VMOVUPSmr addr:$dst, VR128:$src)>;
  def : Pat<(store (v8i16 VR128:$src), addr:$dst),
            (VMOVUPSmr addr:$dst, VR128:$src)>;
  def : Pat<(store (v16i8 VR128:$src), addr:$dst),
            (VMOVUPSmr addr:$dst, VR128:$src)>;

  // 256-bit load/store
  def : Pat<(alignedloadv4i64 addr:$src),
            (VMOVAPSYrm addr:$src)>;
  def : Pat<(loadv4i64 addr:$src),
            (VMOVUPSYrm addr:$src)>;
  def : Pat<(alignedstore256 (v4i64 VR256:$src), addr:$dst),
            (VMOVAPSYmr addr:$dst, VR256:$src)>;
  def : Pat<(alignedstore256 (v8i32 VR256:$src), addr:$dst),
            (VMOVAPSYmr addr:$dst, VR256:$src)>;
  def : Pat<(alignedstore256 (v16i16 VR256:$src), addr:$dst),
            (VMOVAPSYmr addr:$dst, VR256:$src)>;
  def : Pat<(alignedstore256 (v32i8 VR256:$src), addr:$dst),
            (VMOVAPSYmr addr:$dst, VR256:$src)>;
  def : Pat<(store (v4i64 VR256:$src), addr:$dst),
            (VMOVUPSYmr addr:$dst, VR256:$src)>;
  def : Pat<(store (v8i32 VR256:$src), addr:$dst),
            (VMOVUPSYmr addr:$dst, VR256:$src)>;
  def : Pat<(store (v16i16 VR256:$src), addr:$dst),
            (VMOVUPSYmr addr:$dst, VR256:$src)>;
  def : Pat<(store (v32i8 VR256:$src), addr:$dst),
            (VMOVUPSYmr addr:$dst, VR256:$src)>;

  // Special patterns for storing subvector extracts of lower 128-bits
  // Its cheaper to just use VMOVAPS/VMOVUPS instead of VEXTRACTF128mr
  def : Pat<(alignedstore (v2f64 (extract_subvector
                                  (v4f64 VR256:$src), (iPTR 0))), addr:$dst),
            (VMOVAPDmr addr:$dst, (v2f64 (EXTRACT_SUBREG VR256:$src,sub_xmm)))>;
  def : Pat<(alignedstore (v4f32 (extract_subvector
                                  (v8f32 VR256:$src), (iPTR 0))), addr:$dst),
            (VMOVAPSmr addr:$dst, (v4f32 (EXTRACT_SUBREG VR256:$src,sub_xmm)))>;
  def : Pat<(alignedstore (v2i64 (extract_subvector
                                  (v4i64 VR256:$src), (iPTR 0))), addr:$dst),
            (VMOVAPDmr addr:$dst, (v2i64 (EXTRACT_SUBREG VR256:$src,sub_xmm)))>;
  def : Pat<(alignedstore (v4i32 (extract_subvector
                                  (v8i32 VR256:$src), (iPTR 0))), addr:$dst),
            (VMOVAPSmr addr:$dst, (v4i32 (EXTRACT_SUBREG VR256:$src,sub_xmm)))>;
  def : Pat<(alignedstore (v8i16 (extract_subvector
                                  (v16i16 VR256:$src), (iPTR 0))), addr:$dst),
            (VMOVAPSmr addr:$dst, (v8i16 (EXTRACT_SUBREG VR256:$src,sub_xmm)))>;
  def : Pat<(alignedstore (v16i8 (extract_subvector
                                  (v32i8 VR256:$src), (iPTR 0))), addr:$dst),
            (VMOVAPSmr addr:$dst, (v16i8 (EXTRACT_SUBREG VR256:$src,sub_xmm)))>;

  def : Pat<(store (v2f64 (extract_subvector
                           (v4f64 VR256:$src), (iPTR 0))), addr:$dst),
            (VMOVUPDmr addr:$dst, (v2f64 (EXTRACT_SUBREG VR256:$src,sub_xmm)))>;
  def : Pat<(store (v4f32 (extract_subvector
                           (v8f32 VR256:$src), (iPTR 0))), addr:$dst),
            (VMOVUPSmr addr:$dst, (v4f32 (EXTRACT_SUBREG VR256:$src,sub_xmm)))>;
  def : Pat<(store (v2i64 (extract_subvector
                           (v4i64 VR256:$src), (iPTR 0))), addr:$dst),
            (VMOVUPDmr addr:$dst, (v2i64 (EXTRACT_SUBREG VR256:$src,sub_xmm)))>;
  def : Pat<(store (v4i32 (extract_subvector
                           (v8i32 VR256:$src), (iPTR 0))), addr:$dst),
            (VMOVUPSmr addr:$dst, (v4i32 (EXTRACT_SUBREG VR256:$src,sub_xmm)))>;
  def : Pat<(store (v8i16 (extract_subvector
                           (v16i16 VR256:$src), (iPTR 0))), addr:$dst),
            (VMOVUPSmr addr:$dst, (v8i16 (EXTRACT_SUBREG VR256:$src,sub_xmm)))>;
  def : Pat<(store (v16i8 (extract_subvector
                           (v32i8 VR256:$src), (iPTR 0))), addr:$dst),
            (VMOVUPSmr addr:$dst, (v16i8 (EXTRACT_SUBREG VR256:$src,sub_xmm)))>;
}

// Use movaps / movups for SSE integer load / store (one byte shorter).
// The instructions selected below are then converted to MOVDQA/MOVDQU
// during the SSE domain pass.
let Predicates = [UseSSE1] in {
  def : Pat<(alignedloadv2i64 addr:$src),
            (MOVAPSrm addr:$src)>;
  def : Pat<(loadv2i64 addr:$src),
            (MOVUPSrm addr:$src)>;

  def : Pat<(alignedstore (v2i64 VR128:$src), addr:$dst),
            (MOVAPSmr addr:$dst, VR128:$src)>;
  def : Pat<(alignedstore (v4i32 VR128:$src), addr:$dst),
            (MOVAPSmr addr:$dst, VR128:$src)>;
  def : Pat<(alignedstore (v8i16 VR128:$src), addr:$dst),
            (MOVAPSmr addr:$dst, VR128:$src)>;
  def : Pat<(alignedstore (v16i8 VR128:$src), addr:$dst),
            (MOVAPSmr addr:$dst, VR128:$src)>;
  def : Pat<(store (v2i64 VR128:$src), addr:$dst),
            (MOVUPSmr addr:$dst, VR128:$src)>;
  def : Pat<(store (v4i32 VR128:$src), addr:$dst),
            (MOVUPSmr addr:$dst, VR128:$src)>;
  def : Pat<(store (v8i16 VR128:$src), addr:$dst),
            (MOVUPSmr addr:$dst, VR128:$src)>;
  def : Pat<(store (v16i8 VR128:$src), addr:$dst),
            (MOVUPSmr addr:$dst, VR128:$src)>;
}

// Alias instruction to do FR32 or FR64 reg-to-reg copy using movaps. Upper
// bits are disregarded. FIXME: Set encoding to pseudo!
let neverHasSideEffects = 1, SchedRW = [WriteMove] in {
def FsVMOVAPSrr : VPSI<0x28, MRMSrcReg, (outs FR32:$dst), (ins FR32:$src),
                       "movaps\t{$src, $dst|$dst, $src}", [],
                       IIC_SSE_MOVA_P_RR>, VEX;
def FsVMOVAPDrr : VPDI<0x28, MRMSrcReg, (outs FR64:$dst), (ins FR64:$src),
                       "movapd\t{$src, $dst|$dst, $src}", [],
                       IIC_SSE_MOVA_P_RR>, VEX;
def FsMOVAPSrr : PSI<0x28, MRMSrcReg, (outs FR32:$dst), (ins FR32:$src),
                     "movaps\t{$src, $dst|$dst, $src}", [],
                     IIC_SSE_MOVA_P_RR>;
def FsMOVAPDrr : PDI<0x28, MRMSrcReg, (outs FR64:$dst), (ins FR64:$src),
                     "movapd\t{$src, $dst|$dst, $src}", [],
                     IIC_SSE_MOVA_P_RR>;
}

// Alias instruction to load FR32 or FR64 from f128mem using movaps. Upper
// bits are disregarded. FIXME: Set encoding to pseudo!
let canFoldAsLoad = 1, isReMaterializable = 1, SchedRW = [WriteLoad] in {
let isCodeGenOnly = 1 in {
  def FsVMOVAPSrm : VPSI<0x28, MRMSrcMem, (outs FR32:$dst), (ins f128mem:$src),
                         "movaps\t{$src, $dst|$dst, $src}",
                         [(set FR32:$dst, (alignedloadfsf32 addr:$src))],
                         IIC_SSE_MOVA_P_RM>, VEX;
  def FsVMOVAPDrm : VPDI<0x28, MRMSrcMem, (outs FR64:$dst), (ins f128mem:$src),
                         "movapd\t{$src, $dst|$dst, $src}",
                         [(set FR64:$dst, (alignedloadfsf64 addr:$src))],
                         IIC_SSE_MOVA_P_RM>, VEX;
}
def FsMOVAPSrm : PSI<0x28, MRMSrcMem, (outs FR32:$dst), (ins f128mem:$src),
                     "movaps\t{$src, $dst|$dst, $src}",
                     [(set FR32:$dst, (alignedloadfsf32 addr:$src))],
                     IIC_SSE_MOVA_P_RM>;
def FsMOVAPDrm : PDI<0x28, MRMSrcMem, (outs FR64:$dst), (ins f128mem:$src),
                     "movapd\t{$src, $dst|$dst, $src}",
                     [(set FR64:$dst, (alignedloadfsf64 addr:$src))],
                     IIC_SSE_MOVA_P_RM>;
}

//===----------------------------------------------------------------------===//
// SSE 1 & 2 - Move Low packed FP Instructions
//===----------------------------------------------------------------------===//

multiclass sse12_mov_hilo_packed_base<bits<8>opc, SDNode psnode, SDNode pdnode,
                                      string base_opc, string asm_opr,
                                      InstrItinClass itin> {
  def PSrm : PI<opc, MRMSrcMem,
         (outs VR128:$dst), (ins VR128:$src1, f64mem:$src2),
         !strconcat(base_opc, "s", asm_opr),
     [(set VR128:$dst,
       (psnode VR128:$src1,
              (bc_v4f32 (v2f64 (scalar_to_vector (loadf64 addr:$src2))))))],
              itin, SSEPackedSingle>, TB,
     Sched<[WriteShuffleLd, ReadAfterLd]>;

  def PDrm : PI<opc, MRMSrcMem,
         (outs VR128:$dst), (ins VR128:$src1, f64mem:$src2),
         !strconcat(base_opc, "d", asm_opr),
     [(set VR128:$dst, (v2f64 (pdnode VR128:$src1,
                              (scalar_to_vector (loadf64 addr:$src2)))))],
              itin, SSEPackedDouble>, TB, OpSize,
     Sched<[WriteShuffleLd, ReadAfterLd]>;

}

multiclass sse12_mov_hilo_packed<bits<8>opc, SDNode psnode, SDNode pdnode,
                                 string base_opc, InstrItinClass itin> {
  defm V#NAME : sse12_mov_hilo_packed_base<opc, psnode, pdnode, base_opc,
                                    "\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                                    itin>, VEX_4V;

let Constraints = "$src1 = $dst" in
  defm NAME : sse12_mov_hilo_packed_base<opc, psnode, pdnode, base_opc,
                                    "\t{$src2, $dst|$dst, $src2}",
                                    itin>;
}

let AddedComplexity = 20 in {
  defm MOVL : sse12_mov_hilo_packed<0x12, X86Movlps, X86Movlpd, "movlp",
                                    IIC_SSE_MOV_LH>;
}

let SchedRW = [WriteStore] in {
def VMOVLPSmr : VPSI<0x13, MRMDestMem, (outs), (ins f64mem:$dst, VR128:$src),
                   "movlps\t{$src, $dst|$dst, $src}",
                   [(store (f64 (vector_extract (bc_v2f64 (v4f32 VR128:$src)),
                                 (iPTR 0))), addr:$dst)],
                                 IIC_SSE_MOV_LH>, VEX;
def VMOVLPDmr : VPDI<0x13, MRMDestMem, (outs), (ins f64mem:$dst, VR128:$src),
                   "movlpd\t{$src, $dst|$dst, $src}",
                   [(store (f64 (vector_extract (v2f64 VR128:$src),
                                 (iPTR 0))), addr:$dst)],
                                 IIC_SSE_MOV_LH>, VEX;
def MOVLPSmr : PSI<0x13, MRMDestMem, (outs), (ins f64mem:$dst, VR128:$src),
                   "movlps\t{$src, $dst|$dst, $src}",
                   [(store (f64 (vector_extract (bc_v2f64 (v4f32 VR128:$src)),
                                 (iPTR 0))), addr:$dst)],
                                 IIC_SSE_MOV_LH>;
def MOVLPDmr : PDI<0x13, MRMDestMem, (outs), (ins f64mem:$dst, VR128:$src),
                   "movlpd\t{$src, $dst|$dst, $src}",
                   [(store (f64 (vector_extract (v2f64 VR128:$src),
                                 (iPTR 0))), addr:$dst)],
                                 IIC_SSE_MOV_LH>;
} // SchedRW

let Predicates = [HasAVX] in {
  // Shuffle with VMOVLPS
  def : Pat<(v4f32 (X86Movlps VR128:$src1, (load addr:$src2))),
            (VMOVLPSrm VR128:$src1, addr:$src2)>;
  def : Pat<(v4i32 (X86Movlps VR128:$src1, (load addr:$src2))),
            (VMOVLPSrm VR128:$src1, addr:$src2)>;

  // Shuffle with VMOVLPD
  def : Pat<(v2f64 (X86Movlpd VR128:$src1, (load addr:$src2))),
            (VMOVLPDrm VR128:$src1, addr:$src2)>;
  def : Pat<(v2i64 (X86Movlpd VR128:$src1, (load addr:$src2))),
            (VMOVLPDrm VR128:$src1, addr:$src2)>;

  // Store patterns
  def : Pat<(store (v4f32 (X86Movlps (load addr:$src1), VR128:$src2)),
                   addr:$src1),
            (VMOVLPSmr addr:$src1, VR128:$src2)>;
  def : Pat<(store (v4i32 (X86Movlps
                   (bc_v4i32 (loadv2i64 addr:$src1)), VR128:$src2)), addr:$src1),
            (VMOVLPSmr addr:$src1, VR128:$src2)>;
  def : Pat<(store (v2f64 (X86Movlpd (load addr:$src1), VR128:$src2)),
                   addr:$src1),
            (VMOVLPDmr addr:$src1, VR128:$src2)>;
  def : Pat<(store (v2i64 (X86Movlpd (load addr:$src1), VR128:$src2)),
                   addr:$src1),
            (VMOVLPDmr addr:$src1, VR128:$src2)>;
}

let Predicates = [UseSSE1] in {
  // (store (vector_shuffle (load addr), v2, <4, 5, 2, 3>), addr) using MOVLPS
  def : Pat<(store (i64 (vector_extract (bc_v2i64 (v4f32 VR128:$src2)),
                                 (iPTR 0))), addr:$src1),
            (MOVLPSmr addr:$src1, VR128:$src2)>;

  // Shuffle with MOVLPS
  def : Pat<(v4f32 (X86Movlps VR128:$src1, (load addr:$src2))),
            (MOVLPSrm VR128:$src1, addr:$src2)>;
  def : Pat<(v4i32 (X86Movlps VR128:$src1, (load addr:$src2))),
            (MOVLPSrm VR128:$src1, addr:$src2)>;
  def : Pat<(X86Movlps VR128:$src1,
                      (bc_v4f32 (v2i64 (scalar_to_vector (loadi64 addr:$src2))))),
            (MOVLPSrm VR128:$src1, addr:$src2)>;

  // Store patterns
  def : Pat<(store (v4f32 (X86Movlps (load addr:$src1), VR128:$src2)),
                                      addr:$src1),
            (MOVLPSmr addr:$src1, VR128:$src2)>;
  def : Pat<(store (v4i32 (X86Movlps
                   (bc_v4i32 (loadv2i64 addr:$src1)), VR128:$src2)),
                              addr:$src1),
            (MOVLPSmr addr:$src1, VR128:$src2)>;
}

let Predicates = [UseSSE2] in {
  // Shuffle with MOVLPD
  def : Pat<(v2f64 (X86Movlpd VR128:$src1, (load addr:$src2))),
            (MOVLPDrm VR128:$src1, addr:$src2)>;
  def : Pat<(v2i64 (X86Movlpd VR128:$src1, (load addr:$src2))),
            (MOVLPDrm VR128:$src1, addr:$src2)>;

  // Store patterns
  def : Pat<(store (v2f64 (X86Movlpd (load addr:$src1), VR128:$src2)),
                           addr:$src1),
            (MOVLPDmr addr:$src1, VR128:$src2)>;
  def : Pat<(store (v2i64 (X86Movlpd (load addr:$src1), VR128:$src2)),
                           addr:$src1),
            (MOVLPDmr addr:$src1, VR128:$src2)>;
}

//===----------------------------------------------------------------------===//
// SSE 1 & 2 - Move Hi packed FP Instructions
//===----------------------------------------------------------------------===//

let AddedComplexity = 20 in {
  defm MOVH : sse12_mov_hilo_packed<0x16, X86Movlhps, X86Movlhpd, "movhp",
                                    IIC_SSE_MOV_LH>;
}

let SchedRW = [WriteStore] in {
// v2f64 extract element 1 is always custom lowered to unpack high to low
// and extract element 0 so the non-store version isn't too horrible.
def VMOVHPSmr : VPSI<0x17, MRMDestMem, (outs), (ins f64mem:$dst, VR128:$src),
                   "movhps\t{$src, $dst|$dst, $src}",
                   [(store (f64 (vector_extract
                                 (X86Unpckh (bc_v2f64 (v4f32 VR128:$src)),
                                            (bc_v2f64 (v4f32 VR128:$src))),
                                 (iPTR 0))), addr:$dst)], IIC_SSE_MOV_LH>, VEX;
def VMOVHPDmr : VPDI<0x17, MRMDestMem, (outs), (ins f64mem:$dst, VR128:$src),
                   "movhpd\t{$src, $dst|$dst, $src}",
                   [(store (f64 (vector_extract
                                 (v2f64 (X86Unpckh VR128:$src, VR128:$src)),
                                 (iPTR 0))), addr:$dst)], IIC_SSE_MOV_LH>, VEX;
def MOVHPSmr : PSI<0x17, MRMDestMem, (outs), (ins f64mem:$dst, VR128:$src),
                   "movhps\t{$src, $dst|$dst, $src}",
                   [(store (f64 (vector_extract
                                 (X86Unpckh (bc_v2f64 (v4f32 VR128:$src)),
                                            (bc_v2f64 (v4f32 VR128:$src))),
                                 (iPTR 0))), addr:$dst)], IIC_SSE_MOV_LH>;
def MOVHPDmr : PDI<0x17, MRMDestMem, (outs), (ins f64mem:$dst, VR128:$src),
                   "movhpd\t{$src, $dst|$dst, $src}",
                   [(store (f64 (vector_extract
                                 (v2f64 (X86Unpckh VR128:$src, VR128:$src)),
                                 (iPTR 0))), addr:$dst)], IIC_SSE_MOV_LH>;
} // SchedRW

let Predicates = [HasAVX] in {
  // VMOVHPS patterns
  def : Pat<(X86Movlhps VR128:$src1,
                 (bc_v4f32 (v2i64 (scalar_to_vector (loadi64 addr:$src2))))),
            (VMOVHPSrm VR128:$src1, addr:$src2)>;
  def : Pat<(X86Movlhps VR128:$src1,
                 (bc_v4i32 (v2i64 (X86vzload addr:$src2)))),
            (VMOVHPSrm VR128:$src1, addr:$src2)>;

  // FIXME: Instead of X86Unpckl, there should be a X86Movlhpd here, the problem
  // is during lowering, where it's not possible to recognize the load fold
  // cause it has two uses through a bitcast. One use disappears at isel time
  // and the fold opportunity reappears.
  def : Pat<(v2f64 (X86Unpckl VR128:$src1,
                      (scalar_to_vector (loadf64 addr:$src2)))),
            (VMOVHPDrm VR128:$src1, addr:$src2)>;
}

let Predicates = [UseSSE1] in {
  // MOVHPS patterns
  def : Pat<(X86Movlhps VR128:$src1,
                 (bc_v4f32 (v2i64 (scalar_to_vector (loadi64 addr:$src2))))),
            (MOVHPSrm VR128:$src1, addr:$src2)>;
  def : Pat<(X86Movlhps VR128:$src1,
                 (bc_v4f32 (v2i64 (X86vzload addr:$src2)))),
            (MOVHPSrm VR128:$src1, addr:$src2)>;
}

let Predicates = [UseSSE2] in {
  // FIXME: Instead of X86Unpckl, there should be a X86Movlhpd here, the problem
  // is during lowering, where it's not possible to recognize the load fold
  // cause it has two uses through a bitcast. One use disappears at isel time
  // and the fold opportunity reappears.
  def : Pat<(v2f64 (X86Unpckl VR128:$src1,
                      (scalar_to_vector (loadf64 addr:$src2)))),
            (MOVHPDrm VR128:$src1, addr:$src2)>;
}

//===----------------------------------------------------------------------===//
// SSE 1 & 2 - Move Low to High and High to Low packed FP Instructions
//===----------------------------------------------------------------------===//

let AddedComplexity = 20 in {
  def VMOVLHPSrr : VPSI<0x16, MRMSrcReg, (outs VR128:$dst),
                                       (ins VR128:$src1, VR128:$src2),
                      "movlhps\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                      [(set VR128:$dst,
                        (v4f32 (X86Movlhps VR128:$src1, VR128:$src2)))],
                        IIC_SSE_MOV_LH>,
                      VEX_4V, Sched<[WriteShuffle]>;
  def VMOVHLPSrr : VPSI<0x12, MRMSrcReg, (outs VR128:$dst),
                                       (ins VR128:$src1, VR128:$src2),
                      "movhlps\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                      [(set VR128:$dst,
                        (v4f32 (X86Movhlps VR128:$src1, VR128:$src2)))],
                        IIC_SSE_MOV_LH>,
                      VEX_4V, Sched<[WriteShuffle]>;
}
let Constraints = "$src1 = $dst", AddedComplexity = 20 in {
  def MOVLHPSrr : PSI<0x16, MRMSrcReg, (outs VR128:$dst),
                                       (ins VR128:$src1, VR128:$src2),
                      "movlhps\t{$src2, $dst|$dst, $src2}",
                      [(set VR128:$dst,
                        (v4f32 (X86Movlhps VR128:$src1, VR128:$src2)))],
                        IIC_SSE_MOV_LH>, Sched<[WriteShuffle]>;
  def MOVHLPSrr : PSI<0x12, MRMSrcReg, (outs VR128:$dst),
                                       (ins VR128:$src1, VR128:$src2),
                      "movhlps\t{$src2, $dst|$dst, $src2}",
                      [(set VR128:$dst,
                        (v4f32 (X86Movhlps VR128:$src1, VR128:$src2)))],
                        IIC_SSE_MOV_LH>, Sched<[WriteShuffle]>;
}

let Predicates = [HasAVX] in {
  // MOVLHPS patterns
  def : Pat<(v4i32 (X86Movlhps VR128:$src1, VR128:$src2)),
            (VMOVLHPSrr VR128:$src1, VR128:$src2)>;
  def : Pat<(v2i64 (X86Movlhps VR128:$src1, VR128:$src2)),
            (VMOVLHPSrr (v2i64 VR128:$src1), VR128:$src2)>;

  // MOVHLPS patterns
  def : Pat<(v4i32 (X86Movhlps VR128:$src1, VR128:$src2)),
            (VMOVHLPSrr VR128:$src1, VR128:$src2)>;
}

let Predicates = [UseSSE1] in {
  // MOVLHPS patterns
  def : Pat<(v4i32 (X86Movlhps VR128:$src1, VR128:$src2)),
            (MOVLHPSrr VR128:$src1, VR128:$src2)>;
  def : Pat<(v2i64 (X86Movlhps VR128:$src1, VR128:$src2)),
            (MOVLHPSrr (v2i64 VR128:$src1), VR128:$src2)>;

  // MOVHLPS patterns
  def : Pat<(v4i32 (X86Movhlps VR128:$src1, VR128:$src2)),
            (MOVHLPSrr VR128:$src1, VR128:$src2)>;
}

//===----------------------------------------------------------------------===//
// SSE 1 & 2 - Conversion Instructions
//===----------------------------------------------------------------------===//

def SSE_CVT_PD : OpndItins<
  IIC_SSE_CVT_PD_RR, IIC_SSE_CVT_PD_RM
>;

let Sched = WriteCvtI2F in
def SSE_CVT_PS : OpndItins<
  IIC_SSE_CVT_PS_RR, IIC_SSE_CVT_PS_RM
>;

let Sched = WriteCvtI2F in
def SSE_CVT_Scalar : OpndItins<
  IIC_SSE_CVT_Scalar_RR, IIC_SSE_CVT_Scalar_RM
>;

let Sched = WriteCvtF2I in
def SSE_CVT_SS2SI_32 : OpndItins<
  IIC_SSE_CVT_SS2SI32_RR, IIC_SSE_CVT_SS2SI32_RM
>;

let Sched = WriteCvtF2I in
def SSE_CVT_SS2SI_64 : OpndItins<
  IIC_SSE_CVT_SS2SI64_RR, IIC_SSE_CVT_SS2SI64_RM
>;

let Sched = WriteCvtF2I in
def SSE_CVT_SD2SI : OpndItins<
  IIC_SSE_CVT_SD2SI_RR, IIC_SSE_CVT_SD2SI_RM
>;

multiclass sse12_cvt_s<bits<8> opc, RegisterClass SrcRC, RegisterClass DstRC,
                     SDNode OpNode, X86MemOperand x86memop, PatFrag ld_frag,
                     string asm, OpndItins itins> {
  def rr : SI<opc, MRMSrcReg, (outs DstRC:$dst), (ins SrcRC:$src), asm,
                        [(set DstRC:$dst, (OpNode SrcRC:$src))],
                        itins.rr>, Sched<[itins.Sched]>;
  def rm : SI<opc, MRMSrcMem, (outs DstRC:$dst), (ins x86memop:$src), asm,
                        [(set DstRC:$dst, (OpNode (ld_frag addr:$src)))],
                        itins.rm>, Sched<[itins.Sched.Folded]>;
}

multiclass sse12_cvt_p<bits<8> opc, RegisterClass SrcRC, RegisterClass DstRC,
                       X86MemOperand x86memop, string asm, Domain d,
                       OpndItins itins> {
let neverHasSideEffects = 1 in {
  def rr : I<opc, MRMSrcReg, (outs DstRC:$dst), (ins SrcRC:$src), asm,
             [], itins.rr, d>, Sched<[itins.Sched]>;
  let mayLoad = 1 in
  def rm : I<opc, MRMSrcMem, (outs DstRC:$dst), (ins x86memop:$src), asm,
             [], itins.rm, d>, Sched<[itins.Sched.Folded]>;
}
}

multiclass sse12_vcvt_avx<bits<8> opc, RegisterClass SrcRC, RegisterClass DstRC,
                          X86MemOperand x86memop, string asm> {
let neverHasSideEffects = 1 in {
  def rr : SI<opc, MRMSrcReg, (outs DstRC:$dst), (ins DstRC:$src1, SrcRC:$src),
              !strconcat(asm,"\t{$src, $src1, $dst|$dst, $src1, $src}"), []>,
           Sched<[WriteCvtI2F]>;
  let mayLoad = 1 in
  def rm : SI<opc, MRMSrcMem, (outs DstRC:$dst),
              (ins DstRC:$src1, x86memop:$src),
              !strconcat(asm,"\t{$src, $src1, $dst|$dst, $src1, $src}"), []>,
           Sched<[WriteCvtI2FLd, ReadAfterLd]>;
} // neverHasSideEffects = 1
}

defm VCVTTSS2SI   : sse12_cvt_s<0x2C, FR32, GR32, fp_to_sint, f32mem, loadf32,
                                "cvttss2si\t{$src, $dst|$dst, $src}",
                                SSE_CVT_SS2SI_32>,
                                XS, VEX, VEX_LIG;
defm VCVTTSS2SI64 : sse12_cvt_s<0x2C, FR32, GR64, fp_to_sint, f32mem, loadf32,
                                "cvttss2si\t{$src, $dst|$dst, $src}",
                                SSE_CVT_SS2SI_64>,
                                XS, VEX, VEX_W, VEX_LIG;
defm VCVTTSD2SI   : sse12_cvt_s<0x2C, FR64, GR32, fp_to_sint, f64mem, loadf64,
                                "cvttsd2si\t{$src, $dst|$dst, $src}",
                                SSE_CVT_SD2SI>,
                                XD, VEX, VEX_LIG;
defm VCVTTSD2SI64 : sse12_cvt_s<0x2C, FR64, GR64, fp_to_sint, f64mem, loadf64,
                                "cvttsd2si\t{$src, $dst|$dst, $src}",
                                SSE_CVT_SD2SI>,
                                XD, VEX, VEX_W, VEX_LIG;

def : InstAlias<"vcvttss2si{l}\t{$src, $dst|$dst, $src}",
                (VCVTTSS2SIrr GR32:$dst, FR32:$src), 0>;
def : InstAlias<"vcvttss2si{l}\t{$src, $dst|$dst, $src}",
                (VCVTTSS2SIrm GR32:$dst, f32mem:$src), 0>;
def : InstAlias<"vcvttsd2si{l}\t{$src, $dst|$dst, $src}",
                (VCVTTSD2SIrr GR32:$dst, FR64:$src), 0>;
def : InstAlias<"vcvttsd2si{l}\t{$src, $dst|$dst, $src}",
                (VCVTTSD2SIrm GR32:$dst, f64mem:$src), 0>;
def : InstAlias<"vcvttss2si{q}\t{$src, $dst|$dst, $src}",
                (VCVTTSS2SI64rr GR64:$dst, FR32:$src), 0>;
def : InstAlias<"vcvttss2si{q}\t{$src, $dst|$dst, $src}",
                (VCVTTSS2SI64rm GR64:$dst, f32mem:$src), 0>;
def : InstAlias<"vcvttsd2si{q}\t{$src, $dst|$dst, $src}",
                (VCVTTSD2SI64rr GR64:$dst, FR64:$src), 0>;
def : InstAlias<"vcvttsd2si{q}\t{$src, $dst|$dst, $src}",
                (VCVTTSD2SI64rm GR64:$dst, f64mem:$src), 0>;

// The assembler can recognize rr 64-bit instructions by seeing a rxx
// register, but the same isn't true when only using memory operands,
// provide other assembly "l" and "q" forms to address this explicitly
// where appropriate to do so.
defm VCVTSI2SS   : sse12_vcvt_avx<0x2A, GR32, FR32, i32mem, "cvtsi2ss{l}">,
                                  XS, VEX_4V, VEX_LIG;
defm VCVTSI2SS64 : sse12_vcvt_avx<0x2A, GR64, FR32, i64mem, "cvtsi2ss{q}">,
                                  XS, VEX_4V, VEX_W, VEX_LIG;
defm VCVTSI2SD   : sse12_vcvt_avx<0x2A, GR32, FR64, i32mem, "cvtsi2sd{l}">,
                                  XD, VEX_4V, VEX_LIG;
defm VCVTSI2SD64 : sse12_vcvt_avx<0x2A, GR64, FR64, i64mem, "cvtsi2sd{q}">,
                                  XD, VEX_4V, VEX_W, VEX_LIG;

def : InstAlias<"vcvtsi2ss\t{$src, $src1, $dst|$dst, $src1, $src}",
                (VCVTSI2SSrm FR64:$dst, FR64:$src1, i32mem:$src)>;
def : InstAlias<"vcvtsi2sd\t{$src, $src1, $dst|$dst, $src1, $src}",
                (VCVTSI2SDrm FR64:$dst, FR64:$src1, i32mem:$src)>;

let Predicates = [HasAVX] in {
  def : Pat<(f32 (sint_to_fp (loadi32 addr:$src))),
            (VCVTSI2SSrm (f32 (IMPLICIT_DEF)), addr:$src)>;
  def : Pat<(f32 (sint_to_fp (loadi64 addr:$src))),
            (VCVTSI2SS64rm (f32 (IMPLICIT_DEF)), addr:$src)>;
  def : Pat<(f64 (sint_to_fp (loadi32 addr:$src))),
            (VCVTSI2SDrm (f64 (IMPLICIT_DEF)), addr:$src)>;
  def : Pat<(f64 (sint_to_fp (loadi64 addr:$src))),
            (VCVTSI2SD64rm (f64 (IMPLICIT_DEF)), addr:$src)>;

  def : Pat<(f32 (sint_to_fp GR32:$src)),
            (VCVTSI2SSrr (f32 (IMPLICIT_DEF)), GR32:$src)>;
  def : Pat<(f32 (sint_to_fp GR64:$src)),
            (VCVTSI2SS64rr (f32 (IMPLICIT_DEF)), GR64:$src)>;
  def : Pat<(f64 (sint_to_fp GR32:$src)),
            (VCVTSI2SDrr (f64 (IMPLICIT_DEF)), GR32:$src)>;
  def : Pat<(f64 (sint_to_fp GR64:$src)),
            (VCVTSI2SD64rr (f64 (IMPLICIT_DEF)), GR64:$src)>;
}

defm CVTTSS2SI : sse12_cvt_s<0x2C, FR32, GR32, fp_to_sint, f32mem, loadf32,
                      "cvttss2si\t{$src, $dst|$dst, $src}",
                      SSE_CVT_SS2SI_32>, XS;
defm CVTTSS2SI64 : sse12_cvt_s<0x2C, FR32, GR64, fp_to_sint, f32mem, loadf32,
                      "cvttss2si\t{$src, $dst|$dst, $src}",
                      SSE_CVT_SS2SI_64>, XS, REX_W;
defm CVTTSD2SI : sse12_cvt_s<0x2C, FR64, GR32, fp_to_sint, f64mem, loadf64,
                      "cvttsd2si\t{$src, $dst|$dst, $src}",
                      SSE_CVT_SD2SI>, XD;
defm CVTTSD2SI64 : sse12_cvt_s<0x2C, FR64, GR64, fp_to_sint, f64mem, loadf64,
                      "cvttsd2si\t{$src, $dst|$dst, $src}",
                      SSE_CVT_SD2SI>, XD, REX_W;
defm CVTSI2SS  : sse12_cvt_s<0x2A, GR32, FR32, sint_to_fp, i32mem, loadi32,
                      "cvtsi2ss{l}\t{$src, $dst|$dst, $src}",
                      SSE_CVT_Scalar>, XS;
defm CVTSI2SS64 : sse12_cvt_s<0x2A, GR64, FR32, sint_to_fp, i64mem, loadi64,
                      "cvtsi2ss{q}\t{$src, $dst|$dst, $src}",
                      SSE_CVT_Scalar>, XS, REX_W;
defm CVTSI2SD  : sse12_cvt_s<0x2A, GR32, FR64, sint_to_fp, i32mem, loadi32,
                      "cvtsi2sd{l}\t{$src, $dst|$dst, $src}",
                      SSE_CVT_Scalar>, XD;
defm CVTSI2SD64 : sse12_cvt_s<0x2A, GR64, FR64, sint_to_fp, i64mem, loadi64,
                      "cvtsi2sd{q}\t{$src, $dst|$dst, $src}",
                      SSE_CVT_Scalar>, XD, REX_W;

def : InstAlias<"cvttss2si{l}\t{$src, $dst|$dst, $src}",
                (CVTTSS2SIrr GR32:$dst, FR32:$src), 0>;
def : InstAlias<"cvttss2si{l}\t{$src, $dst|$dst, $src}",
                (CVTTSS2SIrm GR32:$dst, f32mem:$src), 0>;
def : InstAlias<"cvttsd2si{l}\t{$src, $dst|$dst, $src}",
                (CVTTSD2SIrr GR32:$dst, FR64:$src), 0>;
def : InstAlias<"cvttsd2si{l}\t{$src, $dst|$dst, $src}",
                (CVTTSD2SIrm GR32:$dst, f64mem:$src), 0>;
def : InstAlias<"cvttss2si{q}\t{$src, $dst|$dst, $src}",
                (CVTTSS2SI64rr GR64:$dst, FR32:$src), 0>;
def : InstAlias<"cvttss2si{q}\t{$src, $dst|$dst, $src}",
                (CVTTSS2SI64rm GR64:$dst, f32mem:$src), 0>;
def : InstAlias<"cvttsd2si{q}\t{$src, $dst|$dst, $src}",
                (CVTTSD2SI64rr GR64:$dst, FR64:$src), 0>;
def : InstAlias<"cvttsd2si{q}\t{$src, $dst|$dst, $src}",
                (CVTTSD2SI64rm GR64:$dst, f64mem:$src), 0>;

def : InstAlias<"cvtsi2ss\t{$src, $dst|$dst, $src}",
                (CVTSI2SSrm FR64:$dst, i32mem:$src)>;
def : InstAlias<"cvtsi2sd\t{$src, $dst|$dst, $src}",
                (CVTSI2SDrm FR64:$dst, i32mem:$src)>;

// Conversion Instructions Intrinsics - Match intrinsics which expect MM
// and/or XMM operand(s).

multiclass sse12_cvt_sint<bits<8> opc, RegisterClass SrcRC, RegisterClass DstRC,
                         Intrinsic Int, Operand memop, ComplexPattern mem_cpat,
                         string asm, OpndItins itins> {
  def rr : SI<opc, MRMSrcReg, (outs DstRC:$dst), (ins SrcRC:$src),
              !strconcat(asm, "\t{$src, $dst|$dst, $src}"),
              [(set DstRC:$dst, (Int SrcRC:$src))], itins.rr>,
           Sched<[itins.Sched]>;
  def rm : SI<opc, MRMSrcMem, (outs DstRC:$dst), (ins memop:$src),
              !strconcat(asm, "\t{$src, $dst|$dst, $src}"),
              [(set DstRC:$dst, (Int mem_cpat:$src))], itins.rm>,
           Sched<[itins.Sched.Folded]>;
}

multiclass sse12_cvt_sint_3addr<bits<8> opc, RegisterClass SrcRC,
                    RegisterClass DstRC, Intrinsic Int, X86MemOperand x86memop,
                    PatFrag ld_frag, string asm, OpndItins itins,
                    bit Is2Addr = 1> {
  def rr : SI<opc, MRMSrcReg, (outs DstRC:$dst), (ins DstRC:$src1, SrcRC:$src2),
              !if(Is2Addr,
                  !strconcat(asm, "\t{$src2, $dst|$dst, $src2}"),
                  !strconcat(asm, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
              [(set DstRC:$dst, (Int DstRC:$src1, SrcRC:$src2))],
              itins.rr>, Sched<[itins.Sched]>;
  def rm : SI<opc, MRMSrcMem, (outs DstRC:$dst),
              (ins DstRC:$src1, x86memop:$src2),
              !if(Is2Addr,
                  !strconcat(asm, "\t{$src2, $dst|$dst, $src2}"),
                  !strconcat(asm, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
              [(set DstRC:$dst, (Int DstRC:$src1, (ld_frag addr:$src2)))],
              itins.rm>, Sched<[itins.Sched.Folded, ReadAfterLd]>;
}

defm VCVTSD2SI : sse12_cvt_sint<0x2D, VR128, GR32,
                  int_x86_sse2_cvtsd2si, sdmem, sse_load_f64, "cvtsd2si",
                  SSE_CVT_SD2SI>, XD, VEX, VEX_LIG;
defm VCVTSD2SI64 : sse12_cvt_sint<0x2D, VR128, GR64,
                    int_x86_sse2_cvtsd2si64, sdmem, sse_load_f64, "cvtsd2si",
                    SSE_CVT_SD2SI>, XD, VEX, VEX_W, VEX_LIG;

defm CVTSD2SI : sse12_cvt_sint<0x2D, VR128, GR32, int_x86_sse2_cvtsd2si,
                 sdmem, sse_load_f64, "cvtsd2si", SSE_CVT_SD2SI>, XD;
defm CVTSD2SI64 : sse12_cvt_sint<0x2D, VR128, GR64, int_x86_sse2_cvtsd2si64,
                   sdmem, sse_load_f64, "cvtsd2si", SSE_CVT_SD2SI>, XD, REX_W;


defm Int_VCVTSI2SS : sse12_cvt_sint_3addr<0x2A, GR32, VR128,
          int_x86_sse_cvtsi2ss, i32mem, loadi32, "cvtsi2ss{l}",
          SSE_CVT_Scalar, 0>, XS, VEX_4V;
defm Int_VCVTSI2SS64 : sse12_cvt_sint_3addr<0x2A, GR64, VR128,
          int_x86_sse_cvtsi642ss, i64mem, loadi64, "cvtsi2ss{q}",
          SSE_CVT_Scalar, 0>, XS, VEX_4V,
          VEX_W;
defm Int_VCVTSI2SD : sse12_cvt_sint_3addr<0x2A, GR32, VR128,
          int_x86_sse2_cvtsi2sd, i32mem, loadi32, "cvtsi2sd{l}",
          SSE_CVT_Scalar, 0>, XD, VEX_4V;
defm Int_VCVTSI2SD64 : sse12_cvt_sint_3addr<0x2A, GR64, VR128,
          int_x86_sse2_cvtsi642sd, i64mem, loadi64, "cvtsi2sd{q}",
          SSE_CVT_Scalar, 0>, XD,
          VEX_4V, VEX_W;

let Constraints = "$src1 = $dst" in {
  defm Int_CVTSI2SS : sse12_cvt_sint_3addr<0x2A, GR32, VR128,
                        int_x86_sse_cvtsi2ss, i32mem, loadi32,
                        "cvtsi2ss{l}", SSE_CVT_Scalar>, XS;
  defm Int_CVTSI2SS64 : sse12_cvt_sint_3addr<0x2A, GR64, VR128,
                        int_x86_sse_cvtsi642ss, i64mem, loadi64,
                        "cvtsi2ss{q}", SSE_CVT_Scalar>, XS, REX_W;
  defm Int_CVTSI2SD : sse12_cvt_sint_3addr<0x2A, GR32, VR128,
                        int_x86_sse2_cvtsi2sd, i32mem, loadi32,
                        "cvtsi2sd{l}", SSE_CVT_Scalar>, XD;
  defm Int_CVTSI2SD64 : sse12_cvt_sint_3addr<0x2A, GR64, VR128,
                        int_x86_sse2_cvtsi642sd, i64mem, loadi64,
                        "cvtsi2sd{q}", SSE_CVT_Scalar>, XD, REX_W;
}

/// SSE 1 Only

// Aliases for intrinsics
defm Int_VCVTTSS2SI : sse12_cvt_sint<0x2C, VR128, GR32, int_x86_sse_cvttss2si,
                                    ssmem, sse_load_f32, "cvttss2si",
                                    SSE_CVT_SS2SI_32>, XS, VEX;
defm Int_VCVTTSS2SI64 : sse12_cvt_sint<0x2C, VR128, GR64,
                                   int_x86_sse_cvttss2si64, ssmem, sse_load_f32,
                                   "cvttss2si", SSE_CVT_SS2SI_64>,
                                   XS, VEX, VEX_W;
defm Int_VCVTTSD2SI : sse12_cvt_sint<0x2C, VR128, GR32, int_x86_sse2_cvttsd2si,
                                    sdmem, sse_load_f64, "cvttsd2si",
                                    SSE_CVT_SD2SI>, XD, VEX;
defm Int_VCVTTSD2SI64 : sse12_cvt_sint<0x2C, VR128, GR64,
                                  int_x86_sse2_cvttsd2si64, sdmem, sse_load_f64,
                                  "cvttsd2si", SSE_CVT_SD2SI>,
                                  XD, VEX, VEX_W;
defm Int_CVTTSS2SI : sse12_cvt_sint<0x2C, VR128, GR32, int_x86_sse_cvttss2si,
                                    ssmem, sse_load_f32, "cvttss2si",
                                    SSE_CVT_SS2SI_32>, XS;
defm Int_CVTTSS2SI64 : sse12_cvt_sint<0x2C, VR128, GR64,
                                   int_x86_sse_cvttss2si64, ssmem, sse_load_f32,
                                   "cvttss2si", SSE_CVT_SS2SI_64>, XS, REX_W;
defm Int_CVTTSD2SI : sse12_cvt_sint<0x2C, VR128, GR32, int_x86_sse2_cvttsd2si,
                                    sdmem, sse_load_f64, "cvttsd2si",
                                    SSE_CVT_SD2SI>, XD;
defm Int_CVTTSD2SI64 : sse12_cvt_sint<0x2C, VR128, GR64,
                                  int_x86_sse2_cvttsd2si64, sdmem, sse_load_f64,
                                  "cvttsd2si", SSE_CVT_SD2SI>, XD, REX_W;

defm VCVTSS2SI   : sse12_cvt_sint<0x2D, VR128, GR32, int_x86_sse_cvtss2si,
                                  ssmem, sse_load_f32, "cvtss2si",
                                  SSE_CVT_SS2SI_32>, XS, VEX, VEX_LIG;
defm VCVTSS2SI64 : sse12_cvt_sint<0x2D, VR128, GR64, int_x86_sse_cvtss2si64,
                                  ssmem, sse_load_f32, "cvtss2si",
                                  SSE_CVT_SS2SI_64>, XS, VEX, VEX_W, VEX_LIG;

defm CVTSS2SI : sse12_cvt_sint<0x2D, VR128, GR32, int_x86_sse_cvtss2si,
                               ssmem, sse_load_f32, "cvtss2si",
                               SSE_CVT_SS2SI_32>, XS;
defm CVTSS2SI64 : sse12_cvt_sint<0x2D, VR128, GR64, int_x86_sse_cvtss2si64,
                                 ssmem, sse_load_f32, "cvtss2si",
                                 SSE_CVT_SS2SI_64>, XS, REX_W;

defm VCVTDQ2PS   : sse12_cvt_p<0x5B, VR128, VR128, i128mem,
                               "vcvtdq2ps\t{$src, $dst|$dst, $src}",
                               SSEPackedSingle, SSE_CVT_PS>,
                               TB, VEX, Requires<[HasAVX]>;
defm VCVTDQ2PSY  : sse12_cvt_p<0x5B, VR256, VR256, i256mem,
                               "vcvtdq2ps\t{$src, $dst|$dst, $src}",
                               SSEPackedSingle, SSE_CVT_PS>,
                               TB, VEX, VEX_L, Requires<[HasAVX]>;

defm CVTDQ2PS : sse12_cvt_p<0x5B, VR128, VR128, i128mem,
                            "cvtdq2ps\t{$src, $dst|$dst, $src}",
                            SSEPackedSingle, SSE_CVT_PS>,
                            TB, Requires<[UseSSE2]>;

def : InstAlias<"vcvtss2si{l}\t{$src, $dst|$dst, $src}",
                (VCVTSS2SIrr GR32:$dst, VR128:$src), 0>;
def : InstAlias<"vcvtss2si{l}\t{$src, $dst|$dst, $src}",
                (VCVTSS2SIrm GR32:$dst, ssmem:$src), 0>;
def : InstAlias<"vcvtsd2si{l}\t{$src, $dst|$dst, $src}",
                (VCVTSD2SIrr GR32:$dst, VR128:$src), 0>;
def : InstAlias<"vcvtsd2si{l}\t{$src, $dst|$dst, $src}",
                (VCVTSD2SIrm GR32:$dst, sdmem:$src), 0>;
def : InstAlias<"vcvtss2si{q}\t{$src, $dst|$dst, $src}",
                (VCVTSS2SI64rr GR64:$dst, VR128:$src), 0>;
def : InstAlias<"vcvtss2si{q}\t{$src, $dst|$dst, $src}",
                (VCVTSS2SI64rm GR64:$dst, ssmem:$src), 0>;
def : InstAlias<"vcvtsd2si{q}\t{$src, $dst|$dst, $src}",
                (VCVTSD2SI64rr GR64:$dst, VR128:$src), 0>;
def : InstAlias<"vcvtsd2si{q}\t{$src, $dst|$dst, $src}",
                (VCVTSD2SI64rm GR64:$dst, sdmem:$src), 0>;

def : InstAlias<"cvtss2si{l}\t{$src, $dst|$dst, $src}",
                (CVTSS2SIrr GR32:$dst, VR128:$src), 0>;
def : InstAlias<"cvtss2si{l}\t{$src, $dst|$dst, $src}",
                (CVTSS2SIrm GR32:$dst, ssmem:$src), 0>;
def : InstAlias<"cvtsd2si{l}\t{$src, $dst|$dst, $src}",
                (CVTSD2SIrr GR32:$dst, VR128:$src), 0>;
def : InstAlias<"cvtsd2si{l}\t{$src, $dst|$dst, $src}",
                (CVTSD2SIrm GR32:$dst, sdmem:$src), 0>;
def : InstAlias<"cvtss2si{q}\t{$src, $dst|$dst, $src}",
                (CVTSS2SI64rr GR64:$dst, VR128:$src), 0>;
def : InstAlias<"cvtss2si{q}\t{$src, $dst|$dst, $src}",
                (CVTSS2SI64rm GR64:$dst, ssmem:$src), 0>;
def : InstAlias<"cvtsd2si{q}\t{$src, $dst|$dst, $src}",
                (CVTSD2SI64rr GR64:$dst, VR128:$src), 0>;
def : InstAlias<"cvtsd2si{q}\t{$src, $dst|$dst, $src}",
                (CVTSD2SI64rm GR64:$dst, sdmem:$src)>;

/// SSE 2 Only

// Convert scalar double to scalar single
let neverHasSideEffects = 1 in {
def VCVTSD2SSrr  : VSDI<0x5A, MRMSrcReg, (outs FR32:$dst),
                       (ins FR64:$src1, FR64:$src2),
                      "cvtsd2ss\t{$src2, $src1, $dst|$dst, $src1, $src2}", [],
                      IIC_SSE_CVT_Scalar_RR>, VEX_4V, VEX_LIG,
                      Sched<[WriteCvtF2F]>;
let mayLoad = 1 in
def VCVTSD2SSrm  : I<0x5A, MRMSrcMem, (outs FR32:$dst),
                       (ins FR64:$src1, f64mem:$src2),
                      "vcvtsd2ss\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                      [], IIC_SSE_CVT_Scalar_RM>,
                      XD, Requires<[HasAVX, OptForSize]>, VEX_4V, VEX_LIG,
                      Sched<[WriteCvtF2FLd, ReadAfterLd]>;
}

def : Pat<(f32 (fround FR64:$src)), (VCVTSD2SSrr FR64:$src, FR64:$src)>,
          Requires<[HasAVX]>;

def CVTSD2SSrr  : SDI<0x5A, MRMSrcReg, (outs FR32:$dst), (ins FR64:$src),
                      "cvtsd2ss\t{$src, $dst|$dst, $src}",
                      [(set FR32:$dst, (fround FR64:$src))],
                      IIC_SSE_CVT_Scalar_RR>, Sched<[WriteCvtF2F]>;
def CVTSD2SSrm  : I<0x5A, MRMSrcMem, (outs FR32:$dst), (ins f64mem:$src),
                      "cvtsd2ss\t{$src, $dst|$dst, $src}",
                      [(set FR32:$dst, (fround (loadf64 addr:$src)))],
                      IIC_SSE_CVT_Scalar_RM>,
                      XD,
                  Requires<[UseSSE2, OptForSize]>, Sched<[WriteCvtF2FLd]>;

def Int_VCVTSD2SSrr: I<0x5A, MRMSrcReg,
                       (outs VR128:$dst), (ins VR128:$src1, VR128:$src2),
                       "vcvtsd2ss\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                       [(set VR128:$dst,
                         (int_x86_sse2_cvtsd2ss VR128:$src1, VR128:$src2))],
                       IIC_SSE_CVT_Scalar_RR>, XD, VEX_4V, Requires<[HasAVX]>,
                       Sched<[WriteCvtF2F]>;
def Int_VCVTSD2SSrm: I<0x5A, MRMSrcReg,
                       (outs VR128:$dst), (ins VR128:$src1, sdmem:$src2),
                       "vcvtsd2ss\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                       [(set VR128:$dst, (int_x86_sse2_cvtsd2ss
                                          VR128:$src1, sse_load_f64:$src2))],
                       IIC_SSE_CVT_Scalar_RM>, XD, VEX_4V, Requires<[HasAVX]>,
                       Sched<[WriteCvtF2FLd, ReadAfterLd]>;

let Constraints = "$src1 = $dst" in {
def Int_CVTSD2SSrr: I<0x5A, MRMSrcReg,
                       (outs VR128:$dst), (ins VR128:$src1, VR128:$src2),
                       "cvtsd2ss\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                       [(set VR128:$dst,
                         (int_x86_sse2_cvtsd2ss VR128:$src1, VR128:$src2))],
                       IIC_SSE_CVT_Scalar_RR>, XD, Requires<[UseSSE2]>,
                       Sched<[WriteCvtF2F]>;
def Int_CVTSD2SSrm: I<0x5A, MRMSrcReg,
                       (outs VR128:$dst), (ins VR128:$src1, sdmem:$src2),
                       "cvtsd2ss\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                       [(set VR128:$dst, (int_x86_sse2_cvtsd2ss
                                          VR128:$src1, sse_load_f64:$src2))],
                       IIC_SSE_CVT_Scalar_RM>, XD, Requires<[UseSSE2]>,
                       Sched<[WriteCvtF2FLd, ReadAfterLd]>;
}

// Convert scalar single to scalar double
// SSE2 instructions with XS prefix
let neverHasSideEffects = 1 in {
def VCVTSS2SDrr : I<0x5A, MRMSrcReg, (outs FR64:$dst),
                    (ins FR32:$src1, FR32:$src2),
                    "vcvtss2sd\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                    [], IIC_SSE_CVT_Scalar_RR>,
                    XS, Requires<[HasAVX]>, VEX_4V, VEX_LIG,
                    Sched<[WriteCvtF2F]>;
let mayLoad = 1 in
def VCVTSS2SDrm : I<0x5A, MRMSrcMem, (outs FR64:$dst),
                    (ins FR32:$src1, f32mem:$src2),
                    "vcvtss2sd\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                    [], IIC_SSE_CVT_Scalar_RM>,
                    XS, VEX_4V, VEX_LIG, Requires<[HasAVX, OptForSize]>,
                    Sched<[WriteCvtF2FLd, ReadAfterLd]>;
}

def : Pat<(f64 (fextend FR32:$src)),
    (VCVTSS2SDrr FR32:$src, FR32:$src)>, Requires<[HasAVX]>;
def : Pat<(fextend (loadf32 addr:$src)),
    (VCVTSS2SDrm (f32 (IMPLICIT_DEF)), addr:$src)>, Requires<[HasAVX]>;

def : Pat<(extloadf32 addr:$src),
    (VCVTSS2SDrm (f32 (IMPLICIT_DEF)), addr:$src)>,
    Requires<[HasAVX, OptForSize]>;
def : Pat<(extloadf32 addr:$src),
    (VCVTSS2SDrr (f32 (IMPLICIT_DEF)), (VMOVSSrm addr:$src))>,
    Requires<[HasAVX, OptForSpeed]>;

def CVTSS2SDrr : I<0x5A, MRMSrcReg, (outs FR64:$dst), (ins FR32:$src),
                   "cvtss2sd\t{$src, $dst|$dst, $src}",
                   [(set FR64:$dst, (fextend FR32:$src))],
                   IIC_SSE_CVT_Scalar_RR>, XS,
                 Requires<[UseSSE2]>, Sched<[WriteCvtF2F]>;
def CVTSS2SDrm : I<0x5A, MRMSrcMem, (outs FR64:$dst), (ins f32mem:$src),
                   "cvtss2sd\t{$src, $dst|$dst, $src}",
                   [(set FR64:$dst, (extloadf32 addr:$src))],
                   IIC_SSE_CVT_Scalar_RM>, XS,
                 Requires<[UseSSE2, OptForSize]>, Sched<[WriteCvtF2FLd]>;

// extload f32 -> f64.  This matches load+fextend because we have a hack in
// the isel (PreprocessForFPConvert) that can introduce loads after dag
// combine.
// Since these loads aren't folded into the fextend, we have to match it
// explicitly here.
def : Pat<(fextend (loadf32 addr:$src)),
          (CVTSS2SDrm addr:$src)>, Requires<[UseSSE2]>;
def : Pat<(extloadf32 addr:$src),
          (CVTSS2SDrr (MOVSSrm addr:$src))>, Requires<[UseSSE2, OptForSpeed]>;

def Int_VCVTSS2SDrr: I<0x5A, MRMSrcReg,
                      (outs VR128:$dst), (ins VR128:$src1, VR128:$src2),
                    "vcvtss2sd\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                    [(set VR128:$dst,
                      (int_x86_sse2_cvtss2sd VR128:$src1, VR128:$src2))],
                    IIC_SSE_CVT_Scalar_RR>, XS, VEX_4V, Requires<[HasAVX]>,
                    Sched<[WriteCvtF2F]>;
def Int_VCVTSS2SDrm: I<0x5A, MRMSrcMem,
                      (outs VR128:$dst), (ins VR128:$src1, ssmem:$src2),
                    "vcvtss2sd\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                    [(set VR128:$dst,
                      (int_x86_sse2_cvtss2sd VR128:$src1, sse_load_f32:$src2))],
                    IIC_SSE_CVT_Scalar_RM>, XS, VEX_4V, Requires<[HasAVX]>,
                    Sched<[WriteCvtF2FLd, ReadAfterLd]>;
let Constraints = "$src1 = $dst" in { // SSE2 instructions with XS prefix
def Int_CVTSS2SDrr: I<0x5A, MRMSrcReg,
                      (outs VR128:$dst), (ins VR128:$src1, VR128:$src2),
                    "cvtss2sd\t{$src2, $dst|$dst, $src2}",
                    [(set VR128:$dst,
                      (int_x86_sse2_cvtss2sd VR128:$src1, VR128:$src2))],
                    IIC_SSE_CVT_Scalar_RR>, XS, Requires<[UseSSE2]>,
                    Sched<[WriteCvtF2F]>;
def Int_CVTSS2SDrm: I<0x5A, MRMSrcMem,
                      (outs VR128:$dst), (ins VR128:$src1, ssmem:$src2),
                    "cvtss2sd\t{$src2, $dst|$dst, $src2}",
                    [(set VR128:$dst,
                      (int_x86_sse2_cvtss2sd VR128:$src1, sse_load_f32:$src2))],
                    IIC_SSE_CVT_Scalar_RM>, XS, Requires<[UseSSE2]>,
                    Sched<[WriteCvtF2FLd, ReadAfterLd]>;
}

// Convert packed single/double fp to doubleword
def VCVTPS2DQrr : VPDI<0x5B, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                       "cvtps2dq\t{$src, $dst|$dst, $src}",
                       [(set VR128:$dst, (int_x86_sse2_cvtps2dq VR128:$src))],
                       IIC_SSE_CVT_PS_RR>, VEX, Sched<[WriteCvtF2I]>;
def VCVTPS2DQrm : VPDI<0x5B, MRMSrcMem, (outs VR128:$dst), (ins f128mem:$src),
                       "cvtps2dq\t{$src, $dst|$dst, $src}",
                       [(set VR128:$dst,
                         (int_x86_sse2_cvtps2dq (memopv4f32 addr:$src)))],
                       IIC_SSE_CVT_PS_RM>, VEX, Sched<[WriteCvtF2ILd]>;
def VCVTPS2DQYrr : VPDI<0x5B, MRMSrcReg, (outs VR256:$dst), (ins VR256:$src),
                        "cvtps2dq\t{$src, $dst|$dst, $src}",
                        [(set VR256:$dst,
                          (int_x86_avx_cvt_ps2dq_256 VR256:$src))],
                        IIC_SSE_CVT_PS_RR>, VEX, VEX_L, Sched<[WriteCvtF2I]>;
def VCVTPS2DQYrm : VPDI<0x5B, MRMSrcMem, (outs VR256:$dst), (ins f256mem:$src),
                        "cvtps2dq\t{$src, $dst|$dst, $src}",
                        [(set VR256:$dst,
                          (int_x86_avx_cvt_ps2dq_256 (memopv8f32 addr:$src)))],
                        IIC_SSE_CVT_PS_RM>, VEX, VEX_L, Sched<[WriteCvtF2ILd]>;
def CVTPS2DQrr : PDI<0x5B, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                     "cvtps2dq\t{$src, $dst|$dst, $src}",
                     [(set VR128:$dst, (int_x86_sse2_cvtps2dq VR128:$src))],
                     IIC_SSE_CVT_PS_RR>, Sched<[WriteCvtF2I]>;
def CVTPS2DQrm : PDI<0x5B, MRMSrcMem, (outs VR128:$dst), (ins f128mem:$src),
                     "cvtps2dq\t{$src, $dst|$dst, $src}",
                     [(set VR128:$dst,
                       (int_x86_sse2_cvtps2dq (memopv4f32 addr:$src)))],
                     IIC_SSE_CVT_PS_RM>, Sched<[WriteCvtF2ILd]>;


// Convert Packed Double FP to Packed DW Integers
let Predicates = [HasAVX] in {
// The assembler can recognize rr 256-bit instructions by seeing a ymm
// register, but the same isn't true when using memory operands instead.
// Provide other assembly rr and rm forms to address this explicitly.
def VCVTPD2DQrr  : SDI<0xE6, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                       "vcvtpd2dq\t{$src, $dst|$dst, $src}",
                       [(set VR128:$dst, (int_x86_sse2_cvtpd2dq VR128:$src))]>,
                       VEX, Sched<[WriteCvtF2I]>;

// XMM only
def : InstAlias<"vcvtpd2dqx\t{$src, $dst|$dst, $src}",
                (VCVTPD2DQrr VR128:$dst, VR128:$src)>;
def VCVTPD2DQXrm : SDI<0xE6, MRMSrcMem, (outs VR128:$dst), (ins f128mem:$src),
                       "vcvtpd2dqx\t{$src, $dst|$dst, $src}",
                       [(set VR128:$dst,
                         (int_x86_sse2_cvtpd2dq (memopv2f64 addr:$src)))]>, VEX,
                       Sched<[WriteCvtF2ILd]>;

// YMM only
def VCVTPD2DQYrr : SDI<0xE6, MRMSrcReg, (outs VR128:$dst), (ins VR256:$src),
                       "vcvtpd2dq{y}\t{$src, $dst|$dst, $src}",
                       [(set VR128:$dst,
                         (int_x86_avx_cvt_pd2dq_256 VR256:$src))]>, VEX, VEX_L,
                       Sched<[WriteCvtF2I]>;
def VCVTPD2DQYrm : SDI<0xE6, MRMSrcMem, (outs VR128:$dst), (ins f256mem:$src),
                       "vcvtpd2dq{y}\t{$src, $dst|$dst, $src}",
                       [(set VR128:$dst,
                         (int_x86_avx_cvt_pd2dq_256 (memopv4f64 addr:$src)))]>,
                       VEX, VEX_L, Sched<[WriteCvtF2ILd]>;
def : InstAlias<"vcvtpd2dq\t{$src, $dst|$dst, $src}",
                (VCVTPD2DQYrr VR128:$dst, VR256:$src)>;
}

def CVTPD2DQrm  : SDI<0xE6, MRMSrcMem, (outs VR128:$dst), (ins f128mem:$src),
                      "cvtpd2dq\t{$src, $dst|$dst, $src}",
                      [(set VR128:$dst,
                        (int_x86_sse2_cvtpd2dq (memopv2f64 addr:$src)))],
                      IIC_SSE_CVT_PD_RM>, Sched<[WriteCvtF2ILd]>;
def CVTPD2DQrr  : SDI<0xE6, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                      "cvtpd2dq\t{$src, $dst|$dst, $src}",
                      [(set VR128:$dst, (int_x86_sse2_cvtpd2dq VR128:$src))],
                      IIC_SSE_CVT_PD_RR>, Sched<[WriteCvtF2I]>;

// Convert with truncation packed single/double fp to doubleword
// SSE2 packed instructions with XS prefix
def VCVTTPS2DQrr : VS2SI<0x5B, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                         "cvttps2dq\t{$src, $dst|$dst, $src}",
                         [(set VR128:$dst,
                           (int_x86_sse2_cvttps2dq VR128:$src))],
                         IIC_SSE_CVT_PS_RR>, VEX, Sched<[WriteCvtF2I]>;
def VCVTTPS2DQrm : VS2SI<0x5B, MRMSrcMem, (outs VR128:$dst), (ins f128mem:$src),
                         "cvttps2dq\t{$src, $dst|$dst, $src}",
                         [(set VR128:$dst, (int_x86_sse2_cvttps2dq
                                            (memopv4f32 addr:$src)))],
                         IIC_SSE_CVT_PS_RM>, VEX, Sched<[WriteCvtF2ILd]>;
def VCVTTPS2DQYrr : VS2SI<0x5B, MRMSrcReg, (outs VR256:$dst), (ins VR256:$src),
                          "cvttps2dq\t{$src, $dst|$dst, $src}",
                          [(set VR256:$dst,
                            (int_x86_avx_cvtt_ps2dq_256 VR256:$src))],
                          IIC_SSE_CVT_PS_RR>, VEX, VEX_L, Sched<[WriteCvtF2I]>;
def VCVTTPS2DQYrm : VS2SI<0x5B, MRMSrcMem, (outs VR256:$dst), (ins f256mem:$src),
                          "cvttps2dq\t{$src, $dst|$dst, $src}",
                          [(set VR256:$dst, (int_x86_avx_cvtt_ps2dq_256
                                             (memopv8f32 addr:$src)))],
                          IIC_SSE_CVT_PS_RM>, VEX, VEX_L,
                          Sched<[WriteCvtF2ILd]>;

def CVTTPS2DQrr : S2SI<0x5B, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                       "cvttps2dq\t{$src, $dst|$dst, $src}",
                       [(set VR128:$dst, (int_x86_sse2_cvttps2dq VR128:$src))],
                       IIC_SSE_CVT_PS_RR>, Sched<[WriteCvtF2I]>;
def CVTTPS2DQrm : S2SI<0x5B, MRMSrcMem, (outs VR128:$dst), (ins f128mem:$src),
                       "cvttps2dq\t{$src, $dst|$dst, $src}",
                       [(set VR128:$dst,
                         (int_x86_sse2_cvttps2dq (memopv4f32 addr:$src)))],
                       IIC_SSE_CVT_PS_RM>, Sched<[WriteCvtF2ILd]>;

let Predicates = [HasAVX] in {
  def : Pat<(v4f32 (sint_to_fp (v4i32 VR128:$src))),
            (VCVTDQ2PSrr VR128:$src)>;
  def : Pat<(v4f32 (sint_to_fp (bc_v4i32 (memopv2i64 addr:$src)))),
            (VCVTDQ2PSrm addr:$src)>;

  def : Pat<(int_x86_sse2_cvtdq2ps VR128:$src),
            (VCVTDQ2PSrr VR128:$src)>;
  def : Pat<(int_x86_sse2_cvtdq2ps (bc_v4i32 (memopv2i64 addr:$src))),
            (VCVTDQ2PSrm addr:$src)>;

  def : Pat<(v4i32 (fp_to_sint (v4f32 VR128:$src))),
            (VCVTTPS2DQrr VR128:$src)>;
  def : Pat<(v4i32 (fp_to_sint (memopv4f32 addr:$src))),
            (VCVTTPS2DQrm addr:$src)>;

  def : Pat<(v8f32 (sint_to_fp (v8i32 VR256:$src))),
            (VCVTDQ2PSYrr VR256:$src)>;
  def : Pat<(v8f32 (sint_to_fp (bc_v8i32 (memopv4i64 addr:$src)))),
            (VCVTDQ2PSYrm addr:$src)>;

  def : Pat<(v8i32 (fp_to_sint (v8f32 VR256:$src))),
            (VCVTTPS2DQYrr VR256:$src)>;
  def : Pat<(v8i32 (fp_to_sint (memopv8f32 addr:$src))),
            (VCVTTPS2DQYrm addr:$src)>;
}

let Predicates = [UseSSE2] in {
  def : Pat<(v4f32 (sint_to_fp (v4i32 VR128:$src))),
            (CVTDQ2PSrr VR128:$src)>;
  def : Pat<(v4f32 (sint_to_fp (bc_v4i32 (memopv2i64 addr:$src)))),
            (CVTDQ2PSrm addr:$src)>;

  def : Pat<(int_x86_sse2_cvtdq2ps VR128:$src),
            (CVTDQ2PSrr VR128:$src)>;
  def : Pat<(int_x86_sse2_cvtdq2ps (bc_v4i32 (memopv2i64 addr:$src))),
            (CVTDQ2PSrm addr:$src)>;

  def : Pat<(v4i32 (fp_to_sint (v4f32 VR128:$src))),
            (CVTTPS2DQrr VR128:$src)>;
  def : Pat<(v4i32 (fp_to_sint (memopv4f32 addr:$src))),
            (CVTTPS2DQrm addr:$src)>;
}

def VCVTTPD2DQrr : VPDI<0xE6, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                        "cvttpd2dq\t{$src, $dst|$dst, $src}",
                        [(set VR128:$dst,
                              (int_x86_sse2_cvttpd2dq VR128:$src))],
                              IIC_SSE_CVT_PD_RR>, VEX, Sched<[WriteCvtF2I]>;

// The assembler can recognize rr 256-bit instructions by seeing a ymm
// register, but the same isn't true when using memory operands instead.
// Provide other assembly rr and rm forms to address this explicitly.

// XMM only
def : InstAlias<"vcvttpd2dqx\t{$src, $dst|$dst, $src}",
                (VCVTTPD2DQrr VR128:$dst, VR128:$src)>;
def VCVTTPD2DQXrm : VPDI<0xE6, MRMSrcMem, (outs VR128:$dst), (ins f128mem:$src),
                         "cvttpd2dqx\t{$src, $dst|$dst, $src}",
                         [(set VR128:$dst, (int_x86_sse2_cvttpd2dq
                                            (memopv2f64 addr:$src)))],
                         IIC_SSE_CVT_PD_RM>, VEX, Sched<[WriteCvtF2ILd]>;

// YMM only
def VCVTTPD2DQYrr : VPDI<0xE6, MRMSrcReg, (outs VR128:$dst), (ins VR256:$src),
                         "cvttpd2dq{y}\t{$src, $dst|$dst, $src}",
                         [(set VR128:$dst,
                           (int_x86_avx_cvtt_pd2dq_256 VR256:$src))],
                         IIC_SSE_CVT_PD_RR>, VEX, VEX_L, Sched<[WriteCvtF2I]>;
def VCVTTPD2DQYrm : VPDI<0xE6, MRMSrcMem, (outs VR128:$dst), (ins f256mem:$src),
                         "cvttpd2dq{y}\t{$src, $dst|$dst, $src}",
                         [(set VR128:$dst,
                          (int_x86_avx_cvtt_pd2dq_256 (memopv4f64 addr:$src)))],
                         IIC_SSE_CVT_PD_RM>, VEX, VEX_L, Sched<[WriteCvtF2ILd]>;
def : InstAlias<"vcvttpd2dq\t{$src, $dst|$dst, $src}",
                (VCVTTPD2DQYrr VR128:$dst, VR256:$src)>;

let Predicates = [HasAVX] in {
  def : Pat<(v4i32 (fp_to_sint (v4f64 VR256:$src))),
            (VCVTTPD2DQYrr VR256:$src)>;
  def : Pat<(v4i32 (fp_to_sint (memopv4f64 addr:$src))),
            (VCVTTPD2DQYrm addr:$src)>;
} // Predicates = [HasAVX]

def CVTTPD2DQrr : PDI<0xE6, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                      "cvttpd2dq\t{$src, $dst|$dst, $src}",
                      [(set VR128:$dst, (int_x86_sse2_cvttpd2dq VR128:$src))],
                      IIC_SSE_CVT_PD_RR>, Sched<[WriteCvtF2I]>;
def CVTTPD2DQrm : PDI<0xE6, MRMSrcMem, (outs VR128:$dst),(ins f128mem:$src),
                      "cvttpd2dq\t{$src, $dst|$dst, $src}",
                      [(set VR128:$dst, (int_x86_sse2_cvttpd2dq
                                        (memopv2f64 addr:$src)))],
                                        IIC_SSE_CVT_PD_RM>,
                      Sched<[WriteCvtF2ILd]>;

// Convert packed single to packed double
let Predicates = [HasAVX] in {
                  // SSE2 instructions without OpSize prefix
def VCVTPS2PDrr : I<0x5A, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                     "vcvtps2pd\t{$src, $dst|$dst, $src}",
                     [(set VR128:$dst, (int_x86_sse2_cvtps2pd VR128:$src))],
                     IIC_SSE_CVT_PD_RR>, TB, VEX, Sched<[WriteCvtF2F]>;
def VCVTPS2PDrm : I<0x5A, MRMSrcMem, (outs VR128:$dst), (ins f64mem:$src),
                    "vcvtps2pd\t{$src, $dst|$dst, $src}",
                    [(set VR128:$dst, (v2f64 (extloadv2f32 addr:$src)))],
                    IIC_SSE_CVT_PD_RM>, TB, VEX, Sched<[WriteCvtF2FLd]>;
def VCVTPS2PDYrr : I<0x5A, MRMSrcReg, (outs VR256:$dst), (ins VR128:$src),
                     "vcvtps2pd\t{$src, $dst|$dst, $src}",
                     [(set VR256:$dst,
                       (int_x86_avx_cvt_ps2_pd_256 VR128:$src))],
                     IIC_SSE_CVT_PD_RR>, TB, VEX, VEX_L, Sched<[WriteCvtF2F]>;
def VCVTPS2PDYrm : I<0x5A, MRMSrcMem, (outs VR256:$dst), (ins f128mem:$src),
                     "vcvtps2pd\t{$src, $dst|$dst, $src}",
                     [(set VR256:$dst,
                       (int_x86_avx_cvt_ps2_pd_256 (memopv4f32 addr:$src)))],
                     IIC_SSE_CVT_PD_RM>, TB, VEX, VEX_L, Sched<[WriteCvtF2FLd]>;
}

let Predicates = [UseSSE2] in {
def CVTPS2PDrr : I<0x5A, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                       "cvtps2pd\t{$src, $dst|$dst, $src}",
                       [(set VR128:$dst, (int_x86_sse2_cvtps2pd VR128:$src))],
                       IIC_SSE_CVT_PD_RR>, TB, Sched<[WriteCvtF2F]>;
def CVTPS2PDrm : I<0x5A, MRMSrcMem, (outs VR128:$dst), (ins f64mem:$src),
                   "cvtps2pd\t{$src, $dst|$dst, $src}",
                   [(set VR128:$dst, (v2f64 (extloadv2f32 addr:$src)))],
                   IIC_SSE_CVT_PD_RM>, TB, Sched<[WriteCvtF2FLd]>;
}

// Convert Packed DW Integers to Packed Double FP
let Predicates = [HasAVX] in {
let neverHasSideEffects = 1, mayLoad = 1 in
def VCVTDQ2PDrm  : S2SI<0xE6, MRMSrcMem, (outs VR128:$dst), (ins i64mem:$src),
                     "vcvtdq2pd\t{$src, $dst|$dst, $src}",
                     []>, VEX, Sched<[WriteCvtI2FLd]>;
def VCVTDQ2PDrr  : S2SI<0xE6, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                     "vcvtdq2pd\t{$src, $dst|$dst, $src}",
                     [(set VR128:$dst,
                       (int_x86_sse2_cvtdq2pd VR128:$src))]>, VEX,
                   Sched<[WriteCvtI2F]>;
def VCVTDQ2PDYrm  : S2SI<0xE6, MRMSrcMem, (outs VR256:$dst), (ins i128mem:$src),
                     "vcvtdq2pd\t{$src, $dst|$dst, $src}",
                     [(set VR256:$dst,
                       (int_x86_avx_cvtdq2_pd_256
                        (bitconvert (memopv2i64 addr:$src))))]>, VEX, VEX_L,
                    Sched<[WriteCvtI2FLd]>;
def VCVTDQ2PDYrr  : S2SI<0xE6, MRMSrcReg, (outs VR256:$dst), (ins VR128:$src),
                     "vcvtdq2pd\t{$src, $dst|$dst, $src}",
                     [(set VR256:$dst,
                       (int_x86_avx_cvtdq2_pd_256 VR128:$src))]>, VEX, VEX_L,
                    Sched<[WriteCvtI2F]>;
}

let neverHasSideEffects = 1, mayLoad = 1 in
def CVTDQ2PDrm  : S2SI<0xE6, MRMSrcMem, (outs VR128:$dst), (ins i64mem:$src),
                       "cvtdq2pd\t{$src, $dst|$dst, $src}", [],
                       IIC_SSE_CVT_PD_RR>, Sched<[WriteCvtI2FLd]>;
def CVTDQ2PDrr  : S2SI<0xE6, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                       "cvtdq2pd\t{$src, $dst|$dst, $src}",
                       [(set VR128:$dst, (int_x86_sse2_cvtdq2pd VR128:$src))],
                       IIC_SSE_CVT_PD_RM>, Sched<[WriteCvtI2F]>;

// AVX 256-bit register conversion intrinsics
let Predicates = [HasAVX] in {
  def : Pat<(v4f64 (sint_to_fp (v4i32 VR128:$src))),
            (VCVTDQ2PDYrr VR128:$src)>;
  def : Pat<(v4f64 (sint_to_fp (bc_v4i32 (memopv2i64 addr:$src)))),
            (VCVTDQ2PDYrm addr:$src)>;
} // Predicates = [HasAVX]

// Convert packed double to packed single
// The assembler can recognize rr 256-bit instructions by seeing a ymm
// register, but the same isn't true when using memory operands instead.
// Provide other assembly rr and rm forms to address this explicitly.
def VCVTPD2PSrr : VPDI<0x5A, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                       "cvtpd2ps\t{$src, $dst|$dst, $src}",
                       [(set VR128:$dst, (int_x86_sse2_cvtpd2ps VR128:$src))],
                       IIC_SSE_CVT_PD_RR>, VEX, Sched<[WriteCvtF2F]>;

// XMM only
def : InstAlias<"vcvtpd2psx\t{$src, $dst|$dst, $src}",
                (VCVTPD2PSrr VR128:$dst, VR128:$src)>;
def VCVTPD2PSXrm : VPDI<0x5A, MRMSrcMem, (outs VR128:$dst), (ins f128mem:$src),
                        "cvtpd2psx\t{$src, $dst|$dst, $src}",
                        [(set VR128:$dst,
                          (int_x86_sse2_cvtpd2ps (memopv2f64 addr:$src)))],
                        IIC_SSE_CVT_PD_RM>, VEX, Sched<[WriteCvtF2FLd]>;

// YMM only
def VCVTPD2PSYrr : VPDI<0x5A, MRMSrcReg, (outs VR128:$dst), (ins VR256:$src),
                        "cvtpd2ps{y}\t{$src, $dst|$dst, $src}",
                        [(set VR128:$dst,
                          (int_x86_avx_cvt_pd2_ps_256 VR256:$src))],
                        IIC_SSE_CVT_PD_RR>, VEX, VEX_L, Sched<[WriteCvtF2F]>;
def VCVTPD2PSYrm : VPDI<0x5A, MRMSrcMem, (outs VR128:$dst), (ins f256mem:$src),
                        "cvtpd2ps{y}\t{$src, $dst|$dst, $src}",
                        [(set VR128:$dst,
                          (int_x86_avx_cvt_pd2_ps_256 (memopv4f64 addr:$src)))],
                        IIC_SSE_CVT_PD_RM>, VEX, VEX_L, Sched<[WriteCvtF2FLd]>;
def : InstAlias<"vcvtpd2ps\t{$src, $dst|$dst, $src}",
                (VCVTPD2PSYrr VR128:$dst, VR256:$src)>;

def CVTPD2PSrr : PDI<0x5A, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                     "cvtpd2ps\t{$src, $dst|$dst, $src}",
                     [(set VR128:$dst, (int_x86_sse2_cvtpd2ps VR128:$src))],
                     IIC_SSE_CVT_PD_RR>, Sched<[WriteCvtF2F]>;
def CVTPD2PSrm : PDI<0x5A, MRMSrcMem, (outs VR128:$dst), (ins f128mem:$src),
                     "cvtpd2ps\t{$src, $dst|$dst, $src}",
                     [(set VR128:$dst,
                       (int_x86_sse2_cvtpd2ps (memopv2f64 addr:$src)))],
                     IIC_SSE_CVT_PD_RM>, Sched<[WriteCvtF2FLd]>;


// AVX 256-bit register conversion intrinsics
// FIXME: Migrate SSE conversion intrinsics matching to use patterns as below
// whenever possible to avoid declaring two versions of each one.
let Predicates = [HasAVX] in {
  def : Pat<(int_x86_avx_cvtdq2_ps_256 VR256:$src),
            (VCVTDQ2PSYrr VR256:$src)>;
  def : Pat<(int_x86_avx_cvtdq2_ps_256 (bitconvert (memopv4i64 addr:$src))),
            (VCVTDQ2PSYrm addr:$src)>;

  // Match fround and fextend for 128/256-bit conversions
  def : Pat<(v4f32 (X86vfpround (v2f64 VR128:$src))),
            (VCVTPD2PSrr VR128:$src)>;
  def : Pat<(v4f32 (X86vfpround (memopv2f64 addr:$src))),
            (VCVTPD2PSXrm addr:$src)>;
  def : Pat<(v4f32 (fround (v4f64 VR256:$src))),
            (VCVTPD2PSYrr VR256:$src)>;
  def : Pat<(v4f32 (fround (loadv4f64 addr:$src))),
            (VCVTPD2PSYrm addr:$src)>;

  def : Pat<(v2f64 (X86vfpext (v4f32 VR128:$src))),
            (VCVTPS2PDrr VR128:$src)>;
  def : Pat<(v4f64 (fextend (v4f32 VR128:$src))),
            (VCVTPS2PDYrr VR128:$src)>;
  def : Pat<(v4f64 (extloadv4f32 addr:$src)),
            (VCVTPS2PDYrm addr:$src)>;
}

let Predicates = [UseSSE2] in {
  // Match fround and fextend for 128 conversions
  def : Pat<(v4f32 (X86vfpround (v2f64 VR128:$src))),
            (CVTPD2PSrr VR128:$src)>;
  def : Pat<(v4f32 (X86vfpround (memopv2f64 addr:$src))),
            (CVTPD2PSrm addr:$src)>;

  def : Pat<(v2f64 (X86vfpext (v4f32 VR128:$src))),
            (CVTPS2PDrr VR128:$src)>;
}

//===----------------------------------------------------------------------===//
// SSE 1 & 2 - Compare Instructions
//===----------------------------------------------------------------------===//

// sse12_cmp_scalar - sse 1 & 2 compare scalar instructions
multiclass sse12_cmp_scalar<RegisterClass RC, X86MemOperand x86memop,
                            Operand CC, SDNode OpNode, ValueType VT,
                            PatFrag ld_frag, string asm, string asm_alt,
                            OpndItins itins> {
  def rr : SIi8<0xC2, MRMSrcReg,
                (outs RC:$dst), (ins RC:$src1, RC:$src2, CC:$cc), asm,
                [(set RC:$dst, (OpNode (VT RC:$src1), RC:$src2, imm:$cc))],
                itins.rr>, Sched<[itins.Sched]>;
  def rm : SIi8<0xC2, MRMSrcMem,
                (outs RC:$dst), (ins RC:$src1, x86memop:$src2, CC:$cc), asm,
                [(set RC:$dst, (OpNode (VT RC:$src1),
                                         (ld_frag addr:$src2), imm:$cc))],
                                         itins.rm>,
           Sched<[itins.Sched.Folded, ReadAfterLd]>;

  // Accept explicit immediate argument form instead of comparison code.
  let neverHasSideEffects = 1 in {
    def rr_alt : SIi8<0xC2, MRMSrcReg, (outs RC:$dst),
                      (ins RC:$src1, RC:$src2, i8imm:$cc), asm_alt, [],
                      IIC_SSE_ALU_F32S_RR>, Sched<[itins.Sched]>;
    let mayLoad = 1 in
    def rm_alt : SIi8<0xC2, MRMSrcMem, (outs RC:$dst),
                      (ins RC:$src1, x86memop:$src2, i8imm:$cc), asm_alt, [],
                      IIC_SSE_ALU_F32S_RM>,
                      Sched<[itins.Sched.Folded, ReadAfterLd]>;
  }
}

defm VCMPSS : sse12_cmp_scalar<FR32, f32mem, AVXCC, X86cmpss, f32, loadf32,
                 "cmp${cc}ss\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                 "cmpss\t{$cc, $src2, $src1, $dst|$dst, $src1, $src2, $cc}",
                 SSE_ALU_F32S>,
                 XS, VEX_4V, VEX_LIG;
defm VCMPSD : sse12_cmp_scalar<FR64, f64mem, AVXCC, X86cmpsd, f64, loadf64,
                 "cmp${cc}sd\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                 "cmpsd\t{$cc, $src2, $src1, $dst|$dst, $src1, $src2, $cc}",
                 SSE_ALU_F32S>, // same latency as 32 bit compare
                 XD, VEX_4V, VEX_LIG;

let Constraints = "$src1 = $dst" in {
  defm CMPSS : sse12_cmp_scalar<FR32, f32mem, SSECC, X86cmpss, f32, loadf32,
                  "cmp${cc}ss\t{$src2, $dst|$dst, $src2}",
                  "cmpss\t{$cc, $src2, $dst|$dst, $src2, $cc}", SSE_ALU_F32S>,
                  XS;
  defm CMPSD : sse12_cmp_scalar<FR64, f64mem, SSECC, X86cmpsd, f64, loadf64,
                  "cmp${cc}sd\t{$src2, $dst|$dst, $src2}",
                  "cmpsd\t{$cc, $src2, $dst|$dst, $src2, $cc}",
                  SSE_ALU_F32S>, // same latency as 32 bit compare
                  XD;
}

multiclass sse12_cmp_scalar_int<X86MemOperand x86memop, Operand CC,
                         Intrinsic Int, string asm, OpndItins itins> {
  def rr : SIi8<0xC2, MRMSrcReg, (outs VR128:$dst),
                      (ins VR128:$src1, VR128:$src, CC:$cc), asm,
                        [(set VR128:$dst, (Int VR128:$src1,
                                               VR128:$src, imm:$cc))],
                                               itins.rr>,
           Sched<[itins.Sched]>;
  def rm : SIi8<0xC2, MRMSrcMem, (outs VR128:$dst),
                      (ins VR128:$src1, x86memop:$src, CC:$cc), asm,
                        [(set VR128:$dst, (Int VR128:$src1,
                                               (load addr:$src), imm:$cc))],
                                               itins.rm>,
           Sched<[itins.Sched.Folded, ReadAfterLd]>;
}

// Aliases to match intrinsics which expect XMM operand(s).
defm Int_VCMPSS  : sse12_cmp_scalar_int<f32mem, AVXCC, int_x86_sse_cmp_ss,
                     "cmp${cc}ss\t{$src, $src1, $dst|$dst, $src1, $src}",
                     SSE_ALU_F32S>,
                     XS, VEX_4V;
defm Int_VCMPSD  : sse12_cmp_scalar_int<f64mem, AVXCC, int_x86_sse2_cmp_sd,
                     "cmp${cc}sd\t{$src, $src1, $dst|$dst, $src1, $src}",
                     SSE_ALU_F32S>, // same latency as f32
                     XD, VEX_4V;
let Constraints = "$src1 = $dst" in {
  defm Int_CMPSS  : sse12_cmp_scalar_int<f32mem, SSECC, int_x86_sse_cmp_ss,
                       "cmp${cc}ss\t{$src, $dst|$dst, $src}",
                       SSE_ALU_F32S>, XS;
  defm Int_CMPSD  : sse12_cmp_scalar_int<f64mem, SSECC, int_x86_sse2_cmp_sd,
                       "cmp${cc}sd\t{$src, $dst|$dst, $src}",
                       SSE_ALU_F32S>, // same latency as f32
                       XD;
}


// sse12_ord_cmp - Unordered/Ordered scalar fp compare and set EFLAGS
multiclass sse12_ord_cmp<bits<8> opc, RegisterClass RC, SDNode OpNode,
                            ValueType vt, X86MemOperand x86memop,
                            PatFrag ld_frag, string OpcodeStr> {
  def rr: SI<opc, MRMSrcReg, (outs), (ins RC:$src1, RC:$src2),
                     !strconcat(OpcodeStr, "\t{$src2, $src1|$src1, $src2}"),
                     [(set EFLAGS, (OpNode (vt RC:$src1), RC:$src2))],
                     IIC_SSE_COMIS_RR>,
          Sched<[WriteFAdd]>;
  def rm: SI<opc, MRMSrcMem, (outs), (ins RC:$src1, x86memop:$src2),
                     !strconcat(OpcodeStr, "\t{$src2, $src1|$src1, $src2}"),
                     [(set EFLAGS, (OpNode (vt RC:$src1),
                                           (ld_frag addr:$src2)))],
                                           IIC_SSE_COMIS_RM>,
          Sched<[WriteFAddLd, ReadAfterLd]>;
}

let Defs = [EFLAGS] in {
  defm VUCOMISS : sse12_ord_cmp<0x2E, FR32, X86cmp, f32, f32mem, loadf32,
                                  "ucomiss">, TB, VEX, VEX_LIG;
  defm VUCOMISD : sse12_ord_cmp<0x2E, FR64, X86cmp, f64, f64mem, loadf64,
                                  "ucomisd">, TB, OpSize, VEX, VEX_LIG;
  let Pattern = []<dag> in {
    defm VCOMISS  : sse12_ord_cmp<0x2F, VR128, undef, v4f32, f128mem, load,
                                    "comiss">, TB, VEX, VEX_LIG;
    defm VCOMISD  : sse12_ord_cmp<0x2F, VR128, undef, v2f64, f128mem, load,
                                    "comisd">, TB, OpSize, VEX, VEX_LIG;
  }

  defm Int_VUCOMISS  : sse12_ord_cmp<0x2E, VR128, X86ucomi, v4f32, f128mem,
                            load, "ucomiss">, TB, VEX;
  defm Int_VUCOMISD  : sse12_ord_cmp<0x2E, VR128, X86ucomi, v2f64, f128mem,
                            load, "ucomisd">, TB, OpSize, VEX;

  defm Int_VCOMISS  : sse12_ord_cmp<0x2F, VR128, X86comi, v4f32, f128mem,
                            load, "comiss">, TB, VEX;
  defm Int_VCOMISD  : sse12_ord_cmp<0x2F, VR128, X86comi, v2f64, f128mem,
                            load, "comisd">, TB, OpSize, VEX;
  defm UCOMISS  : sse12_ord_cmp<0x2E, FR32, X86cmp, f32, f32mem, loadf32,
                                  "ucomiss">, TB;
  defm UCOMISD  : sse12_ord_cmp<0x2E, FR64, X86cmp, f64, f64mem, loadf64,
                                  "ucomisd">, TB, OpSize;

  let Pattern = []<dag> in {
    defm COMISS  : sse12_ord_cmp<0x2F, VR128, undef, v4f32, f128mem, load,
                                    "comiss">, TB;
    defm COMISD  : sse12_ord_cmp<0x2F, VR128, undef, v2f64, f128mem, load,
                                    "comisd">, TB, OpSize;
  }

  defm Int_UCOMISS  : sse12_ord_cmp<0x2E, VR128, X86ucomi, v4f32, f128mem,
                              load, "ucomiss">, TB;
  defm Int_UCOMISD  : sse12_ord_cmp<0x2E, VR128, X86ucomi, v2f64, f128mem,
                              load, "ucomisd">, TB, OpSize;

  defm Int_COMISS  : sse12_ord_cmp<0x2F, VR128, X86comi, v4f32, f128mem, load,
                                  "comiss">, TB;
  defm Int_COMISD  : sse12_ord_cmp<0x2F, VR128, X86comi, v2f64, f128mem, load,
                                  "comisd">, TB, OpSize;
} // Defs = [EFLAGS]

// sse12_cmp_packed - sse 1 & 2 compare packed instructions
multiclass sse12_cmp_packed<RegisterClass RC, X86MemOperand x86memop,
                            Operand CC, Intrinsic Int, string asm,
                            string asm_alt, Domain d> {
  def rri : PIi8<0xC2, MRMSrcReg,
             (outs RC:$dst), (ins RC:$src1, RC:$src2, CC:$cc), asm,
             [(set RC:$dst, (Int RC:$src1, RC:$src2, imm:$cc))],
             IIC_SSE_CMPP_RR, d>,
            Sched<[WriteFAdd]>;
  def rmi : PIi8<0xC2, MRMSrcMem,
             (outs RC:$dst), (ins RC:$src1, x86memop:$src2, CC:$cc), asm,
             [(set RC:$dst, (Int RC:$src1, (memop addr:$src2), imm:$cc))],
             IIC_SSE_CMPP_RM, d>,
            Sched<[WriteFAddLd, ReadAfterLd]>;

  // Accept explicit immediate argument form instead of comparison code.
  let neverHasSideEffects = 1 in {
    def rri_alt : PIi8<0xC2, MRMSrcReg,
               (outs RC:$dst), (ins RC:$src1, RC:$src2, i8imm:$cc),
               asm_alt, [], IIC_SSE_CMPP_RR, d>, Sched<[WriteFAdd]>;
    def rmi_alt : PIi8<0xC2, MRMSrcMem,
               (outs RC:$dst), (ins RC:$src1, x86memop:$src2, i8imm:$cc),
               asm_alt, [], IIC_SSE_CMPP_RM, d>,
               Sched<[WriteFAddLd, ReadAfterLd]>;
  }
}

defm VCMPPS : sse12_cmp_packed<VR128, f128mem, AVXCC, int_x86_sse_cmp_ps,
               "cmp${cc}ps\t{$src2, $src1, $dst|$dst, $src1, $src2}",
               "cmpps\t{$cc, $src2, $src1, $dst|$dst, $src1, $src2, $cc}",
               SSEPackedSingle>, TB, VEX_4V;
defm VCMPPD : sse12_cmp_packed<VR128, f128mem, AVXCC, int_x86_sse2_cmp_pd,
               "cmp${cc}pd\t{$src2, $src1, $dst|$dst, $src1, $src2}",
               "cmppd\t{$cc, $src2, $src1, $dst|$dst, $src1, $src2, $cc}",
               SSEPackedDouble>, TB, OpSize, VEX_4V;
defm VCMPPSY : sse12_cmp_packed<VR256, f256mem, AVXCC, int_x86_avx_cmp_ps_256,
               "cmp${cc}ps\t{$src2, $src1, $dst|$dst, $src1, $src2}",
               "cmpps\t{$cc, $src2, $src1, $dst|$dst, $src1, $src2, $cc}",
               SSEPackedSingle>, TB, VEX_4V, VEX_L;
defm VCMPPDY : sse12_cmp_packed<VR256, f256mem, AVXCC, int_x86_avx_cmp_pd_256,
               "cmp${cc}pd\t{$src2, $src1, $dst|$dst, $src1, $src2}",
               "cmppd\t{$cc, $src2, $src1, $dst|$dst, $src1, $src2, $cc}",
               SSEPackedDouble>, TB, OpSize, VEX_4V, VEX_L;
let Constraints = "$src1 = $dst" in {
  defm CMPPS : sse12_cmp_packed<VR128, f128mem, SSECC, int_x86_sse_cmp_ps,
                 "cmp${cc}ps\t{$src2, $dst|$dst, $src2}",
                 "cmpps\t{$cc, $src2, $dst|$dst, $src2, $cc}",
                 SSEPackedSingle>, TB;
  defm CMPPD : sse12_cmp_packed<VR128, f128mem, SSECC, int_x86_sse2_cmp_pd,
                 "cmp${cc}pd\t{$src2, $dst|$dst, $src2}",
                 "cmppd\t{$cc, $src2, $dst|$dst, $src2, $cc}",
                 SSEPackedDouble>, TB, OpSize;
}

let Predicates = [HasAVX] in {
def : Pat<(v4i32 (X86cmpp (v4f32 VR128:$src1), VR128:$src2, imm:$cc)),
          (VCMPPSrri (v4f32 VR128:$src1), (v4f32 VR128:$src2), imm:$cc)>;
def : Pat<(v4i32 (X86cmpp (v4f32 VR128:$src1), (memop addr:$src2), imm:$cc)),
          (VCMPPSrmi (v4f32 VR128:$src1), addr:$src2, imm:$cc)>;
def : Pat<(v2i64 (X86cmpp (v2f64 VR128:$src1), VR128:$src2, imm:$cc)),
          (VCMPPDrri VR128:$src1, VR128:$src2, imm:$cc)>;
def : Pat<(v2i64 (X86cmpp (v2f64 VR128:$src1), (memop addr:$src2), imm:$cc)),
          (VCMPPDrmi VR128:$src1, addr:$src2, imm:$cc)>;

def : Pat<(v8i32 (X86cmpp (v8f32 VR256:$src1), VR256:$src2, imm:$cc)),
          (VCMPPSYrri (v8f32 VR256:$src1), (v8f32 VR256:$src2), imm:$cc)>;
def : Pat<(v8i32 (X86cmpp (v8f32 VR256:$src1), (memop addr:$src2), imm:$cc)),
          (VCMPPSYrmi (v8f32 VR256:$src1), addr:$src2, imm:$cc)>;
def : Pat<(v4i64 (X86cmpp (v4f64 VR256:$src1), VR256:$src2, imm:$cc)),
          (VCMPPDYrri VR256:$src1, VR256:$src2, imm:$cc)>;
def : Pat<(v4i64 (X86cmpp (v4f64 VR256:$src1), (memop addr:$src2), imm:$cc)),
          (VCMPPDYrmi VR256:$src1, addr:$src2, imm:$cc)>;
}

let Predicates = [UseSSE1] in {
def : Pat<(v4i32 (X86cmpp (v4f32 VR128:$src1), VR128:$src2, imm:$cc)),
          (CMPPSrri (v4f32 VR128:$src1), (v4f32 VR128:$src2), imm:$cc)>;
def : Pat<(v4i32 (X86cmpp (v4f32 VR128:$src1), (memop addr:$src2), imm:$cc)),
          (CMPPSrmi (v4f32 VR128:$src1), addr:$src2, imm:$cc)>;
}

let Predicates = [UseSSE2] in {
def : Pat<(v2i64 (X86cmpp (v2f64 VR128:$src1), VR128:$src2, imm:$cc)),
          (CMPPDrri VR128:$src1, VR128:$src2, imm:$cc)>;
def : Pat<(v2i64 (X86cmpp (v2f64 VR128:$src1), (memop addr:$src2), imm:$cc)),
          (CMPPDrmi VR128:$src1, addr:$src2, imm:$cc)>;
}

//===----------------------------------------------------------------------===//
// SSE 1 & 2 - Shuffle Instructions
//===----------------------------------------------------------------------===//

/// sse12_shuffle - sse 1 & 2 shuffle instructions
multiclass sse12_shuffle<RegisterClass RC, X86MemOperand x86memop,
                         ValueType vt, string asm, PatFrag mem_frag,
                         Domain d, bit IsConvertibleToThreeAddress = 0> {
  def rmi : PIi8<0xC6, MRMSrcMem, (outs RC:$dst),
                   (ins RC:$src1, x86memop:$src2, i8imm:$src3), asm,
                   [(set RC:$dst, (vt (X86Shufp RC:$src1, (mem_frag addr:$src2),
                                       (i8 imm:$src3))))], IIC_SSE_SHUFP, d>,
            Sched<[WriteShuffleLd, ReadAfterLd]>;
  let isConvertibleToThreeAddress = IsConvertibleToThreeAddress in
    def rri : PIi8<0xC6, MRMSrcReg, (outs RC:$dst),
                   (ins RC:$src1, RC:$src2, i8imm:$src3), asm,
                   [(set RC:$dst, (vt (X86Shufp RC:$src1, RC:$src2,
                                       (i8 imm:$src3))))], IIC_SSE_SHUFP, d>,
              Sched<[WriteShuffle]>;
}

defm VSHUFPS  : sse12_shuffle<VR128, f128mem, v4f32,
           "shufps\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}",
           memopv4f32, SSEPackedSingle>, TB, VEX_4V;
defm VSHUFPSY : sse12_shuffle<VR256, f256mem, v8f32,
           "shufps\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}",
           memopv8f32, SSEPackedSingle>, TB, VEX_4V, VEX_L;
defm VSHUFPD  : sse12_shuffle<VR128, f128mem, v2f64,
           "shufpd\t{$src3, $src2, $src1, $dst|$dst, $src2, $src2, $src3}",
           memopv2f64, SSEPackedDouble>, TB, OpSize, VEX_4V;
defm VSHUFPDY : sse12_shuffle<VR256, f256mem, v4f64,
           "shufpd\t{$src3, $src2, $src1, $dst|$dst, $src2, $src2, $src3}",
           memopv4f64, SSEPackedDouble>, TB, OpSize, VEX_4V, VEX_L;

let Constraints = "$src1 = $dst" in {
  defm SHUFPS : sse12_shuffle<VR128, f128mem, v4f32,
                    "shufps\t{$src3, $src2, $dst|$dst, $src2, $src3}",
                    memopv4f32, SSEPackedSingle, 1 /* cvt to pshufd */>,
                    TB;
  defm SHUFPD : sse12_shuffle<VR128, f128mem, v2f64,
                    "shufpd\t{$src3, $src2, $dst|$dst, $src2, $src3}",
                    memopv2f64, SSEPackedDouble, 1 /* cvt to pshufd */>,
                    TB, OpSize;
}

let Predicates = [HasAVX] in {
  def : Pat<(v4i32 (X86Shufp VR128:$src1,
                       (bc_v4i32 (memopv2i64 addr:$src2)), (i8 imm:$imm))),
            (VSHUFPSrmi VR128:$src1, addr:$src2, imm:$imm)>;
  def : Pat<(v4i32 (X86Shufp VR128:$src1, VR128:$src2, (i8 imm:$imm))),
            (VSHUFPSrri VR128:$src1, VR128:$src2, imm:$imm)>;

  def : Pat<(v2i64 (X86Shufp VR128:$src1,
                       (memopv2i64 addr:$src2), (i8 imm:$imm))),
            (VSHUFPDrmi VR128:$src1, addr:$src2, imm:$imm)>;
  def : Pat<(v2i64 (X86Shufp VR128:$src1, VR128:$src2, (i8 imm:$imm))),
            (VSHUFPDrri VR128:$src1, VR128:$src2, imm:$imm)>;

  // 256-bit patterns
  def : Pat<(v8i32 (X86Shufp VR256:$src1, VR256:$src2, (i8 imm:$imm))),
            (VSHUFPSYrri VR256:$src1, VR256:$src2, imm:$imm)>;
  def : Pat<(v8i32 (X86Shufp VR256:$src1,
                      (bc_v8i32 (memopv4i64 addr:$src2)), (i8 imm:$imm))),
            (VSHUFPSYrmi VR256:$src1, addr:$src2, imm:$imm)>;

  def : Pat<(v4i64 (X86Shufp VR256:$src1, VR256:$src2, (i8 imm:$imm))),
            (VSHUFPDYrri VR256:$src1, VR256:$src2, imm:$imm)>;
  def : Pat<(v4i64 (X86Shufp VR256:$src1,
                              (memopv4i64 addr:$src2), (i8 imm:$imm))),
            (VSHUFPDYrmi VR256:$src1, addr:$src2, imm:$imm)>;
}

let Predicates = [UseSSE1] in {
  def : Pat<(v4i32 (X86Shufp VR128:$src1,
                       (bc_v4i32 (memopv2i64 addr:$src2)), (i8 imm:$imm))),
            (SHUFPSrmi VR128:$src1, addr:$src2, imm:$imm)>;
  def : Pat<(v4i32 (X86Shufp VR128:$src1, VR128:$src2, (i8 imm:$imm))),
            (SHUFPSrri VR128:$src1, VR128:$src2, imm:$imm)>;
}

let Predicates = [UseSSE2] in {
  // Generic SHUFPD patterns
  def : Pat<(v2i64 (X86Shufp VR128:$src1,
                       (memopv2i64 addr:$src2), (i8 imm:$imm))),
            (SHUFPDrmi VR128:$src1, addr:$src2, imm:$imm)>;
  def : Pat<(v2i64 (X86Shufp VR128:$src1, VR128:$src2, (i8 imm:$imm))),
            (SHUFPDrri VR128:$src1, VR128:$src2, imm:$imm)>;
}

//===----------------------------------------------------------------------===//
// SSE 1 & 2 - Unpack Instructions
//===----------------------------------------------------------------------===//

/// sse12_unpack_interleave - sse 1 & 2 unpack and interleave
multiclass sse12_unpack_interleave<bits<8> opc, SDNode OpNode, ValueType vt,
                                   PatFrag mem_frag, RegisterClass RC,
                                   X86MemOperand x86memop, string asm,
                                   Domain d> {
    def rr : PI<opc, MRMSrcReg,
                (outs RC:$dst), (ins RC:$src1, RC:$src2),
                asm, [(set RC:$dst,
                           (vt (OpNode RC:$src1, RC:$src2)))],
                           IIC_SSE_UNPCK, d>, Sched<[WriteShuffle]>;
    def rm : PI<opc, MRMSrcMem,
                (outs RC:$dst), (ins RC:$src1, x86memop:$src2),
                asm, [(set RC:$dst,
                           (vt (OpNode RC:$src1,
                                       (mem_frag addr:$src2))))],
                                       IIC_SSE_UNPCK, d>,
             Sched<[WriteShuffleLd, ReadAfterLd]>;
}

defm VUNPCKHPS: sse12_unpack_interleave<0x15, X86Unpckh, v4f32, memopv4f32,
      VR128, f128mem, "unpckhps\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                     SSEPackedSingle>, TB, VEX_4V;
defm VUNPCKHPD: sse12_unpack_interleave<0x15, X86Unpckh, v2f64, memopv2f64,
      VR128, f128mem, "unpckhpd\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                     SSEPackedDouble>, TB, OpSize, VEX_4V;
defm VUNPCKLPS: sse12_unpack_interleave<0x14, X86Unpckl, v4f32, memopv4f32,
      VR128, f128mem, "unpcklps\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                     SSEPackedSingle>, TB, VEX_4V;
defm VUNPCKLPD: sse12_unpack_interleave<0x14, X86Unpckl, v2f64, memopv2f64,
      VR128, f128mem, "unpcklpd\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                     SSEPackedDouble>, TB, OpSize, VEX_4V;

defm VUNPCKHPSY: sse12_unpack_interleave<0x15, X86Unpckh, v8f32, memopv8f32,
      VR256, f256mem, "unpckhps\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                     SSEPackedSingle>, TB, VEX_4V, VEX_L;
defm VUNPCKHPDY: sse12_unpack_interleave<0x15, X86Unpckh, v4f64, memopv4f64,
      VR256, f256mem, "unpckhpd\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                     SSEPackedDouble>, TB, OpSize, VEX_4V, VEX_L;
defm VUNPCKLPSY: sse12_unpack_interleave<0x14, X86Unpckl, v8f32, memopv8f32,
      VR256, f256mem, "unpcklps\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                     SSEPackedSingle>, TB, VEX_4V, VEX_L;
defm VUNPCKLPDY: sse12_unpack_interleave<0x14, X86Unpckl, v4f64, memopv4f64,
      VR256, f256mem, "unpcklpd\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                     SSEPackedDouble>, TB, OpSize, VEX_4V, VEX_L;

let Constraints = "$src1 = $dst" in {
  defm UNPCKHPS: sse12_unpack_interleave<0x15, X86Unpckh, v4f32, memopv4f32,
        VR128, f128mem, "unpckhps\t{$src2, $dst|$dst, $src2}",
                       SSEPackedSingle>, TB;
  defm UNPCKHPD: sse12_unpack_interleave<0x15, X86Unpckh, v2f64, memopv2f64,
        VR128, f128mem, "unpckhpd\t{$src2, $dst|$dst, $src2}",
                       SSEPackedDouble>, TB, OpSize;
  defm UNPCKLPS: sse12_unpack_interleave<0x14, X86Unpckl, v4f32, memopv4f32,
        VR128, f128mem, "unpcklps\t{$src2, $dst|$dst, $src2}",
                       SSEPackedSingle>, TB;
  defm UNPCKLPD: sse12_unpack_interleave<0x14, X86Unpckl, v2f64, memopv2f64,
        VR128, f128mem, "unpcklpd\t{$src2, $dst|$dst, $src2}",
                       SSEPackedDouble>, TB, OpSize;
} // Constraints = "$src1 = $dst"

let Predicates = [HasAVX1Only] in {
  def : Pat<(v8i32 (X86Unpckl VR256:$src1, (bc_v8i32 (memopv4i64 addr:$src2)))),
            (VUNPCKLPSYrm VR256:$src1, addr:$src2)>;
  def : Pat<(v8i32 (X86Unpckl VR256:$src1, VR256:$src2)),
            (VUNPCKLPSYrr VR256:$src1, VR256:$src2)>;
  def : Pat<(v8i32 (X86Unpckh VR256:$src1, (bc_v8i32 (memopv4i64 addr:$src2)))),
            (VUNPCKHPSYrm VR256:$src1, addr:$src2)>;
  def : Pat<(v8i32 (X86Unpckh VR256:$src1, VR256:$src2)),
            (VUNPCKHPSYrr VR256:$src1, VR256:$src2)>;

  def : Pat<(v4i64 (X86Unpckl VR256:$src1, (memopv4i64 addr:$src2))),
            (VUNPCKLPDYrm VR256:$src1, addr:$src2)>;
  def : Pat<(v4i64 (X86Unpckl VR256:$src1, VR256:$src2)),
            (VUNPCKLPDYrr VR256:$src1, VR256:$src2)>;
  def : Pat<(v4i64 (X86Unpckh VR256:$src1, (memopv4i64 addr:$src2))),
            (VUNPCKHPDYrm VR256:$src1, addr:$src2)>;
  def : Pat<(v4i64 (X86Unpckh VR256:$src1, VR256:$src2)),
            (VUNPCKHPDYrr VR256:$src1, VR256:$src2)>;
}

let Predicates = [HasAVX] in {
  // FIXME: Instead of X86Movddup, there should be a X86Unpckl here, the
  // problem is during lowering, where it's not possible to recognize the load
  // fold cause it has two uses through a bitcast. One use disappears at isel
  // time and the fold opportunity reappears.
  def : Pat<(v2f64 (X86Movddup VR128:$src)),
            (VUNPCKLPDrr VR128:$src, VR128:$src)>;
}

let Predicates = [UseSSE2] in {
  // FIXME: Instead of X86Movddup, there should be a X86Unpckl here, the
  // problem is during lowering, where it's not possible to recognize the load
  // fold cause it has two uses through a bitcast. One use disappears at isel
  // time and the fold opportunity reappears.
  def : Pat<(v2f64 (X86Movddup VR128:$src)),
            (UNPCKLPDrr VR128:$src, VR128:$src)>;
}

//===----------------------------------------------------------------------===//
// SSE 1 & 2 - Extract Floating-Point Sign mask
//===----------------------------------------------------------------------===//

/// sse12_extr_sign_mask - sse 1 & 2 unpack and interleave
multiclass sse12_extr_sign_mask<RegisterClass RC, Intrinsic Int, string asm,
                                Domain d> {
  def rr32 : PI<0x50, MRMSrcReg, (outs GR32:$dst), (ins RC:$src),
                !strconcat(asm, "\t{$src, $dst|$dst, $src}"),
                     [(set GR32:$dst, (Int RC:$src))], IIC_SSE_MOVMSK, d>,
             Sched<[WriteVecLogic]>;
  def rr64 : PI<0x50, MRMSrcReg, (outs GR64:$dst), (ins RC:$src),
                !strconcat(asm, "\t{$src, $dst|$dst, $src}"), [],
                IIC_SSE_MOVMSK, d>, REX_W, Sched<[WriteVecLogic]>;
}

let Predicates = [HasAVX] in {
  defm VMOVMSKPS : sse12_extr_sign_mask<VR128, int_x86_sse_movmsk_ps,
                                        "movmskps", SSEPackedSingle>, TB, VEX;
  defm VMOVMSKPD : sse12_extr_sign_mask<VR128, int_x86_sse2_movmsk_pd,
                                        "movmskpd", SSEPackedDouble>, TB,
                                        OpSize, VEX;
  defm VMOVMSKPSY : sse12_extr_sign_mask<VR256, int_x86_avx_movmsk_ps_256,
                                        "movmskps", SSEPackedSingle>, TB,
                                        VEX, VEX_L;
  defm VMOVMSKPDY : sse12_extr_sign_mask<VR256, int_x86_avx_movmsk_pd_256,
                                        "movmskpd", SSEPackedDouble>, TB,
                                        OpSize, VEX, VEX_L;

  def : Pat<(i32 (X86fgetsign FR32:$src)),
            (VMOVMSKPSrr32 (COPY_TO_REGCLASS FR32:$src, VR128))>;
  def : Pat<(i64 (X86fgetsign FR32:$src)),
            (VMOVMSKPSrr64 (COPY_TO_REGCLASS FR32:$src, VR128))>;
  def : Pat<(i32 (X86fgetsign FR64:$src)),
            (VMOVMSKPDrr32 (COPY_TO_REGCLASS FR64:$src, VR128))>;
  def : Pat<(i64 (X86fgetsign FR64:$src)),
            (VMOVMSKPDrr64 (COPY_TO_REGCLASS FR64:$src, VR128))>;

  // Assembler Only
  def VMOVMSKPSr64r : PI<0x50, MRMSrcReg, (outs GR64:$dst), (ins VR128:$src),
             "movmskps\t{$src, $dst|$dst, $src}", [], IIC_SSE_MOVMSK,
             SSEPackedSingle>, TB, VEX, Sched<[WriteVecLogic]>;
  def VMOVMSKPDr64r : PI<0x50, MRMSrcReg, (outs GR64:$dst), (ins VR128:$src),
             "movmskpd\t{$src, $dst|$dst, $src}", [], IIC_SSE_MOVMSK,
             SSEPackedDouble>, TB,
             OpSize, VEX, Sched<[WriteVecLogic]>;
  def VMOVMSKPSYr64r : PI<0x50, MRMSrcReg, (outs GR64:$dst), (ins VR256:$src),
             "movmskps\t{$src, $dst|$dst, $src}", [], IIC_SSE_MOVMSK,
             SSEPackedSingle>, TB, VEX, VEX_L, Sched<[WriteVecLogic]>;
  def VMOVMSKPDYr64r : PI<0x50, MRMSrcReg, (outs GR64:$dst), (ins VR256:$src),
             "movmskpd\t{$src, $dst|$dst, $src}", [], IIC_SSE_MOVMSK,
             SSEPackedDouble>, TB,
             OpSize, VEX, VEX_L, Sched<[WriteVecLogic]>;
}

defm MOVMSKPS : sse12_extr_sign_mask<VR128, int_x86_sse_movmsk_ps, "movmskps",
                                     SSEPackedSingle>, TB;
defm MOVMSKPD : sse12_extr_sign_mask<VR128, int_x86_sse2_movmsk_pd, "movmskpd",
                                     SSEPackedDouble>, TB, OpSize;

def : Pat<(i32 (X86fgetsign FR32:$src)),
          (MOVMSKPSrr32 (COPY_TO_REGCLASS FR32:$src, VR128))>,
      Requires<[UseSSE1]>;
def : Pat<(i64 (X86fgetsign FR32:$src)),
          (MOVMSKPSrr64 (COPY_TO_REGCLASS FR32:$src, VR128))>,
      Requires<[UseSSE1]>;
def : Pat<(i32 (X86fgetsign FR64:$src)),
          (MOVMSKPDrr32 (COPY_TO_REGCLASS FR64:$src, VR128))>,
      Requires<[UseSSE2]>;
def : Pat<(i64 (X86fgetsign FR64:$src)),
          (MOVMSKPDrr64 (COPY_TO_REGCLASS FR64:$src, VR128))>,
      Requires<[UseSSE2]>;

//===---------------------------------------------------------------------===//
// SSE2 - Packed Integer Logical Instructions
//===---------------------------------------------------------------------===//

let ExeDomain = SSEPackedInt in { // SSE integer instructions

/// PDI_binop_rm - Simple SSE2 binary operator.
multiclass PDI_binop_rm<bits<8> opc, string OpcodeStr, SDNode OpNode,
                        ValueType OpVT, RegisterClass RC, PatFrag memop_frag,
                        X86MemOperand x86memop, OpndItins itins,
                        bit IsCommutable, bit Is2Addr> {
  let isCommutable = IsCommutable in
  def rr : PDI<opc, MRMSrcReg, (outs RC:$dst),
       (ins RC:$src1, RC:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (OpVT (OpNode RC:$src1, RC:$src2)))], itins.rr>,
       Sched<[itins.Sched]>;
  def rm : PDI<opc, MRMSrcMem, (outs RC:$dst),
       (ins RC:$src1, x86memop:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (OpVT (OpNode RC:$src1,
                                     (bitconvert (memop_frag addr:$src2)))))],
                                     itins.rm>,
       Sched<[itins.Sched.Folded, ReadAfterLd]>;
}
} // ExeDomain = SSEPackedInt

multiclass PDI_binop_all<bits<8> opc, string OpcodeStr, SDNode Opcode,
                         ValueType OpVT128, ValueType OpVT256,
                         OpndItins itins, bit IsCommutable = 0> {
let Predicates = [HasAVX] in
  defm V#NAME : PDI_binop_rm<opc, !strconcat("v", OpcodeStr), Opcode, OpVT128,
                    VR128, memopv2i64, i128mem, itins, IsCommutable, 0>, VEX_4V;

let Constraints = "$src1 = $dst" in
  defm NAME : PDI_binop_rm<opc, OpcodeStr, Opcode, OpVT128, VR128,
                           memopv2i64, i128mem, itins, IsCommutable, 1>;

let Predicates = [HasAVX2] in
  defm V#NAME#Y : PDI_binop_rm<opc, !strconcat("v", OpcodeStr), Opcode,
                               OpVT256, VR256, memopv4i64, i256mem, itins,
                               IsCommutable, 0>, VEX_4V, VEX_L;
}

// These are ordered here for pattern ordering requirements with the fp versions

defm PAND  : PDI_binop_all<0xDB, "pand", and, v2i64, v4i64, SSE_BIT_ITINS_P, 1>;
defm POR   : PDI_binop_all<0xEB, "por", or, v2i64, v4i64, SSE_BIT_ITINS_P, 1>;
defm PXOR  : PDI_binop_all<0xEF, "pxor", xor, v2i64, v4i64, SSE_BIT_ITINS_P, 1>;
defm PANDN : PDI_binop_all<0xDF, "pandn", X86andnp, v2i64, v4i64,
                           SSE_BIT_ITINS_P, 0>;

//===----------------------------------------------------------------------===//
// SSE 1 & 2 - Logical Instructions
//===----------------------------------------------------------------------===//

/// sse12_fp_alias_pack_logical - SSE 1 & 2 aliased packed FP logical ops
///
multiclass sse12_fp_alias_pack_logical<bits<8> opc, string OpcodeStr,
                                       SDNode OpNode, OpndItins itins> {
  defm V#NAME#PS : sse12_fp_packed<opc, !strconcat(OpcodeStr, "ps"), OpNode,
              FR32, f32, f128mem, memopfsf32, SSEPackedSingle, itins, 0>,
              TB, VEX_4V;

  defm V#NAME#PD : sse12_fp_packed<opc, !strconcat(OpcodeStr, "pd"), OpNode,
        FR64, f64, f128mem, memopfsf64, SSEPackedDouble, itins, 0>,
        TB, OpSize, VEX_4V;

  let Constraints = "$src1 = $dst" in {
    defm PS : sse12_fp_packed<opc, !strconcat(OpcodeStr, "ps"), OpNode, FR32,
                f32, f128mem, memopfsf32, SSEPackedSingle, itins>,
                TB;

    defm PD : sse12_fp_packed<opc, !strconcat(OpcodeStr, "pd"), OpNode, FR64,
                f64, f128mem, memopfsf64, SSEPackedDouble, itins>,
                TB, OpSize;
  }
}

// Alias bitwise logical operations using SSE logical ops on packed FP values.
defm FsAND  : sse12_fp_alias_pack_logical<0x54, "and", X86fand,
              SSE_BIT_ITINS_P>;
defm FsOR   : sse12_fp_alias_pack_logical<0x56, "or", X86for,
              SSE_BIT_ITINS_P>;
defm FsXOR  : sse12_fp_alias_pack_logical<0x57, "xor", X86fxor,
              SSE_BIT_ITINS_P>;

let neverHasSideEffects = 1, Pattern = []<dag>, isCommutable = 0 in
  defm FsANDN : sse12_fp_alias_pack_logical<0x55, "andn", undef,
                SSE_BIT_ITINS_P>;

/// sse12_fp_packed_logical - SSE 1 & 2 packed FP logical ops
///
multiclass sse12_fp_packed_logical<bits<8> opc, string OpcodeStr,
                                   SDNode OpNode> {
  defm V#NAME#PSY : sse12_fp_packed_logical_rm<opc, VR256, SSEPackedSingle,
        !strconcat(OpcodeStr, "ps"), f256mem,
        [(set VR256:$dst, (v4i64 (OpNode VR256:$src1, VR256:$src2)))],
        [(set VR256:$dst, (OpNode (bc_v4i64 (v8f32 VR256:$src1)),
                           (memopv4i64 addr:$src2)))], 0>, TB, VEX_4V, VEX_L;

  defm V#NAME#PDY : sse12_fp_packed_logical_rm<opc, VR256, SSEPackedDouble,
        !strconcat(OpcodeStr, "pd"), f256mem,
        [(set VR256:$dst, (OpNode (bc_v4i64 (v4f64 VR256:$src1)),
                                  (bc_v4i64 (v4f64 VR256:$src2))))],
        [(set VR256:$dst, (OpNode (bc_v4i64 (v4f64 VR256:$src1)),
                                  (memopv4i64 addr:$src2)))], 0>,
                                  TB, OpSize, VEX_4V, VEX_L;

  // In AVX no need to add a pattern for 128-bit logical rr ps, because they
  // are all promoted to v2i64, and the patterns are covered by the int
  // version. This is needed in SSE only, because v2i64 isn't supported on
  // SSE1, but only on SSE2.
  defm V#NAME#PS : sse12_fp_packed_logical_rm<opc, VR128, SSEPackedSingle,
       !strconcat(OpcodeStr, "ps"), f128mem, [],
       [(set VR128:$dst, (OpNode (bc_v2i64 (v4f32 VR128:$src1)),
                                 (memopv2i64 addr:$src2)))], 0>, TB, VEX_4V;

  defm V#NAME#PD : sse12_fp_packed_logical_rm<opc, VR128, SSEPackedDouble,
       !strconcat(OpcodeStr, "pd"), f128mem,
       [(set VR128:$dst, (OpNode (bc_v2i64 (v2f64 VR128:$src1)),
                                 (bc_v2i64 (v2f64 VR128:$src2))))],
       [(set VR128:$dst, (OpNode (bc_v2i64 (v2f64 VR128:$src1)),
                                 (memopv2i64 addr:$src2)))], 0>,
                                                 TB, OpSize, VEX_4V;

  let Constraints = "$src1 = $dst" in {
    defm PS : sse12_fp_packed_logical_rm<opc, VR128, SSEPackedSingle,
         !strconcat(OpcodeStr, "ps"), f128mem,
         [(set VR128:$dst, (v2i64 (OpNode VR128:$src1, VR128:$src2)))],
         [(set VR128:$dst, (OpNode (bc_v2i64 (v4f32 VR128:$src1)),
                                   (memopv2i64 addr:$src2)))]>, TB;

    defm PD : sse12_fp_packed_logical_rm<opc, VR128, SSEPackedDouble,
         !strconcat(OpcodeStr, "pd"), f128mem,
         [(set VR128:$dst, (OpNode (bc_v2i64 (v2f64 VR128:$src1)),
                                   (bc_v2i64 (v2f64 VR128:$src2))))],
         [(set VR128:$dst, (OpNode (bc_v2i64 (v2f64 VR128:$src1)),
                                   (memopv2i64 addr:$src2)))]>, TB, OpSize;
  }
}

defm AND  : sse12_fp_packed_logical<0x54, "and", and>;
defm OR   : sse12_fp_packed_logical<0x56, "or", or>;
defm XOR  : sse12_fp_packed_logical<0x57, "xor", xor>;
let isCommutable = 0 in
  defm ANDN : sse12_fp_packed_logical<0x55, "andn", X86andnp>;

//===----------------------------------------------------------------------===//
// SSE 1 & 2 - Arithmetic Instructions
//===----------------------------------------------------------------------===//

/// basic_sse12_fp_binop_xxx - SSE 1 & 2 binops come in both scalar and
/// vector forms.
///
/// In addition, we also have a special variant of the scalar form here to
/// represent the associated intrinsic operation.  This form is unlike the
/// plain scalar form, in that it takes an entire vector (instead of a scalar)
/// and leaves the top elements unmodified (therefore these cannot be commuted).
///
/// These three forms can each be reg+reg or reg+mem.
///

/// FIXME: once all 256-bit intrinsics are matched, cleanup and refactor those
/// classes below
multiclass basic_sse12_fp_binop_s<bits<8> opc, string OpcodeStr, SDNode OpNode,
                                  SizeItins itins,
                                  bit Is2Addr = 1> {
  defm SS : sse12_fp_scalar<opc, !strconcat(OpcodeStr, "ss"),
                            OpNode, FR32, f32mem,
                            itins.s, Is2Addr>, XS;
  defm SD : sse12_fp_scalar<opc, !strconcat(OpcodeStr, "sd"),
                            OpNode, FR64, f64mem,
                            itins.d, Is2Addr>, XD;
}

multiclass basic_sse12_fp_binop_p<bits<8> opc, string OpcodeStr,
                                  SDNode OpNode, SizeItins itins> {
let Predicates = [HasAVX] in {
  defm V#NAME#PS : sse12_fp_packed<opc, !strconcat(OpcodeStr, "ps"), OpNode,
                               VR128, v4f32, f128mem, memopv4f32,
                               SSEPackedSingle, itins.s, 0>, TB, VEX_4V;
  defm V#NAME#PD : sse12_fp_packed<opc, !strconcat(OpcodeStr, "pd"), OpNode,
                               VR128, v2f64, f128mem, memopv2f64,
                               SSEPackedDouble, itins.d, 0>, TB, OpSize, VEX_4V;

  defm V#NAME#PSY : sse12_fp_packed<opc, !strconcat(OpcodeStr, "ps"),
                        OpNode, VR256, v8f32, f256mem, memopv8f32,
                        SSEPackedSingle, itins.s, 0>, TB, VEX_4V, VEX_L;
  defm V#NAME#PDY : sse12_fp_packed<opc, !strconcat(OpcodeStr, "pd"),
                        OpNode, VR256, v4f64, f256mem, memopv4f64,
                        SSEPackedDouble, itins.d, 0>, TB, OpSize, VEX_4V, VEX_L;
}

let Constraints = "$src1 = $dst" in {
  defm PS : sse12_fp_packed<opc, !strconcat(OpcodeStr, "ps"), OpNode, VR128,
                            v4f32, f128mem, memopv4f32, SSEPackedSingle,
                            itins.s, 1>, TB;
  defm PD : sse12_fp_packed<opc, !strconcat(OpcodeStr, "pd"), OpNode, VR128,
                            v2f64, f128mem, memopv2f64, SSEPackedDouble,
                            itins.d, 1>, TB, OpSize;
}
}

multiclass basic_sse12_fp_binop_s_int<bits<8> opc, string OpcodeStr,
                                      SizeItins itins,
                                      bit Is2Addr = 1> {
  defm SS : sse12_fp_scalar_int<opc, OpcodeStr, VR128,
     !strconcat(OpcodeStr, "ss"), "", "_ss", ssmem, sse_load_f32,
     itins.s, Is2Addr>, XS;
  defm SD : sse12_fp_scalar_int<opc, OpcodeStr, VR128,
     !strconcat(OpcodeStr, "sd"), "2", "_sd", sdmem, sse_load_f64,
     itins.d, Is2Addr>, XD;
}

// Binary Arithmetic instructions
defm ADD : basic_sse12_fp_binop_p<0x58, "add", fadd, SSE_ALU_ITINS_P>;
defm MUL : basic_sse12_fp_binop_p<0x59, "mul", fmul, SSE_MUL_ITINS_P>;
let isCommutable = 0 in {
  defm SUB : basic_sse12_fp_binop_p<0x5C, "sub", fsub, SSE_ALU_ITINS_P>;
  defm DIV : basic_sse12_fp_binop_p<0x5E, "div", fdiv, SSE_DIV_ITINS_P>;
  defm MAX : basic_sse12_fp_binop_p<0x5F, "max", X86fmax, SSE_ALU_ITINS_P>;
  defm MIN : basic_sse12_fp_binop_p<0x5D, "min", X86fmin, SSE_ALU_ITINS_P>;
}

let isCodeGenOnly = 1 in {
  defm MAXC: basic_sse12_fp_binop_p<0x5F, "max", X86fmaxc, SSE_ALU_ITINS_P>;
  defm MINC: basic_sse12_fp_binop_p<0x5D, "min", X86fminc, SSE_ALU_ITINS_P>;
}

defm VADD : basic_sse12_fp_binop_s<0x58, "add", fadd, SSE_ALU_ITINS_S, 0>,
            basic_sse12_fp_binop_s_int<0x58, "add", SSE_ALU_ITINS_S, 0>,
              VEX_4V, VEX_LIG;
defm VMUL : basic_sse12_fp_binop_s<0x59, "mul", fmul, SSE_MUL_ITINS_S, 0>,
            basic_sse12_fp_binop_s_int<0x59, "mul", SSE_MUL_ITINS_S, 0>,
              VEX_4V, VEX_LIG;

let isCommutable = 0 in {
  defm VSUB : basic_sse12_fp_binop_s<0x5C, "sub", fsub, SSE_ALU_ITINS_S, 0>,
              basic_sse12_fp_binop_s_int<0x5C, "sub", SSE_ALU_ITINS_S, 0>,
                VEX_4V, VEX_LIG;
  defm VDIV : basic_sse12_fp_binop_s<0x5E, "div", fdiv, SSE_DIV_ITINS_S, 0>,
              basic_sse12_fp_binop_s_int<0x5E, "div", SSE_DIV_ITINS_S, 0>,
                VEX_4V, VEX_LIG;
  defm VMAX : basic_sse12_fp_binop_s<0x5F, "max", X86fmax, SSE_ALU_ITINS_S, 0>,
              basic_sse12_fp_binop_s_int<0x5F, "max", SSE_ALU_ITINS_S, 0>,
                VEX_4V, VEX_LIG;
  defm VMIN : basic_sse12_fp_binop_s<0x5D, "min", X86fmin, SSE_ALU_ITINS_S, 0>,
              basic_sse12_fp_binop_s_int<0x5D, "min", SSE_ALU_ITINS_S, 0>,
                VEX_4V, VEX_LIG;
}

let Constraints = "$src1 = $dst" in {
  defm ADD : basic_sse12_fp_binop_s<0x58, "add", fadd, SSE_ALU_ITINS_S>,
             basic_sse12_fp_binop_s_int<0x58, "add", SSE_ALU_ITINS_S>;
  defm MUL : basic_sse12_fp_binop_s<0x59, "mul", fmul, SSE_MUL_ITINS_S>,
             basic_sse12_fp_binop_s_int<0x59, "mul", SSE_MUL_ITINS_S>;

  let isCommutable = 0 in {
    defm SUB : basic_sse12_fp_binop_s<0x5C, "sub", fsub, SSE_ALU_ITINS_S>,
               basic_sse12_fp_binop_s_int<0x5C, "sub", SSE_ALU_ITINS_S>;
    defm DIV : basic_sse12_fp_binop_s<0x5E, "div", fdiv, SSE_DIV_ITINS_S>,
               basic_sse12_fp_binop_s_int<0x5E, "div", SSE_DIV_ITINS_S>;
    defm MAX : basic_sse12_fp_binop_s<0x5F, "max", X86fmax, SSE_ALU_ITINS_S>,
               basic_sse12_fp_binop_s_int<0x5F, "max", SSE_ALU_ITINS_S>;
    defm MIN : basic_sse12_fp_binop_s<0x5D, "min", X86fmin, SSE_ALU_ITINS_S>,
               basic_sse12_fp_binop_s_int<0x5D, "min", SSE_ALU_ITINS_S>;
  }
}

let isCodeGenOnly = 1 in {
  defm VMAXC: basic_sse12_fp_binop_s<0x5F, "max", X86fmaxc, SSE_ALU_ITINS_S, 0>,
       VEX_4V, VEX_LIG;
  defm VMINC: basic_sse12_fp_binop_s<0x5D, "min", X86fminc, SSE_ALU_ITINS_S, 0>,
       VEX_4V, VEX_LIG;
  let Constraints = "$src1 = $dst" in {
    defm MAXC: basic_sse12_fp_binop_s<0x5F, "max", X86fmaxc, SSE_ALU_ITINS_S>;
    defm MINC: basic_sse12_fp_binop_s<0x5D, "min", X86fminc, SSE_ALU_ITINS_S>;
  }
}

/// Unop Arithmetic
/// In addition, we also have a special variant of the scalar form here to
/// represent the associated intrinsic operation.  This form is unlike the
/// plain scalar form, in that it takes an entire vector (instead of a
/// scalar) and leaves the top elements undefined.
///
/// And, we have a special variant form for a full-vector intrinsic form.

let Sched = WriteFSqrt in {
def SSE_SQRTPS : OpndItins<
  IIC_SSE_SQRTPS_RR, IIC_SSE_SQRTPS_RM
>;

def SSE_SQRTSS : OpndItins<
  IIC_SSE_SQRTSS_RR, IIC_SSE_SQRTSS_RM
>;

def SSE_SQRTPD : OpndItins<
  IIC_SSE_SQRTPD_RR, IIC_SSE_SQRTPD_RM
>;

def SSE_SQRTSD : OpndItins<
  IIC_SSE_SQRTSD_RR, IIC_SSE_SQRTSD_RM
>;
}

let Sched = WriteFRcp in {
def SSE_RCPP : OpndItins<
  IIC_SSE_RCPP_RR, IIC_SSE_RCPP_RM
>;

def SSE_RCPS : OpndItins<
  IIC_SSE_RCPS_RR, IIC_SSE_RCPS_RM
>;
}

/// sse1_fp_unop_s - SSE1 unops in scalar form.
multiclass sse1_fp_unop_s<bits<8> opc, string OpcodeStr,
                          SDNode OpNode, Intrinsic F32Int, OpndItins itins> {
let Predicates = [HasAVX], hasSideEffects = 0 in {
  def V#NAME#SSr : SSI<opc, MRMSrcReg, (outs FR32:$dst),
                      (ins FR32:$src1, FR32:$src2),
                      !strconcat("v", OpcodeStr,
                                 "ss\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                      []>, VEX_4V, VEX_LIG, Sched<[itins.Sched]>;
  let mayLoad = 1 in {
  def V#NAME#SSm : SSI<opc, MRMSrcMem, (outs FR32:$dst),
                      (ins FR32:$src1,f32mem:$src2),
                      !strconcat("v", OpcodeStr,
                                 "ss\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                      []>, VEX_4V, VEX_LIG,
                   Sched<[itins.Sched.Folded, ReadAfterLd]>;
  def V#NAME#SSm_Int : SSI<opc, MRMSrcMem, (outs VR128:$dst),
                      (ins VR128:$src1, ssmem:$src2),
                      !strconcat("v", OpcodeStr,
                                 "ss\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                      []>, VEX_4V, VEX_LIG,
                      Sched<[itins.Sched.Folded, ReadAfterLd]>;
  }
}

  def SSr : SSI<opc, MRMSrcReg, (outs FR32:$dst), (ins FR32:$src),
                !strconcat(OpcodeStr, "ss\t{$src, $dst|$dst, $src}"),
                [(set FR32:$dst, (OpNode FR32:$src))]>, Sched<[itins.Sched]>;
  // For scalar unary operations, fold a load into the operation
  // only in OptForSize mode. It eliminates an instruction, but it also
  // eliminates a whole-register clobber (the load), so it introduces a
  // partial register update condition.
  def SSm : I<opc, MRMSrcMem, (outs FR32:$dst), (ins f32mem:$src),
                !strconcat(OpcodeStr, "ss\t{$src, $dst|$dst, $src}"),
                [(set FR32:$dst, (OpNode (load addr:$src)))], itins.rm>, XS,
            Requires<[UseSSE1, OptForSize]>, Sched<[itins.Sched.Folded]>;
  def SSr_Int : SSI<opc, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                    !strconcat(OpcodeStr, "ss\t{$src, $dst|$dst, $src}"),
                    [(set VR128:$dst, (F32Int VR128:$src))], itins.rr>,
                Sched<[itins.Sched]>;
  def SSm_Int : SSI<opc, MRMSrcMem, (outs VR128:$dst), (ins ssmem:$src),
                    !strconcat(OpcodeStr, "ss\t{$src, $dst|$dst, $src}"),
                    [(set VR128:$dst, (F32Int sse_load_f32:$src))], itins.rm>,
                Sched<[itins.Sched.Folded]>;
}

/// sse1_fp_unop_s_rw - SSE1 unops where vector form has a read-write operand.
multiclass sse1_fp_unop_rw<bits<8> opc, string OpcodeStr, SDNode OpNode,
                           OpndItins itins> {
let Predicates = [HasAVX], hasSideEffects = 0 in {
  def V#NAME#SSr : SSI<opc, MRMSrcReg, (outs FR32:$dst),
                       (ins FR32:$src1, FR32:$src2),
                       !strconcat("v", OpcodeStr,
                           "ss\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                []>, VEX_4V, VEX_LIG, Sched<[itins.Sched]>;
  let mayLoad = 1 in {
  def V#NAME#SSm : SSI<opc, MRMSrcMem, (outs FR32:$dst),
                      (ins FR32:$src1,f32mem:$src2),
                      !strconcat("v", OpcodeStr,
                                 "ss\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                      []>, VEX_4V, VEX_LIG,
                   Sched<[itins.Sched.Folded, ReadAfterLd]>;
  def V#NAME#SSm_Int : SSI<opc, MRMSrcMem, (outs VR128:$dst),
                      (ins VR128:$src1, ssmem:$src2),
                      !strconcat("v", OpcodeStr,
                                 "ss\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                      []>, VEX_4V, VEX_LIG,
                      Sched<[itins.Sched.Folded, ReadAfterLd]>;
  }
}

  def SSr : SSI<opc, MRMSrcReg, (outs FR32:$dst), (ins FR32:$src),
                !strconcat(OpcodeStr, "ss\t{$src, $dst|$dst, $src}"),
                [(set FR32:$dst, (OpNode FR32:$src))]>, Sched<[itins.Sched]>;
  // For scalar unary operations, fold a load into the operation
  // only in OptForSize mode. It eliminates an instruction, but it also
  // eliminates a whole-register clobber (the load), so it introduces a
  // partial register update condition.
  def SSm : I<opc, MRMSrcMem, (outs FR32:$dst), (ins f32mem:$src),
                !strconcat(OpcodeStr, "ss\t{$src, $dst|$dst, $src}"),
                [(set FR32:$dst, (OpNode (load addr:$src)))], itins.rm>, XS,
            Requires<[UseSSE1, OptForSize]>, Sched<[itins.Sched.Folded]>;
  let Constraints = "$src1 = $dst" in {
    def SSr_Int : SSI<opc, MRMSrcReg, (outs VR128:$dst),
                      (ins VR128:$src1, VR128:$src2),
                      !strconcat(OpcodeStr, "ss\t{$src2, $dst|$dst, $src2}"),
                      [], itins.rr>, Sched<[itins.Sched]>;
    let mayLoad = 1, hasSideEffects = 0 in
    def SSm_Int : SSI<opc, MRMSrcMem, (outs VR128:$dst),
                      (ins VR128:$src1, ssmem:$src2),
                      !strconcat(OpcodeStr, "ss\t{$src2, $dst|$dst, $src2}"),
                      [], itins.rm>, Sched<[itins.Sched.Folded, ReadAfterLd]>;
  }
}

/// sse1_fp_unop_p - SSE1 unops in packed form.
multiclass sse1_fp_unop_p<bits<8> opc, string OpcodeStr, SDNode OpNode,
                          OpndItins itins> {
let Predicates = [HasAVX] in {
  def V#NAME#PSr : PSI<opc, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                       !strconcat("v", OpcodeStr,
                                  "ps\t{$src, $dst|$dst, $src}"),
                       [(set VR128:$dst, (v4f32 (OpNode VR128:$src)))],
                       itins.rr>, VEX, Sched<[itins.Sched]>;
  def V#NAME#PSm : PSI<opc, MRMSrcMem, (outs VR128:$dst), (ins f128mem:$src),
                       !strconcat("v", OpcodeStr,
                                  "ps\t{$src, $dst|$dst, $src}"),
                       [(set VR128:$dst, (OpNode (memopv4f32 addr:$src)))],
                       itins.rm>, VEX, Sched<[itins.Sched.Folded]>;
  def V#NAME#PSYr : PSI<opc, MRMSrcReg, (outs VR256:$dst), (ins VR256:$src),
                        !strconcat("v", OpcodeStr,
                                   "ps\t{$src, $dst|$dst, $src}"),
                        [(set VR256:$dst, (v8f32 (OpNode VR256:$src)))],
                        itins.rr>, VEX, VEX_L, Sched<[itins.Sched]>;
  def V#NAME#PSYm : PSI<opc, MRMSrcMem, (outs VR256:$dst), (ins f256mem:$src),
                        !strconcat("v", OpcodeStr,
                                   "ps\t{$src, $dst|$dst, $src}"),
                        [(set VR256:$dst, (OpNode (memopv8f32 addr:$src)))],
                        itins.rm>, VEX, VEX_L, Sched<[itins.Sched.Folded]>;
}

  def PSr : PSI<opc, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                !strconcat(OpcodeStr, "ps\t{$src, $dst|$dst, $src}"),
                [(set VR128:$dst, (v4f32 (OpNode VR128:$src)))], itins.rr>,
            Sched<[itins.Sched]>;
  def PSm : PSI<opc, MRMSrcMem, (outs VR128:$dst), (ins f128mem:$src),
                !strconcat(OpcodeStr, "ps\t{$src, $dst|$dst, $src}"),
                [(set VR128:$dst, (OpNode (memopv4f32 addr:$src)))], itins.rm>,
            Sched<[itins.Sched.Folded]>;
}

/// sse1_fp_unop_p_int - SSE1 intrinsics unops in packed forms.
multiclass sse1_fp_unop_p_int<bits<8> opc, string OpcodeStr,
                              Intrinsic V4F32Int, Intrinsic V8F32Int,
                              OpndItins itins> {
let Predicates = [HasAVX] in {
  def V#NAME#PSr_Int : PSI<opc, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                           !strconcat("v", OpcodeStr,
                                      "ps\t{$src, $dst|$dst, $src}"),
                           [(set VR128:$dst, (V4F32Int VR128:$src))],
                           itins.rr>, VEX, Sched<[itins.Sched]>;
  def V#NAME#PSm_Int : PSI<opc, MRMSrcMem, (outs VR128:$dst), (ins f128mem:$src),
                          !strconcat("v", OpcodeStr,
                          "ps\t{$src, $dst|$dst, $src}"),
                          [(set VR128:$dst, (V4F32Int (memopv4f32 addr:$src)))],
                          itins.rm>, VEX, Sched<[itins.Sched.Folded]>;
  def V#NAME#PSYr_Int : PSI<opc, MRMSrcReg, (outs VR256:$dst), (ins VR256:$src),
                            !strconcat("v", OpcodeStr,
                                       "ps\t{$src, $dst|$dst, $src}"),
                            [(set VR256:$dst, (V8F32Int VR256:$src))],
                            itins.rr>, VEX, VEX_L, Sched<[itins.Sched]>;
  def V#NAME#PSYm_Int : PSI<opc, MRMSrcMem, (outs VR256:$dst),
                          (ins f256mem:$src),
                          !strconcat("v", OpcodeStr,
                                    "ps\t{$src, $dst|$dst, $src}"),
                          [(set VR256:$dst, (V8F32Int (memopv8f32 addr:$src)))],
                          itins.rm>, VEX, VEX_L, Sched<[itins.Sched.Folded]>;
}

  def PSr_Int : PSI<opc, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                    !strconcat(OpcodeStr, "ps\t{$src, $dst|$dst, $src}"),
                    [(set VR128:$dst, (V4F32Int VR128:$src))],
                    itins.rr>, Sched<[itins.Sched]>;
  def PSm_Int : PSI<opc, MRMSrcMem, (outs VR128:$dst), (ins f128mem:$src),
                    !strconcat(OpcodeStr, "ps\t{$src, $dst|$dst, $src}"),
                    [(set VR128:$dst, (V4F32Int (memopv4f32 addr:$src)))],
                    itins.rm>, Sched<[itins.Sched.Folded]>;
}

/// sse2_fp_unop_s - SSE2 unops in scalar form.
multiclass sse2_fp_unop_s<bits<8> opc, string OpcodeStr,
                          SDNode OpNode, Intrinsic F64Int, OpndItins itins> {
let Predicates = [HasAVX], hasSideEffects = 0 in {
  def V#NAME#SDr : SDI<opc, MRMSrcReg, (outs FR64:$dst),
                      (ins FR64:$src1, FR64:$src2),
                      !strconcat("v", OpcodeStr,
                                 "sd\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                      []>, VEX_4V, VEX_LIG, Sched<[itins.Sched]>;
  let mayLoad = 1 in {
  def V#NAME#SDm : SDI<opc, MRMSrcMem, (outs FR64:$dst),
                      (ins FR64:$src1,f64mem:$src2),
                      !strconcat("v", OpcodeStr,
                                 "sd\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                      []>, VEX_4V, VEX_LIG,
                   Sched<[itins.Sched.Folded, ReadAfterLd]>;
  def V#NAME#SDm_Int : SDI<opc, MRMSrcMem, (outs VR128:$dst),
                      (ins VR128:$src1, sdmem:$src2),
                      !strconcat("v", OpcodeStr,
                                 "sd\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                      []>, VEX_4V, VEX_LIG,
                      Sched<[itins.Sched.Folded, ReadAfterLd]>;
  }
}

  def SDr : SDI<opc, MRMSrcReg, (outs FR64:$dst), (ins FR64:$src),
                !strconcat(OpcodeStr, "sd\t{$src, $dst|$dst, $src}"),
                [(set FR64:$dst, (OpNode FR64:$src))], itins.rr>,
            Sched<[itins.Sched]>;
  // See the comments in sse1_fp_unop_s for why this is OptForSize.
  def SDm : I<opc, MRMSrcMem, (outs FR64:$dst), (ins f64mem:$src),
                !strconcat(OpcodeStr, "sd\t{$src, $dst|$dst, $src}"),
                [(set FR64:$dst, (OpNode (load addr:$src)))], itins.rm>, XD,
            Requires<[UseSSE2, OptForSize]>, Sched<[itins.Sched.Folded]>;
  def SDr_Int : SDI<opc, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                    !strconcat(OpcodeStr, "sd\t{$src, $dst|$dst, $src}"),
                    [(set VR128:$dst, (F64Int VR128:$src))], itins.rr>,
                Sched<[itins.Sched]>;
  def SDm_Int : SDI<opc, MRMSrcMem, (outs VR128:$dst), (ins sdmem:$src),
                    !strconcat(OpcodeStr, "sd\t{$src, $dst|$dst, $src}"),
                    [(set VR128:$dst, (F64Int sse_load_f64:$src))], itins.rm>,
                Sched<[itins.Sched.Folded]>;
}

/// sse2_fp_unop_p - SSE2 unops in vector forms.
multiclass sse2_fp_unop_p<bits<8> opc, string OpcodeStr,
                          SDNode OpNode, OpndItins itins> {
let Predicates = [HasAVX] in {
  def V#NAME#PDr : PDI<opc, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                       !strconcat("v", OpcodeStr,
                                  "pd\t{$src, $dst|$dst, $src}"),
                       [(set VR128:$dst, (v2f64 (OpNode VR128:$src)))],
                       itins.rr>, VEX, Sched<[itins.Sched]>;
  def V#NAME#PDm : PDI<opc, MRMSrcMem, (outs VR128:$dst), (ins f128mem:$src),
                       !strconcat("v", OpcodeStr,
                                  "pd\t{$src, $dst|$dst, $src}"),
                       [(set VR128:$dst, (OpNode (memopv2f64 addr:$src)))],
                       itins.rm>, VEX, Sched<[itins.Sched.Folded]>;
  def V#NAME#PDYr : PDI<opc, MRMSrcReg, (outs VR256:$dst), (ins VR256:$src),
                        !strconcat("v", OpcodeStr,
                                   "pd\t{$src, $dst|$dst, $src}"),
                        [(set VR256:$dst, (v4f64 (OpNode VR256:$src)))],
                        itins.rr>, VEX, VEX_L, Sched<[itins.Sched]>;
  def V#NAME#PDYm : PDI<opc, MRMSrcMem, (outs VR256:$dst), (ins f256mem:$src),
                        !strconcat("v", OpcodeStr,
                                   "pd\t{$src, $dst|$dst, $src}"),
                        [(set VR256:$dst, (OpNode (memopv4f64 addr:$src)))],
                        itins.rm>, VEX, VEX_L, Sched<[itins.Sched.Folded]>;
}

  def PDr : PDI<opc, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
              !strconcat(OpcodeStr, "pd\t{$src, $dst|$dst, $src}"),
              [(set VR128:$dst, (v2f64 (OpNode VR128:$src)))], itins.rr>,
            Sched<[itins.Sched]>;
  def PDm : PDI<opc, MRMSrcMem, (outs VR128:$dst), (ins f128mem:$src),
                !strconcat(OpcodeStr, "pd\t{$src, $dst|$dst, $src}"),
                [(set VR128:$dst, (OpNode (memopv2f64 addr:$src)))], itins.rm>,
            Sched<[itins.Sched.Folded]>;
}

// Square root.
defm SQRT  : sse1_fp_unop_s<0x51, "sqrt",  fsqrt, int_x86_sse_sqrt_ss,
                            SSE_SQRTSS>,
             sse1_fp_unop_p<0x51, "sqrt", fsqrt, SSE_SQRTPS>,
             sse2_fp_unop_s<0x51, "sqrt",  fsqrt, int_x86_sse2_sqrt_sd,
                            SSE_SQRTSD>,
             sse2_fp_unop_p<0x51, "sqrt", fsqrt, SSE_SQRTPD>;

// Reciprocal approximations. Note that these typically require refinement
// in order to obtain suitable precision.
defm RSQRT : sse1_fp_unop_rw<0x52, "rsqrt", X86frsqrt, SSE_SQRTSS>,
             sse1_fp_unop_p<0x52, "rsqrt", X86frsqrt, SSE_SQRTPS>,
             sse1_fp_unop_p_int<0x52, "rsqrt", int_x86_sse_rsqrt_ps,
                                int_x86_avx_rsqrt_ps_256, SSE_SQRTPS>;
defm RCP   : sse1_fp_unop_rw<0x53, "rcp", X86frcp, SSE_RCPS>,
             sse1_fp_unop_p<0x53, "rcp", X86frcp, SSE_RCPP>,
             sse1_fp_unop_p_int<0x53, "rcp", int_x86_sse_rcp_ps,
                                int_x86_avx_rcp_ps_256, SSE_RCPP>;

def : Pat<(f32 (fsqrt FR32:$src)),
          (VSQRTSSr (f32 (IMPLICIT_DEF)), FR32:$src)>, Requires<[HasAVX]>;
def : Pat<(f32 (fsqrt (load addr:$src))),
          (VSQRTSSm (f32 (IMPLICIT_DEF)), addr:$src)>,
          Requires<[HasAVX, OptForSize]>;
def : Pat<(f64 (fsqrt FR64:$src)),
          (VSQRTSDr (f64 (IMPLICIT_DEF)), FR64:$src)>, Requires<[HasAVX]>;
def : Pat<(f64 (fsqrt (load addr:$src))),
          (VSQRTSDm (f64 (IMPLICIT_DEF)), addr:$src)>,
          Requires<[HasAVX, OptForSize]>;

def : Pat<(f32 (X86frsqrt FR32:$src)),
          (VRSQRTSSr (f32 (IMPLICIT_DEF)), FR32:$src)>, Requires<[HasAVX]>;
def : Pat<(f32 (X86frsqrt (load addr:$src))),
          (VRSQRTSSm (f32 (IMPLICIT_DEF)), addr:$src)>,
          Requires<[HasAVX, OptForSize]>;

def : Pat<(f32 (X86frcp FR32:$src)),
          (VRCPSSr (f32 (IMPLICIT_DEF)), FR32:$src)>, Requires<[HasAVX]>;
def : Pat<(f32 (X86frcp (load addr:$src))),
          (VRCPSSm (f32 (IMPLICIT_DEF)), addr:$src)>,
          Requires<[HasAVX, OptForSize]>;

let Predicates = [HasAVX] in {
  def : Pat<(int_x86_sse_sqrt_ss VR128:$src),
            (COPY_TO_REGCLASS (VSQRTSSr (f32 (IMPLICIT_DEF)),
                                        (COPY_TO_REGCLASS VR128:$src, FR32)),
                              VR128)>;
  def : Pat<(int_x86_sse_sqrt_ss sse_load_f32:$src),
            (VSQRTSSm_Int (v4f32 (IMPLICIT_DEF)), sse_load_f32:$src)>;

  def : Pat<(int_x86_sse2_sqrt_sd VR128:$src),
            (COPY_TO_REGCLASS (VSQRTSDr (f64 (IMPLICIT_DEF)),
                                        (COPY_TO_REGCLASS VR128:$src, FR64)),
                              VR128)>;
  def : Pat<(int_x86_sse2_sqrt_sd sse_load_f64:$src),
            (VSQRTSDm_Int (v2f64 (IMPLICIT_DEF)), sse_load_f64:$src)>;

  def : Pat<(int_x86_sse_rsqrt_ss VR128:$src),
            (COPY_TO_REGCLASS (VRSQRTSSr (f32 (IMPLICIT_DEF)),
                                         (COPY_TO_REGCLASS VR128:$src, FR32)),
                              VR128)>;
  def : Pat<(int_x86_sse_rsqrt_ss sse_load_f32:$src),
            (VRSQRTSSm_Int (v4f32 (IMPLICIT_DEF)), sse_load_f32:$src)>;

  def : Pat<(int_x86_sse_rcp_ss VR128:$src),
            (COPY_TO_REGCLASS (VRCPSSr (f32 (IMPLICIT_DEF)),
                                       (COPY_TO_REGCLASS VR128:$src, FR32)),
                              VR128)>;
  def : Pat<(int_x86_sse_rcp_ss sse_load_f32:$src),
            (VRCPSSm_Int (v4f32 (IMPLICIT_DEF)), sse_load_f32:$src)>;
}

// Reciprocal approximations. Note that these typically require refinement
// in order to obtain suitable precision.
let Predicates = [UseSSE1] in {
  def : Pat<(int_x86_sse_rsqrt_ss VR128:$src),
            (RSQRTSSr_Int VR128:$src, VR128:$src)>;
  def : Pat<(int_x86_sse_rcp_ss VR128:$src),
            (RCPSSr_Int VR128:$src, VR128:$src)>;
}

// There is no f64 version of the reciprocal approximation instructions.

//===----------------------------------------------------------------------===//
// SSE 1 & 2 - Non-temporal stores
//===----------------------------------------------------------------------===//

let AddedComplexity = 400 in { // Prefer non-temporal versions
let SchedRW = [WriteStore] in {
def VMOVNTPSmr : VPSI<0x2B, MRMDestMem, (outs),
                     (ins f128mem:$dst, VR128:$src),
                     "movntps\t{$src, $dst|$dst, $src}",
                     [(alignednontemporalstore (v4f32 VR128:$src),
                                               addr:$dst)],
                                               IIC_SSE_MOVNT>, VEX;
def VMOVNTPDmr : VPDI<0x2B, MRMDestMem, (outs),
                     (ins f128mem:$dst, VR128:$src),
                     "movntpd\t{$src, $dst|$dst, $src}",
                     [(alignednontemporalstore (v2f64 VR128:$src),
                                               addr:$dst)],
                                               IIC_SSE_MOVNT>, VEX;

let ExeDomain = SSEPackedInt in
def VMOVNTDQmr    : VPDI<0xE7, MRMDestMem, (outs),
                         (ins f128mem:$dst, VR128:$src),
                         "movntdq\t{$src, $dst|$dst, $src}",
                         [(alignednontemporalstore (v2i64 VR128:$src),
                                                   addr:$dst)],
                                                   IIC_SSE_MOVNT>, VEX;

def VMOVNTPSYmr : VPSI<0x2B, MRMDestMem, (outs),
                     (ins f256mem:$dst, VR256:$src),
                     "movntps\t{$src, $dst|$dst, $src}",
                     [(alignednontemporalstore (v8f32 VR256:$src),
                                               addr:$dst)],
                                               IIC_SSE_MOVNT>, VEX, VEX_L;
def VMOVNTPDYmr : VPDI<0x2B, MRMDestMem, (outs),
                     (ins f256mem:$dst, VR256:$src),
                     "movntpd\t{$src, $dst|$dst, $src}",
                     [(alignednontemporalstore (v4f64 VR256:$src),
                                               addr:$dst)],
                                               IIC_SSE_MOVNT>, VEX, VEX_L;
let ExeDomain = SSEPackedInt in
def VMOVNTDQYmr : VPDI<0xE7, MRMDestMem, (outs),
                    (ins f256mem:$dst, VR256:$src),
                    "movntdq\t{$src, $dst|$dst, $src}",
                    [(alignednontemporalstore (v4i64 VR256:$src),
                                              addr:$dst)],
                                              IIC_SSE_MOVNT>, VEX, VEX_L;

def MOVNTPSmr : PSI<0x2B, MRMDestMem, (outs), (ins f128mem:$dst, VR128:$src),
                    "movntps\t{$src, $dst|$dst, $src}",
                    [(alignednontemporalstore (v4f32 VR128:$src), addr:$dst)],
                    IIC_SSE_MOVNT>;
def MOVNTPDmr : PDI<0x2B, MRMDestMem, (outs), (ins f128mem:$dst, VR128:$src),
                    "movntpd\t{$src, $dst|$dst, $src}",
                    [(alignednontemporalstore(v2f64 VR128:$src), addr:$dst)],
                    IIC_SSE_MOVNT>;

let ExeDomain = SSEPackedInt in
def MOVNTDQmr : PDI<0xE7, MRMDestMem, (outs), (ins f128mem:$dst, VR128:$src),
                    "movntdq\t{$src, $dst|$dst, $src}",
                    [(alignednontemporalstore (v2i64 VR128:$src), addr:$dst)],
                    IIC_SSE_MOVNT>;

// There is no AVX form for instructions below this point
def MOVNTImr : I<0xC3, MRMDestMem, (outs), (ins i32mem:$dst, GR32:$src),
                 "movnti{l}\t{$src, $dst|$dst, $src}",
                 [(nontemporalstore (i32 GR32:$src), addr:$dst)],
                 IIC_SSE_MOVNT>,
               TB, Requires<[HasSSE2]>;
def MOVNTI_64mr : RI<0xC3, MRMDestMem, (outs), (ins i64mem:$dst, GR64:$src),
                     "movnti{q}\t{$src, $dst|$dst, $src}",
                     [(nontemporalstore (i64 GR64:$src), addr:$dst)],
                     IIC_SSE_MOVNT>,
                  TB, Requires<[HasSSE2]>;
} // SchedRW = [WriteStore]

def : Pat<(alignednontemporalstore (v2i64 VR128:$src), addr:$dst),
          (VMOVNTDQmr addr:$dst, VR128:$src)>, Requires<[HasAVX]>;

def : Pat<(alignednontemporalstore (v2i64 VR128:$src), addr:$dst),
          (MOVNTDQmr addr:$dst, VR128:$src)>, Requires<[UseSSE2]>;
} // AddedComplexity

//===----------------------------------------------------------------------===//
// SSE 1 & 2 - Prefetch and memory fence
//===----------------------------------------------------------------------===//

// Prefetch intrinsic.
let Predicates = [HasSSE1], SchedRW = [WriteLoad] in {
def PREFETCHT0   : I<0x18, MRM1m, (outs), (ins i8mem:$src),
    "prefetcht0\t$src", [(prefetch addr:$src, imm, (i32 3), (i32 1))],
    IIC_SSE_PREFETCH>, TB;
def PREFETCHT1   : I<0x18, MRM2m, (outs), (ins i8mem:$src),
    "prefetcht1\t$src", [(prefetch addr:$src, imm, (i32 2), (i32 1))],
    IIC_SSE_PREFETCH>, TB;
def PREFETCHT2   : I<0x18, MRM3m, (outs), (ins i8mem:$src),
    "prefetcht2\t$src", [(prefetch addr:$src, imm, (i32 1), (i32 1))],
    IIC_SSE_PREFETCH>, TB;
def PREFETCHNTA  : I<0x18, MRM0m, (outs), (ins i8mem:$src),
    "prefetchnta\t$src", [(prefetch addr:$src, imm, (i32 0), (i32 1))],
    IIC_SSE_PREFETCH>, TB;
}

// FIXME: How should these memory instructions be modeled?
let SchedRW = [WriteLoad] in {
// Flush cache
def CLFLUSH : I<0xAE, MRM7m, (outs), (ins i8mem:$src),
               "clflush\t$src", [(int_x86_sse2_clflush addr:$src)],
               IIC_SSE_PREFETCH>, TB, Requires<[HasSSE2]>;

// Pause. This "instruction" is encoded as "rep; nop", so even though it
// was introduced with SSE2, it's backward compatible.
def PAUSE : I<0x90, RawFrm, (outs), (ins), "pause", [], IIC_SSE_PAUSE>, REP;

// Load, store, and memory fence
def SFENCE : I<0xAE, MRM_F8, (outs), (ins),
               "sfence", [(int_x86_sse_sfence)], IIC_SSE_SFENCE>,
               TB, Requires<[HasSSE1]>;
def LFENCE : I<0xAE, MRM_E8, (outs), (ins),
               "lfence", [(int_x86_sse2_lfence)], IIC_SSE_LFENCE>,
               TB, Requires<[HasSSE2]>;
def MFENCE : I<0xAE, MRM_F0, (outs), (ins),
               "mfence", [(int_x86_sse2_mfence)], IIC_SSE_MFENCE>,
               TB, Requires<[HasSSE2]>;
} // SchedRW

def : Pat<(X86SFence), (SFENCE)>;
def : Pat<(X86LFence), (LFENCE)>;
def : Pat<(X86MFence), (MFENCE)>;

//===----------------------------------------------------------------------===//
// SSE 1 & 2 - Load/Store XCSR register
//===----------------------------------------------------------------------===//

def VLDMXCSR : VPSI<0xAE, MRM2m, (outs), (ins i32mem:$src),
                  "ldmxcsr\t$src", [(int_x86_sse_ldmxcsr addr:$src)],
                  IIC_SSE_LDMXCSR>, VEX, Sched<[WriteLoad]>;
def VSTMXCSR : VPSI<0xAE, MRM3m, (outs), (ins i32mem:$dst),
                  "stmxcsr\t$dst", [(int_x86_sse_stmxcsr addr:$dst)],
                  IIC_SSE_STMXCSR>, VEX, Sched<[WriteStore]>;

def LDMXCSR : PSI<0xAE, MRM2m, (outs), (ins i32mem:$src),
                  "ldmxcsr\t$src", [(int_x86_sse_ldmxcsr addr:$src)],
                  IIC_SSE_LDMXCSR>, Sched<[WriteLoad]>;
def STMXCSR : PSI<0xAE, MRM3m, (outs), (ins i32mem:$dst),
                  "stmxcsr\t$dst", [(int_x86_sse_stmxcsr addr:$dst)],
                  IIC_SSE_STMXCSR>, Sched<[WriteStore]>;

//===---------------------------------------------------------------------===//
// SSE2 - Move Aligned/Unaligned Packed Integer Instructions
//===---------------------------------------------------------------------===//

let ExeDomain = SSEPackedInt in { // SSE integer instructions

let neverHasSideEffects = 1, SchedRW = [WriteMove] in {
def VMOVDQArr  : VPDI<0x6F, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                    "movdqa\t{$src, $dst|$dst, $src}", [], IIC_SSE_MOVA_P_RR>,
                    VEX;
def VMOVDQAYrr : VPDI<0x6F, MRMSrcReg, (outs VR256:$dst), (ins VR256:$src),
                    "movdqa\t{$src, $dst|$dst, $src}", [], IIC_SSE_MOVA_P_RR>,
                    VEX, VEX_L;
def VMOVDQUrr  : VSSI<0x6F, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                    "movdqu\t{$src, $dst|$dst, $src}", [], IIC_SSE_MOVU_P_RR>,
                    VEX;
def VMOVDQUYrr : VSSI<0x6F, MRMSrcReg, (outs VR256:$dst), (ins VR256:$src),
                    "movdqu\t{$src, $dst|$dst, $src}", [], IIC_SSE_MOVU_P_RR>,
                    VEX, VEX_L;
}

// For Disassembler
let isCodeGenOnly = 1, hasSideEffects = 0, SchedRW = [WriteMove] in {
def VMOVDQArr_REV  : VPDI<0x7F, MRMDestReg, (outs VR128:$dst), (ins VR128:$src),
                        "movdqa\t{$src, $dst|$dst, $src}", [],
                        IIC_SSE_MOVA_P_RR>,
                        VEX;
def VMOVDQAYrr_REV : VPDI<0x7F, MRMDestReg, (outs VR256:$dst), (ins VR256:$src),
                        "movdqa\t{$src, $dst|$dst, $src}", [],
                        IIC_SSE_MOVA_P_RR>, VEX, VEX_L;
def VMOVDQUrr_REV  : VSSI<0x7F, MRMDestReg, (outs VR128:$dst), (ins VR128:$src),
                        "movdqu\t{$src, $dst|$dst, $src}", [],
                        IIC_SSE_MOVU_P_RR>,
                        VEX;
def VMOVDQUYrr_REV : VSSI<0x7F, MRMDestReg, (outs VR256:$dst), (ins VR256:$src),
                        "movdqu\t{$src, $dst|$dst, $src}", [],
                        IIC_SSE_MOVU_P_RR>, VEX, VEX_L;
}

let canFoldAsLoad = 1, mayLoad = 1, isReMaterializable = 1,
    neverHasSideEffects = 1, SchedRW = [WriteLoad] in {
def VMOVDQArm  : VPDI<0x6F, MRMSrcMem, (outs VR128:$dst), (ins i128mem:$src),
                   "movdqa\t{$src, $dst|$dst, $src}", [], IIC_SSE_MOVA_P_RM>,
                   VEX;
def VMOVDQAYrm : VPDI<0x6F, MRMSrcMem, (outs VR256:$dst), (ins i256mem:$src),
                   "movdqa\t{$src, $dst|$dst, $src}", [], IIC_SSE_MOVA_P_RM>,
                   VEX, VEX_L;
let Predicates = [HasAVX] in {
  def VMOVDQUrm  : I<0x6F, MRMSrcMem, (outs VR128:$dst), (ins i128mem:$src),
                    "vmovdqu\t{$src, $dst|$dst, $src}",[], IIC_SSE_MOVU_P_RM>,
                    XS, VEX;
  def VMOVDQUYrm : I<0x6F, MRMSrcMem, (outs VR256:$dst), (ins i256mem:$src),
                    "vmovdqu\t{$src, $dst|$dst, $src}",[], IIC_SSE_MOVU_P_RM>,
                    XS, VEX, VEX_L;
}
}

let mayStore = 1, neverHasSideEffects = 1, SchedRW = [WriteStore] in {
def VMOVDQAmr  : VPDI<0x7F, MRMDestMem, (outs),
                     (ins i128mem:$dst, VR128:$src),
                     "movdqa\t{$src, $dst|$dst, $src}", [], IIC_SSE_MOVA_P_MR>,
                     VEX;
def VMOVDQAYmr : VPDI<0x7F, MRMDestMem, (outs),
                     (ins i256mem:$dst, VR256:$src),
                     "movdqa\t{$src, $dst|$dst, $src}", [], IIC_SSE_MOVA_P_MR>,
                     VEX, VEX_L;
let Predicates = [HasAVX] in {
def VMOVDQUmr  : I<0x7F, MRMDestMem, (outs), (ins i128mem:$dst, VR128:$src),
                  "vmovdqu\t{$src, $dst|$dst, $src}",[], IIC_SSE_MOVU_P_MR>,
                  XS, VEX;
def VMOVDQUYmr : I<0x7F, MRMDestMem, (outs), (ins i256mem:$dst, VR256:$src),
                  "vmovdqu\t{$src, $dst|$dst, $src}",[], IIC_SSE_MOVU_P_MR>,
                  XS, VEX, VEX_L;
}
}

let SchedRW = [WriteMove] in {
let neverHasSideEffects = 1 in
def MOVDQArr : PDI<0x6F, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                   "movdqa\t{$src, $dst|$dst, $src}", [], IIC_SSE_MOVA_P_RR>;

def MOVDQUrr :   I<0x6F, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                   "movdqu\t{$src, $dst|$dst, $src}",
                   [], IIC_SSE_MOVU_P_RR>, XS, Requires<[UseSSE2]>;

// For Disassembler
let isCodeGenOnly = 1, hasSideEffects = 0 in {
def MOVDQArr_REV : PDI<0x7F, MRMDestReg, (outs VR128:$dst), (ins VR128:$src),
                       "movdqa\t{$src, $dst|$dst, $src}", [],
                       IIC_SSE_MOVA_P_RR>;

def MOVDQUrr_REV :   I<0x7F, MRMDestReg, (outs VR128:$dst), (ins VR128:$src),
                       "movdqu\t{$src, $dst|$dst, $src}",
                       [], IIC_SSE_MOVU_P_RR>, XS, Requires<[UseSSE2]>;
}
} // SchedRW

let canFoldAsLoad = 1, mayLoad = 1, isReMaterializable = 1,
    neverHasSideEffects = 1, SchedRW = [WriteLoad] in {
def MOVDQArm : PDI<0x6F, MRMSrcMem, (outs VR128:$dst), (ins i128mem:$src),
                   "movdqa\t{$src, $dst|$dst, $src}",
                   [/*(set VR128:$dst, (alignedloadv2i64 addr:$src))*/],
                   IIC_SSE_MOVA_P_RM>;
def MOVDQUrm :   I<0x6F, MRMSrcMem, (outs VR128:$dst), (ins i128mem:$src),
                   "movdqu\t{$src, $dst|$dst, $src}",
                   [/*(set VR128:$dst, (loadv2i64 addr:$src))*/],
                   IIC_SSE_MOVU_P_RM>,
                 XS, Requires<[UseSSE2]>;
}

let mayStore = 1, SchedRW = [WriteStore] in {
def MOVDQAmr : PDI<0x7F, MRMDestMem, (outs), (ins i128mem:$dst, VR128:$src),
                   "movdqa\t{$src, $dst|$dst, $src}",
                   [/*(alignedstore (v2i64 VR128:$src), addr:$dst)*/],
                   IIC_SSE_MOVA_P_MR>;
def MOVDQUmr :   I<0x7F, MRMDestMem, (outs), (ins i128mem:$dst, VR128:$src),
                   "movdqu\t{$src, $dst|$dst, $src}",
                   [/*(store (v2i64 VR128:$src), addr:$dst)*/],
                   IIC_SSE_MOVU_P_MR>,
                 XS, Requires<[UseSSE2]>;
}

} // ExeDomain = SSEPackedInt

let Predicates = [HasAVX] in {
  def : Pat<(int_x86_sse2_storeu_dq addr:$dst, VR128:$src),
            (VMOVDQUmr addr:$dst, VR128:$src)>;
  def : Pat<(int_x86_avx_storeu_dq_256 addr:$dst, VR256:$src),
            (VMOVDQUYmr addr:$dst, VR256:$src)>;
}
let Predicates = [UseSSE2] in
def : Pat<(int_x86_sse2_storeu_dq addr:$dst, VR128:$src),
          (MOVDQUmr addr:$dst, VR128:$src)>;

//===---------------------------------------------------------------------===//
// SSE2 - Packed Integer Arithmetic Instructions
//===---------------------------------------------------------------------===//

let Sched = WriteVecIMul in
def SSE_PMADD : OpndItins<
  IIC_SSE_PMADD, IIC_SSE_PMADD
>;

let ExeDomain = SSEPackedInt in { // SSE integer instructions

multiclass PDI_binop_rm_int<bits<8> opc, string OpcodeStr, Intrinsic IntId,
                            RegisterClass RC, PatFrag memop_frag,
                            X86MemOperand x86memop,
                            OpndItins itins,
                            bit IsCommutable = 0,
                            bit Is2Addr = 1> {
  let isCommutable = IsCommutable in
  def rr : PDI<opc, MRMSrcReg, (outs RC:$dst),
       (ins RC:$src1, RC:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (IntId RC:$src1, RC:$src2))], itins.rr>,
      Sched<[itins.Sched]>;
  def rm : PDI<opc, MRMSrcMem, (outs RC:$dst),
       (ins RC:$src1, x86memop:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (IntId RC:$src1, (bitconvert (memop_frag addr:$src2))))],
       itins.rm>, Sched<[itins.Sched.Folded, ReadAfterLd]>;
}

multiclass PDI_binop_all_int<bits<8> opc, string OpcodeStr, Intrinsic IntId128,
                             Intrinsic IntId256, OpndItins itins,
                             bit IsCommutable = 0> {
let Predicates = [HasAVX] in
  defm V#NAME : PDI_binop_rm_int<opc, !strconcat("v", OpcodeStr), IntId128,
                                 VR128, memopv2i64, i128mem, itins,
                                 IsCommutable, 0>, VEX_4V;

let Constraints = "$src1 = $dst" in
  defm NAME : PDI_binop_rm_int<opc, OpcodeStr, IntId128, VR128, memopv2i64,
                               i128mem, itins, IsCommutable, 1>;

let Predicates = [HasAVX2] in
  defm V#NAME#Y : PDI_binop_rm_int<opc, !strconcat("v", OpcodeStr), IntId256,
                                   VR256, memopv4i64, i256mem, itins,
                                   IsCommutable, 0>, VEX_4V, VEX_L;
}

multiclass PDI_binop_rmi<bits<8> opc, bits<8> opc2, Format ImmForm,
                         string OpcodeStr, SDNode OpNode,
                         SDNode OpNode2, RegisterClass RC,
                         ValueType DstVT, ValueType SrcVT, PatFrag bc_frag,
                         ShiftOpndItins itins,
                         bit Is2Addr = 1> {
  // src2 is always 128-bit
  def rr : PDI<opc, MRMSrcReg, (outs RC:$dst),
       (ins RC:$src1, VR128:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (DstVT (OpNode RC:$src1, (SrcVT VR128:$src2))))],
        itins.rr>, Sched<[WriteVecShift]>;
  def rm : PDI<opc, MRMSrcMem, (outs RC:$dst),
       (ins RC:$src1, i128mem:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (DstVT (OpNode RC:$src1,
                       (bc_frag (memopv2i64 addr:$src2)))))], itins.rm>,
      Sched<[WriteVecShiftLd, ReadAfterLd]>;
  def ri : PDIi8<opc2, ImmForm, (outs RC:$dst),
       (ins RC:$src1, i32i8imm:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (DstVT (OpNode2 RC:$src1, (i32 imm:$src2))))], itins.ri>,
       Sched<[WriteVecShift]>;
}

/// PDI_binop_rm2 - Simple SSE2 binary operator with different src and dst types
multiclass PDI_binop_rm2<bits<8> opc, string OpcodeStr, SDNode OpNode,
                         ValueType DstVT, ValueType SrcVT, RegisterClass RC,
                         PatFrag memop_frag, X86MemOperand x86memop,
                         OpndItins itins,
                         bit IsCommutable = 0, bit Is2Addr = 1> {
  let isCommutable = IsCommutable in
  def rr : PDI<opc, MRMSrcReg, (outs RC:$dst),
       (ins RC:$src1, RC:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (DstVT (OpNode (SrcVT RC:$src1), RC:$src2)))]>,
       Sched<[itins.Sched]>;
  def rm : PDI<opc, MRMSrcMem, (outs RC:$dst),
       (ins RC:$src1, x86memop:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (DstVT (OpNode (SrcVT RC:$src1),
                                     (bitconvert (memop_frag addr:$src2)))))]>,
       Sched<[itins.Sched.Folded, ReadAfterLd]>;
}
} // ExeDomain = SSEPackedInt

defm PADDB   : PDI_binop_all<0xFC, "paddb", add, v16i8, v32i8,
                             SSE_INTALU_ITINS_P, 1>;
defm PADDW   : PDI_binop_all<0xFD, "paddw", add, v8i16, v16i16,
                             SSE_INTALU_ITINS_P, 1>;
defm PADDD   : PDI_binop_all<0xFE, "paddd", add, v4i32, v8i32,
                             SSE_INTALU_ITINS_P, 1>;
defm PADDQ   : PDI_binop_all<0xD4, "paddq", add, v2i64, v4i64,
                             SSE_INTALUQ_ITINS_P, 1>;
defm PMULLW  : PDI_binop_all<0xD5, "pmullw", mul, v8i16, v16i16,
                             SSE_INTMUL_ITINS_P, 1>;
defm PSUBB   : PDI_binop_all<0xF8, "psubb", sub, v16i8, v32i8,
                             SSE_INTALU_ITINS_P, 0>;
defm PSUBW   : PDI_binop_all<0xF9, "psubw", sub, v8i16, v16i16,
                             SSE_INTALU_ITINS_P, 0>;
defm PSUBD   : PDI_binop_all<0xFA, "psubd", sub, v4i32, v8i32,
                             SSE_INTALU_ITINS_P, 0>;
defm PSUBQ   : PDI_binop_all<0xFB, "psubq", sub, v2i64, v4i64,
                             SSE_INTALUQ_ITINS_P, 0>;
defm PSUBUSB : PDI_binop_all<0xD8, "psubusb", X86subus, v16i8, v32i8,
                             SSE_INTALU_ITINS_P, 0>;
defm PSUBUSW : PDI_binop_all<0xD9, "psubusw", X86subus, v8i16, v16i16,
                             SSE_INTALU_ITINS_P, 0>;
defm PMINUB  : PDI_binop_all<0xDA, "pminub", X86umin, v16i8, v32i8,
                             SSE_INTALU_ITINS_P, 1>;
defm PMINSW  : PDI_binop_all<0xEA, "pminsw", X86smin, v8i16, v16i16,
                             SSE_INTALU_ITINS_P, 1>;
defm PMAXUB  : PDI_binop_all<0xDE, "pmaxub", X86umax, v16i8, v32i8,
                             SSE_INTALU_ITINS_P, 1>;
defm PMAXSW  : PDI_binop_all<0xEE, "pmaxsw", X86smax, v8i16, v16i16,
                             SSE_INTALU_ITINS_P, 1>;

// Intrinsic forms
defm PSUBSB  : PDI_binop_all_int<0xE8, "psubsb", int_x86_sse2_psubs_b,
                                 int_x86_avx2_psubs_b, SSE_INTALU_ITINS_P, 0>;
defm PSUBSW  : PDI_binop_all_int<0xE9, "psubsw" , int_x86_sse2_psubs_w,
                                 int_x86_avx2_psubs_w, SSE_INTALU_ITINS_P, 0>;
defm PADDSB  : PDI_binop_all_int<0xEC, "paddsb" , int_x86_sse2_padds_b,
                                 int_x86_avx2_padds_b, SSE_INTALU_ITINS_P, 1>;
defm PADDSW  : PDI_binop_all_int<0xED, "paddsw" , int_x86_sse2_padds_w,
                                 int_x86_avx2_padds_w, SSE_INTALU_ITINS_P, 1>;
defm PADDUSB : PDI_binop_all_int<0xDC, "paddusb", int_x86_sse2_paddus_b,
                                 int_x86_avx2_paddus_b, SSE_INTALU_ITINS_P, 1>;
defm PADDUSW : PDI_binop_all_int<0xDD, "paddusw", int_x86_sse2_paddus_w,
                                 int_x86_avx2_paddus_w, SSE_INTALU_ITINS_P, 1>;
defm PMULHUW : PDI_binop_all_int<0xE4, "pmulhuw", int_x86_sse2_pmulhu_w,
                                 int_x86_avx2_pmulhu_w, SSE_INTMUL_ITINS_P, 1>;
defm PMULHW  : PDI_binop_all_int<0xE5, "pmulhw" , int_x86_sse2_pmulh_w,
                                 int_x86_avx2_pmulh_w, SSE_INTMUL_ITINS_P, 1>;
defm PMADDWD : PDI_binop_all_int<0xF5, "pmaddwd", int_x86_sse2_pmadd_wd,
                                 int_x86_avx2_pmadd_wd, SSE_PMADD, 1>;
defm PAVGB   : PDI_binop_all_int<0xE0, "pavgb", int_x86_sse2_pavg_b,
                                 int_x86_avx2_pavg_b, SSE_INTALU_ITINS_P, 1>;
defm PAVGW   : PDI_binop_all_int<0xE3, "pavgw", int_x86_sse2_pavg_w,
                                 int_x86_avx2_pavg_w, SSE_INTALU_ITINS_P, 1>;
defm PSADBW  : PDI_binop_all_int<0xF6, "psadbw", int_x86_sse2_psad_bw,
                                 int_x86_avx2_psad_bw, SSE_INTALU_ITINS_P, 1>;

let Predicates = [HasAVX] in
defm VPMULUDQ : PDI_binop_rm2<0xF4, "vpmuludq", X86pmuludq, v2i64, v4i32, VR128,
                              memopv2i64, i128mem, SSE_INTMUL_ITINS_P, 1, 0>,
                              VEX_4V;
let Predicates = [HasAVX2] in
defm VPMULUDQY : PDI_binop_rm2<0xF4, "vpmuludq", X86pmuludq, v4i64, v8i32,
                               VR256, memopv4i64, i256mem,
                               SSE_INTMUL_ITINS_P, 1, 0>, VEX_4V, VEX_L;
let Constraints = "$src1 = $dst" in
defm PMULUDQ : PDI_binop_rm2<0xF4, "pmuludq", X86pmuludq, v2i64, v4i32, VR128,
                             memopv2i64, i128mem, SSE_INTMUL_ITINS_P, 1>;

//===---------------------------------------------------------------------===//
// SSE2 - Packed Integer Logical Instructions
//===---------------------------------------------------------------------===//

let Predicates = [HasAVX] in {
defm VPSLLW : PDI_binop_rmi<0xF1, 0x71, MRM6r, "vpsllw", X86vshl, X86vshli,
                            VR128, v8i16, v8i16, bc_v8i16,
                            SSE_INTSHIFT_ITINS_P, 0>, VEX_4V;
defm VPSLLD : PDI_binop_rmi<0xF2, 0x72, MRM6r, "vpslld", X86vshl, X86vshli,
                            VR128, v4i32, v4i32, bc_v4i32,
                            SSE_INTSHIFT_ITINS_P, 0>, VEX_4V;
defm VPSLLQ : PDI_binop_rmi<0xF3, 0x73, MRM6r, "vpsllq", X86vshl, X86vshli,
                            VR128, v2i64, v2i64, bc_v2i64,
                            SSE_INTSHIFT_ITINS_P, 0>, VEX_4V;

defm VPSRLW : PDI_binop_rmi<0xD1, 0x71, MRM2r, "vpsrlw", X86vsrl, X86vsrli,
                            VR128, v8i16, v8i16, bc_v8i16,
                            SSE_INTSHIFT_ITINS_P, 0>, VEX_4V;
defm VPSRLD : PDI_binop_rmi<0xD2, 0x72, MRM2r, "vpsrld", X86vsrl, X86vsrli,
                            VR128, v4i32, v4i32, bc_v4i32,
                            SSE_INTSHIFT_ITINS_P, 0>, VEX_4V;
defm VPSRLQ : PDI_binop_rmi<0xD3, 0x73, MRM2r, "vpsrlq", X86vsrl, X86vsrli,
                            VR128, v2i64, v2i64, bc_v2i64,
                            SSE_INTSHIFT_ITINS_P, 0>, VEX_4V;

defm VPSRAW : PDI_binop_rmi<0xE1, 0x71, MRM4r, "vpsraw", X86vsra, X86vsrai,
                            VR128, v8i16, v8i16, bc_v8i16,
                            SSE_INTSHIFT_ITINS_P, 0>, VEX_4V;
defm VPSRAD : PDI_binop_rmi<0xE2, 0x72, MRM4r, "vpsrad", X86vsra, X86vsrai,
                            VR128, v4i32, v4i32, bc_v4i32,
                            SSE_INTSHIFT_ITINS_P, 0>, VEX_4V;

let ExeDomain = SSEPackedInt, SchedRW = [WriteVecShift] in {
  // 128-bit logical shifts.
  def VPSLLDQri : PDIi8<0x73, MRM7r,
                    (outs VR128:$dst), (ins VR128:$src1, i32i8imm:$src2),
                    "vpslldq\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                    [(set VR128:$dst,
                      (int_x86_sse2_psll_dq_bs VR128:$src1, imm:$src2))]>,
                    VEX_4V;
  def VPSRLDQri : PDIi8<0x73, MRM3r,
                    (outs VR128:$dst), (ins VR128:$src1, i32i8imm:$src2),
                    "vpsrldq\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                    [(set VR128:$dst,
                      (int_x86_sse2_psrl_dq_bs VR128:$src1, imm:$src2))]>,
                    VEX_4V;
  // PSRADQri doesn't exist in SSE[1-3].
}
} // Predicates = [HasAVX]

let Predicates = [HasAVX2] in {
defm VPSLLWY : PDI_binop_rmi<0xF1, 0x71, MRM6r, "vpsllw", X86vshl, X86vshli,
                             VR256, v16i16, v8i16, bc_v8i16,
                             SSE_INTSHIFT_ITINS_P, 0>, VEX_4V, VEX_L;
defm VPSLLDY : PDI_binop_rmi<0xF2, 0x72, MRM6r, "vpslld", X86vshl, X86vshli,
                             VR256, v8i32, v4i32, bc_v4i32,
                             SSE_INTSHIFT_ITINS_P, 0>, VEX_4V, VEX_L;
defm VPSLLQY : PDI_binop_rmi<0xF3, 0x73, MRM6r, "vpsllq", X86vshl, X86vshli,
                             VR256, v4i64, v2i64, bc_v2i64,
                             SSE_INTSHIFT_ITINS_P, 0>, VEX_4V, VEX_L;

defm VPSRLWY : PDI_binop_rmi<0xD1, 0x71, MRM2r, "vpsrlw", X86vsrl, X86vsrli,
                             VR256, v16i16, v8i16, bc_v8i16,
                             SSE_INTSHIFT_ITINS_P, 0>, VEX_4V, VEX_L;
defm VPSRLDY : PDI_binop_rmi<0xD2, 0x72, MRM2r, "vpsrld", X86vsrl, X86vsrli,
                             VR256, v8i32, v4i32, bc_v4i32,
                             SSE_INTSHIFT_ITINS_P, 0>, VEX_4V, VEX_L;
defm VPSRLQY : PDI_binop_rmi<0xD3, 0x73, MRM2r, "vpsrlq", X86vsrl, X86vsrli,
                             VR256, v4i64, v2i64, bc_v2i64,
                             SSE_INTSHIFT_ITINS_P, 0>, VEX_4V, VEX_L;

defm VPSRAWY : PDI_binop_rmi<0xE1, 0x71, MRM4r, "vpsraw", X86vsra, X86vsrai,
                             VR256, v16i16, v8i16, bc_v8i16,
                             SSE_INTSHIFT_ITINS_P, 0>, VEX_4V, VEX_L;
defm VPSRADY : PDI_binop_rmi<0xE2, 0x72, MRM4r, "vpsrad", X86vsra, X86vsrai,
                             VR256, v8i32, v4i32, bc_v4i32,
                             SSE_INTSHIFT_ITINS_P, 0>, VEX_4V, VEX_L;

let ExeDomain = SSEPackedInt, SchedRW = [WriteVecShift] in {
  // 256-bit logical shifts.
  def VPSLLDQYri : PDIi8<0x73, MRM7r,
                    (outs VR256:$dst), (ins VR256:$src1, i32i8imm:$src2),
                    "vpslldq\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                    [(set VR256:$dst,
                      (int_x86_avx2_psll_dq_bs VR256:$src1, imm:$src2))]>,
                    VEX_4V, VEX_L;
  def VPSRLDQYri : PDIi8<0x73, MRM3r,
                    (outs VR256:$dst), (ins VR256:$src1, i32i8imm:$src2),
                    "vpsrldq\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                    [(set VR256:$dst,
                      (int_x86_avx2_psrl_dq_bs VR256:$src1, imm:$src2))]>,
                    VEX_4V, VEX_L;
  // PSRADQYri doesn't exist in SSE[1-3].
}
} // Predicates = [HasAVX2]

let Constraints = "$src1 = $dst" in {
defm PSLLW : PDI_binop_rmi<0xF1, 0x71, MRM6r, "psllw", X86vshl, X86vshli,
                           VR128, v8i16, v8i16, bc_v8i16,
                           SSE_INTSHIFT_ITINS_P>;
defm PSLLD : PDI_binop_rmi<0xF2, 0x72, MRM6r, "pslld", X86vshl, X86vshli,
                           VR128, v4i32, v4i32, bc_v4i32,
                           SSE_INTSHIFT_ITINS_P>;
defm PSLLQ : PDI_binop_rmi<0xF3, 0x73, MRM6r, "psllq", X86vshl, X86vshli,
                           VR128, v2i64, v2i64, bc_v2i64,
                           SSE_INTSHIFT_ITINS_P>;

defm PSRLW : PDI_binop_rmi<0xD1, 0x71, MRM2r, "psrlw", X86vsrl, X86vsrli,
                           VR128, v8i16, v8i16, bc_v8i16,
                           SSE_INTSHIFT_ITINS_P>;
defm PSRLD : PDI_binop_rmi<0xD2, 0x72, MRM2r, "psrld", X86vsrl, X86vsrli,
                           VR128, v4i32, v4i32, bc_v4i32,
                           SSE_INTSHIFT_ITINS_P>;
defm PSRLQ : PDI_binop_rmi<0xD3, 0x73, MRM2r, "psrlq", X86vsrl, X86vsrli,
                           VR128, v2i64, v2i64, bc_v2i64,
                           SSE_INTSHIFT_ITINS_P>;

defm PSRAW : PDI_binop_rmi<0xE1, 0x71, MRM4r, "psraw", X86vsra, X86vsrai,
                           VR128, v8i16, v8i16, bc_v8i16,
                           SSE_INTSHIFT_ITINS_P>;
defm PSRAD : PDI_binop_rmi<0xE2, 0x72, MRM4r, "psrad", X86vsra, X86vsrai,
                           VR128, v4i32, v4i32, bc_v4i32,
                           SSE_INTSHIFT_ITINS_P>;

let ExeDomain = SSEPackedInt, SchedRW = [WriteVecShift] in {
  // 128-bit logical shifts.
  def PSLLDQri : PDIi8<0x73, MRM7r,
                       (outs VR128:$dst), (ins VR128:$src1, i32i8imm:$src2),
                       "pslldq\t{$src2, $dst|$dst, $src2}",
                       [(set VR128:$dst,
                         (int_x86_sse2_psll_dq_bs VR128:$src1, imm:$src2))]>;
  def PSRLDQri : PDIi8<0x73, MRM3r,
                       (outs VR128:$dst), (ins VR128:$src1, i32i8imm:$src2),
                       "psrldq\t{$src2, $dst|$dst, $src2}",
                       [(set VR128:$dst,
                         (int_x86_sse2_psrl_dq_bs VR128:$src1, imm:$src2))]>;
  // PSRADQri doesn't exist in SSE[1-3].
}
} // Constraints = "$src1 = $dst"

let Predicates = [HasAVX] in {
  def : Pat<(int_x86_sse2_psll_dq VR128:$src1, imm:$src2),
            (VPSLLDQri VR128:$src1, (BYTE_imm imm:$src2))>;
  def : Pat<(int_x86_sse2_psrl_dq VR128:$src1, imm:$src2),
            (VPSRLDQri VR128:$src1, (BYTE_imm imm:$src2))>;
  def : Pat<(v2f64 (X86fsrl VR128:$src1, i32immSExt8:$src2)),
            (VPSRLDQri VR128:$src1, (BYTE_imm imm:$src2))>;

  // Shift up / down and insert zero's.
  def : Pat<(v2i64 (X86vshldq VR128:$src, (i8 imm:$amt))),
            (VPSLLDQri VR128:$src, (BYTE_imm imm:$amt))>;
  def : Pat<(v2i64 (X86vshrdq VR128:$src, (i8 imm:$amt))),
            (VPSRLDQri VR128:$src, (BYTE_imm imm:$amt))>;
}

let Predicates = [HasAVX2] in {
  def : Pat<(int_x86_avx2_psll_dq VR256:$src1, imm:$src2),
            (VPSLLDQYri VR256:$src1, (BYTE_imm imm:$src2))>;
  def : Pat<(int_x86_avx2_psrl_dq VR256:$src1, imm:$src2),
            (VPSRLDQYri VR256:$src1, (BYTE_imm imm:$src2))>;
}

let Predicates = [UseSSE2] in {
  def : Pat<(int_x86_sse2_psll_dq VR128:$src1, imm:$src2),
            (PSLLDQri VR128:$src1, (BYTE_imm imm:$src2))>;
  def : Pat<(int_x86_sse2_psrl_dq VR128:$src1, imm:$src2),
            (PSRLDQri VR128:$src1, (BYTE_imm imm:$src2))>;
  def : Pat<(v2f64 (X86fsrl VR128:$src1, i32immSExt8:$src2)),
            (PSRLDQri VR128:$src1, (BYTE_imm imm:$src2))>;

  // Shift up / down and insert zero's.
  def : Pat<(v2i64 (X86vshldq VR128:$src, (i8 imm:$amt))),
            (PSLLDQri VR128:$src, (BYTE_imm imm:$amt))>;
  def : Pat<(v2i64 (X86vshrdq VR128:$src, (i8 imm:$amt))),
            (PSRLDQri VR128:$src, (BYTE_imm imm:$amt))>;
}

//===---------------------------------------------------------------------===//
// SSE2 - Packed Integer Comparison Instructions
//===---------------------------------------------------------------------===//

defm PCMPEQB : PDI_binop_all<0x74, "pcmpeqb", X86pcmpeq, v16i8, v32i8,
                             SSE_INTALU_ITINS_P, 1>;
defm PCMPEQW : PDI_binop_all<0x75, "pcmpeqw", X86pcmpeq, v8i16, v16i16,
                             SSE_INTALU_ITINS_P, 1>;
defm PCMPEQD : PDI_binop_all<0x76, "pcmpeqd", X86pcmpeq, v4i32, v8i32,
                             SSE_INTALU_ITINS_P, 1>;
defm PCMPGTB : PDI_binop_all<0x64, "pcmpgtb", X86pcmpgt, v16i8, v32i8,
                             SSE_INTALU_ITINS_P, 0>;
defm PCMPGTW : PDI_binop_all<0x65, "pcmpgtw", X86pcmpgt, v8i16, v16i16,
                             SSE_INTALU_ITINS_P, 0>;
defm PCMPGTD : PDI_binop_all<0x66, "pcmpgtd", X86pcmpgt, v4i32, v8i32,
                             SSE_INTALU_ITINS_P, 0>;

//===---------------------------------------------------------------------===//
// SSE2 - Packed Integer Pack Instructions
//===---------------------------------------------------------------------===//

defm PACKSSWB : PDI_binop_all_int<0x63, "packsswb", int_x86_sse2_packsswb_128,
                                  int_x86_avx2_packsswb, SSE_INTALU_ITINS_P, 0>;
defm PACKSSDW : PDI_binop_all_int<0x6B, "packssdw", int_x86_sse2_packssdw_128,
                                  int_x86_avx2_packssdw, SSE_INTALU_ITINS_P, 0>;
defm PACKUSWB : PDI_binop_all_int<0x67, "packuswb", int_x86_sse2_packuswb_128,
                                  int_x86_avx2_packuswb, SSE_INTALU_ITINS_P, 0>;

//===---------------------------------------------------------------------===//
// SSE2 - Packed Integer Shuffle Instructions
//===---------------------------------------------------------------------===//

let ExeDomain = SSEPackedInt in {
multiclass sse2_pshuffle<string OpcodeStr, ValueType vt128, ValueType vt256,
                         SDNode OpNode> {
let Predicates = [HasAVX] in {
  def V#NAME#ri : Ii8<0x70, MRMSrcReg, (outs VR128:$dst),
                      (ins VR128:$src1, i8imm:$src2),
                      !strconcat("v", OpcodeStr,
                                 "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                      [(set VR128:$dst,
                        (vt128 (OpNode VR128:$src1, (i8 imm:$src2))))],
                      IIC_SSE_PSHUF>, VEX, Sched<[WriteShuffle]>;
  def V#NAME#mi : Ii8<0x70, MRMSrcMem, (outs VR128:$dst),
                      (ins i128mem:$src1, i8imm:$src2),
                      !strconcat("v", OpcodeStr,
                                 "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                     [(set VR128:$dst,
                       (vt128 (OpNode (bitconvert (memopv2i64 addr:$src1)),
                        (i8 imm:$src2))))], IIC_SSE_PSHUF>, VEX,
                  Sched<[WriteShuffleLd]>;
}

let Predicates = [HasAVX2] in {
  def V#NAME#Yri : Ii8<0x70, MRMSrcReg, (outs VR256:$dst),
                       (ins VR256:$src1, i8imm:$src2),
                       !strconcat("v", OpcodeStr,
                                  "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                       [(set VR256:$dst,
                         (vt256 (OpNode VR256:$src1, (i8 imm:$src2))))],
                       IIC_SSE_PSHUF>, VEX, VEX_L, Sched<[WriteShuffle]>;
  def V#NAME#Ymi : Ii8<0x70, MRMSrcMem, (outs VR256:$dst),
                       (ins i256mem:$src1, i8imm:$src2),
                       !strconcat("v", OpcodeStr,
                                  "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                      [(set VR256:$dst,
                        (vt256 (OpNode (bitconvert (memopv4i64 addr:$src1)),
                         (i8 imm:$src2))))], IIC_SSE_PSHUF>, VEX, VEX_L,
                   Sched<[WriteShuffleLd]>;
}

let Predicates = [UseSSE2] in {
  def ri : Ii8<0x70, MRMSrcReg,
               (outs VR128:$dst), (ins VR128:$src1, i8imm:$src2),
               !strconcat(OpcodeStr,
                          "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                [(set VR128:$dst,
                  (vt128 (OpNode VR128:$src1, (i8 imm:$src2))))],
                IIC_SSE_PSHUF>, Sched<[WriteShuffle]>;
  def mi : Ii8<0x70, MRMSrcMem,
               (outs VR128:$dst), (ins i128mem:$src1, i8imm:$src2),
               !strconcat(OpcodeStr,
                          "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                [(set VR128:$dst,
                  (vt128 (OpNode (bitconvert (memopv2i64 addr:$src1)),
                          (i8 imm:$src2))))], IIC_SSE_PSHUF>,
           Sched<[WriteShuffleLd]>;
}
}
} // ExeDomain = SSEPackedInt

defm PSHUFD  : sse2_pshuffle<"pshufd", v4i32, v8i32, X86PShufd>, TB, OpSize;
defm PSHUFHW : sse2_pshuffle<"pshufhw", v8i16, v16i16, X86PShufhw>, XS;
defm PSHUFLW : sse2_pshuffle<"pshuflw", v8i16, v16i16, X86PShuflw>, XD;

let Predicates = [HasAVX] in {
  def : Pat<(v4f32 (X86PShufd (memopv4f32 addr:$src1), (i8 imm:$imm))),
            (VPSHUFDmi addr:$src1, imm:$imm)>;
  def : Pat<(v4f32 (X86PShufd VR128:$src1, (i8 imm:$imm))),
            (VPSHUFDri VR128:$src1, imm:$imm)>;
}

let Predicates = [UseSSE2] in {
  def : Pat<(v4f32 (X86PShufd (memopv4f32 addr:$src1), (i8 imm:$imm))),
            (PSHUFDmi addr:$src1, imm:$imm)>;
  def : Pat<(v4f32 (X86PShufd VR128:$src1, (i8 imm:$imm))),
            (PSHUFDri VR128:$src1, imm:$imm)>;
}

//===---------------------------------------------------------------------===//
// SSE2 - Packed Integer Unpack Instructions
//===---------------------------------------------------------------------===//

let ExeDomain = SSEPackedInt in {
multiclass sse2_unpack<bits<8> opc, string OpcodeStr, ValueType vt,
                       SDNode OpNode, PatFrag bc_frag, bit Is2Addr = 1> {
  def rr : PDI<opc, MRMSrcReg,
      (outs VR128:$dst), (ins VR128:$src1, VR128:$src2),
      !if(Is2Addr,
          !strconcat(OpcodeStr,"\t{$src2, $dst|$dst, $src2}"),
          !strconcat(OpcodeStr,"\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
      [(set VR128:$dst, (vt (OpNode VR128:$src1, VR128:$src2)))],
      IIC_SSE_UNPCK>, Sched<[WriteShuffle]>;
  def rm : PDI<opc, MRMSrcMem,
      (outs VR128:$dst), (ins VR128:$src1, i128mem:$src2),
      !if(Is2Addr,
          !strconcat(OpcodeStr,"\t{$src2, $dst|$dst, $src2}"),
          !strconcat(OpcodeStr,"\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
      [(set VR128:$dst, (OpNode VR128:$src1,
                                  (bc_frag (memopv2i64
                                               addr:$src2))))],
                                               IIC_SSE_UNPCK>,
      Sched<[WriteShuffleLd, ReadAfterLd]>;
}

multiclass sse2_unpack_y<bits<8> opc, string OpcodeStr, ValueType vt,
                         SDNode OpNode, PatFrag bc_frag> {
  def Yrr : PDI<opc, MRMSrcReg,
      (outs VR256:$dst), (ins VR256:$src1, VR256:$src2),
      !strconcat(OpcodeStr,"\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
      [(set VR256:$dst, (vt (OpNode VR256:$src1, VR256:$src2)))]>,
      Sched<[WriteShuffle]>;
  def Yrm : PDI<opc, MRMSrcMem,
      (outs VR256:$dst), (ins VR256:$src1, i256mem:$src2),
      !strconcat(OpcodeStr,"\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
      [(set VR256:$dst, (OpNode VR256:$src1,
                                  (bc_frag (memopv4i64 addr:$src2))))]>,
      Sched<[WriteShuffleLd, ReadAfterLd]>;
}

let Predicates = [HasAVX] in {
  defm VPUNPCKLBW  : sse2_unpack<0x60, "vpunpcklbw", v16i8, X86Unpckl,
                                 bc_v16i8, 0>, VEX_4V;
  defm VPUNPCKLWD  : sse2_unpack<0x61, "vpunpcklwd", v8i16, X86Unpckl,
                                 bc_v8i16, 0>, VEX_4V;
  defm VPUNPCKLDQ  : sse2_unpack<0x62, "vpunpckldq", v4i32, X86Unpckl,
                                 bc_v4i32, 0>, VEX_4V;
  defm VPUNPCKLQDQ : sse2_unpack<0x6C, "vpunpcklqdq", v2i64, X86Unpckl,
                                 bc_v2i64, 0>, VEX_4V;

  defm VPUNPCKHBW  : sse2_unpack<0x68, "vpunpckhbw", v16i8, X86Unpckh,
                                 bc_v16i8, 0>, VEX_4V;
  defm VPUNPCKHWD  : sse2_unpack<0x69, "vpunpckhwd", v8i16, X86Unpckh,
                                 bc_v8i16, 0>, VEX_4V;
  defm VPUNPCKHDQ  : sse2_unpack<0x6A, "vpunpckhdq", v4i32, X86Unpckh,
                                 bc_v4i32, 0>, VEX_4V;
  defm VPUNPCKHQDQ : sse2_unpack<0x6D, "vpunpckhqdq", v2i64, X86Unpckh,
                                 bc_v2i64, 0>, VEX_4V;
}

let Predicates = [HasAVX2] in {
  defm VPUNPCKLBW  : sse2_unpack_y<0x60, "vpunpcklbw", v32i8, X86Unpckl,
                                   bc_v32i8>, VEX_4V, VEX_L;
  defm VPUNPCKLWD  : sse2_unpack_y<0x61, "vpunpcklwd", v16i16, X86Unpckl,
                                   bc_v16i16>, VEX_4V, VEX_L;
  defm VPUNPCKLDQ  : sse2_unpack_y<0x62, "vpunpckldq", v8i32, X86Unpckl,
                                   bc_v8i32>, VEX_4V, VEX_L;
  defm VPUNPCKLQDQ : sse2_unpack_y<0x6C, "vpunpcklqdq", v4i64, X86Unpckl,
                                   bc_v4i64>, VEX_4V, VEX_L;

  defm VPUNPCKHBW  : sse2_unpack_y<0x68, "vpunpckhbw", v32i8, X86Unpckh,
                                   bc_v32i8>, VEX_4V, VEX_L;
  defm VPUNPCKHWD  : sse2_unpack_y<0x69, "vpunpckhwd", v16i16, X86Unpckh,
                                   bc_v16i16>, VEX_4V, VEX_L;
  defm VPUNPCKHDQ  : sse2_unpack_y<0x6A, "vpunpckhdq", v8i32, X86Unpckh,
                                   bc_v8i32>, VEX_4V, VEX_L;
  defm VPUNPCKHQDQ : sse2_unpack_y<0x6D, "vpunpckhqdq", v4i64, X86Unpckh,
                                   bc_v4i64>, VEX_4V, VEX_L;
}

let Constraints = "$src1 = $dst" in {
  defm PUNPCKLBW  : sse2_unpack<0x60, "punpcklbw", v16i8, X86Unpckl,
                                bc_v16i8>;
  defm PUNPCKLWD  : sse2_unpack<0x61, "punpcklwd", v8i16, X86Unpckl,
                                bc_v8i16>;
  defm PUNPCKLDQ  : sse2_unpack<0x62, "punpckldq", v4i32, X86Unpckl,
                                bc_v4i32>;
  defm PUNPCKLQDQ : sse2_unpack<0x6C, "punpcklqdq", v2i64, X86Unpckl,
                                bc_v2i64>;

  defm PUNPCKHBW  : sse2_unpack<0x68, "punpckhbw", v16i8, X86Unpckh,
                                bc_v16i8>;
  defm PUNPCKHWD  : sse2_unpack<0x69, "punpckhwd", v8i16, X86Unpckh,
                                bc_v8i16>;
  defm PUNPCKHDQ  : sse2_unpack<0x6A, "punpckhdq", v4i32, X86Unpckh,
                                bc_v4i32>;
  defm PUNPCKHQDQ : sse2_unpack<0x6D, "punpckhqdq", v2i64, X86Unpckh,
                                bc_v2i64>;
}
} // ExeDomain = SSEPackedInt

//===---------------------------------------------------------------------===//
// SSE2 - Packed Integer Extract and Insert
//===---------------------------------------------------------------------===//

let ExeDomain = SSEPackedInt in {
multiclass sse2_pinsrw<bit Is2Addr = 1> {
  def rri : Ii8<0xC4, MRMSrcReg,
       (outs VR128:$dst), (ins VR128:$src1,
        GR32:$src2, i32i8imm:$src3),
       !if(Is2Addr,
           "pinsrw\t{$src3, $src2, $dst|$dst, $src2, $src3}",
           "vpinsrw\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}"),
       [(set VR128:$dst,
         (X86pinsrw VR128:$src1, GR32:$src2, imm:$src3))], IIC_SSE_PINSRW>,
       Sched<[WriteShuffle]>;
  def rmi : Ii8<0xC4, MRMSrcMem,
                       (outs VR128:$dst), (ins VR128:$src1,
                        i16mem:$src2, i32i8imm:$src3),
       !if(Is2Addr,
           "pinsrw\t{$src3, $src2, $dst|$dst, $src2, $src3}",
           "vpinsrw\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}"),
       [(set VR128:$dst,
         (X86pinsrw VR128:$src1, (extloadi16 addr:$src2),
                    imm:$src3))], IIC_SSE_PINSRW>,
       Sched<[WriteShuffleLd, ReadAfterLd]>;
}

// Extract
let Predicates = [HasAVX] in
def VPEXTRWri : Ii8<0xC5, MRMSrcReg,
                    (outs GR32:$dst), (ins VR128:$src1, i32i8imm:$src2),
                    "vpextrw\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                    [(set GR32:$dst, (X86pextrw (v8i16 VR128:$src1),
                                                imm:$src2))]>, TB, OpSize, VEX,
                Sched<[WriteShuffle]>;
def PEXTRWri : PDIi8<0xC5, MRMSrcReg,
                    (outs GR32:$dst), (ins VR128:$src1, i32i8imm:$src2),
                    "pextrw\t{$src2, $src1, $dst|$dst, $src1, $src2}",
                    [(set GR32:$dst, (X86pextrw (v8i16 VR128:$src1),
                                                imm:$src2))], IIC_SSE_PEXTRW>,
               Sched<[WriteShuffleLd, ReadAfterLd]>;

// Insert
let Predicates = [HasAVX] in {
  defm VPINSRW : sse2_pinsrw<0>, TB, OpSize, VEX_4V;
  def  VPINSRWrr64i : Ii8<0xC4, MRMSrcReg, (outs VR128:$dst),
       (ins VR128:$src1, GR64:$src2, i32i8imm:$src3),
       "vpinsrw\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}",
       []>, TB, OpSize, VEX_4V, Sched<[WriteShuffle]>;
}

let Constraints = "$src1 = $dst" in
  defm PINSRW : sse2_pinsrw, TB, OpSize, Requires<[UseSSE2]>;

} // ExeDomain = SSEPackedInt

//===---------------------------------------------------------------------===//
// SSE2 - Packed Mask Creation
//===---------------------------------------------------------------------===//

let ExeDomain = SSEPackedInt, SchedRW = [WriteVecLogic] in {

def VPMOVMSKBrr  : VPDI<0xD7, MRMSrcReg, (outs GR32:$dst), (ins VR128:$src),
           "pmovmskb\t{$src, $dst|$dst, $src}",
           [(set GR32:$dst, (int_x86_sse2_pmovmskb_128 VR128:$src))],
           IIC_SSE_MOVMSK>, VEX;
def VPMOVMSKBr64r : VPDI<0xD7, MRMSrcReg, (outs GR64:$dst), (ins VR128:$src),
           "pmovmskb\t{$src, $dst|$dst, $src}", [], IIC_SSE_MOVMSK>, VEX;

let Predicates = [HasAVX2] in {
def VPMOVMSKBYrr  : VPDI<0xD7, MRMSrcReg, (outs GR32:$dst), (ins VR256:$src),
           "pmovmskb\t{$src, $dst|$dst, $src}",
           [(set GR32:$dst, (int_x86_avx2_pmovmskb VR256:$src))]>, VEX, VEX_L;
def VPMOVMSKBYr64r : VPDI<0xD7, MRMSrcReg, (outs GR64:$dst), (ins VR256:$src),
           "pmovmskb\t{$src, $dst|$dst, $src}", []>, VEX, VEX_L;
}

def PMOVMSKBrr : PDI<0xD7, MRMSrcReg, (outs GR32:$dst), (ins VR128:$src),
           "pmovmskb\t{$src, $dst|$dst, $src}",
           [(set GR32:$dst, (int_x86_sse2_pmovmskb_128 VR128:$src))],
           IIC_SSE_MOVMSK>;

} // ExeDomain = SSEPackedInt

//===---------------------------------------------------------------------===//
// SSE2 - Conditional Store
//===---------------------------------------------------------------------===//

let ExeDomain = SSEPackedInt, SchedRW = [WriteStore] in {

let Uses = [EDI] in
def VMASKMOVDQU : VPDI<0xF7, MRMSrcReg, (outs),
           (ins VR128:$src, VR128:$mask),
           "maskmovdqu\t{$mask, $src|$src, $mask}",
           [(int_x86_sse2_maskmov_dqu VR128:$src, VR128:$mask, EDI)],
           IIC_SSE_MASKMOV>, VEX;
let Uses = [RDI] in
def VMASKMOVDQU64 : VPDI<0xF7, MRMSrcReg, (outs),
           (ins VR128:$src, VR128:$mask),
           "maskmovdqu\t{$mask, $src|$src, $mask}",
           [(int_x86_sse2_maskmov_dqu VR128:$src, VR128:$mask, RDI)],
           IIC_SSE_MASKMOV>, VEX;

let Uses = [EDI] in
def MASKMOVDQU : PDI<0xF7, MRMSrcReg, (outs), (ins VR128:$src, VR128:$mask),
           "maskmovdqu\t{$mask, $src|$src, $mask}",
           [(int_x86_sse2_maskmov_dqu VR128:$src, VR128:$mask, EDI)],
           IIC_SSE_MASKMOV>;
let Uses = [RDI] in
def MASKMOVDQU64 : PDI<0xF7, MRMSrcReg, (outs), (ins VR128:$src, VR128:$mask),
           "maskmovdqu\t{$mask, $src|$src, $mask}",
           [(int_x86_sse2_maskmov_dqu VR128:$src, VR128:$mask, RDI)],
           IIC_SSE_MASKMOV>;

} // ExeDomain = SSEPackedInt

//===---------------------------------------------------------------------===//
// SSE2 - Move Doubleword
//===---------------------------------------------------------------------===//

//===---------------------------------------------------------------------===//
// Move Int Doubleword to Packed Double Int
//
def VMOVDI2PDIrr : VS2I<0x6E, MRMSrcReg, (outs VR128:$dst), (ins GR32:$src),
                      "movd\t{$src, $dst|$dst, $src}",
                      [(set VR128:$dst,
                        (v4i32 (scalar_to_vector GR32:$src)))], IIC_SSE_MOVDQ>,
                        VEX, Sched<[WriteMove]>;
def VMOVDI2PDIrm : VS2I<0x6E, MRMSrcMem, (outs VR128:$dst), (ins i32mem:$src),
                      "movd\t{$src, $dst|$dst, $src}",
                      [(set VR128:$dst,
                        (v4i32 (scalar_to_vector (loadi32 addr:$src))))],
                        IIC_SSE_MOVDQ>,
                      VEX, Sched<[WriteLoad]>;
def VMOV64toPQIrr : VRS2I<0x6E, MRMSrcReg, (outs VR128:$dst), (ins GR64:$src),
                        "mov{d|q}\t{$src, $dst|$dst, $src}",
                        [(set VR128:$dst,
                          (v2i64 (scalar_to_vector GR64:$src)))],
                          IIC_SSE_MOVDQ>, VEX, Sched<[WriteMove]>;
def VMOV64toSDrr : VRS2I<0x6E, MRMSrcReg, (outs FR64:$dst), (ins GR64:$src),
                       "mov{d|q}\t{$src, $dst|$dst, $src}",
                       [(set FR64:$dst, (bitconvert GR64:$src))],
                       IIC_SSE_MOVDQ>, VEX, Sched<[WriteMove]>;

def MOVDI2PDIrr : S2I<0x6E, MRMSrcReg, (outs VR128:$dst), (ins GR32:$src),
                      "movd\t{$src, $dst|$dst, $src}",
                      [(set VR128:$dst,
                        (v4i32 (scalar_to_vector GR32:$src)))], IIC_SSE_MOVDQ>,
                  Sched<[WriteMove]>;
def MOVDI2PDIrm : S2I<0x6E, MRMSrcMem, (outs VR128:$dst), (ins i32mem:$src),
                      "movd\t{$src, $dst|$dst, $src}",
                      [(set VR128:$dst,
                        (v4i32 (scalar_to_vector (loadi32 addr:$src))))],
                        IIC_SSE_MOVDQ>, Sched<[WriteLoad]>;
def MOV64toPQIrr : RS2I<0x6E, MRMSrcReg, (outs VR128:$dst), (ins GR64:$src),
                        "mov{d|q}\t{$src, $dst|$dst, $src}",
                        [(set VR128:$dst,
                          (v2i64 (scalar_to_vector GR64:$src)))],
                          IIC_SSE_MOVDQ>, Sched<[WriteMove]>;
def MOV64toSDrr : RS2I<0x6E, MRMSrcReg, (outs FR64:$dst), (ins GR64:$src),
                       "mov{d|q}\t{$src, $dst|$dst, $src}",
                       [(set FR64:$dst, (bitconvert GR64:$src))],
                       IIC_SSE_MOVDQ>, Sched<[WriteMove]>;

//===---------------------------------------------------------------------===//
// Move Int Doubleword to Single Scalar
//
def VMOVDI2SSrr  : VS2I<0x6E, MRMSrcReg, (outs FR32:$dst), (ins GR32:$src),
                      "movd\t{$src, $dst|$dst, $src}",
                      [(set FR32:$dst, (bitconvert GR32:$src))],
                      IIC_SSE_MOVDQ>, VEX, Sched<[WriteMove]>;

def VMOVDI2SSrm  : VS2I<0x6E, MRMSrcMem, (outs FR32:$dst), (ins i32mem:$src),
                      "movd\t{$src, $dst|$dst, $src}",
                      [(set FR32:$dst, (bitconvert (loadi32 addr:$src)))],
                      IIC_SSE_MOVDQ>,
                      VEX, Sched<[WriteLoad]>;
def MOVDI2SSrr  : S2I<0x6E, MRMSrcReg, (outs FR32:$dst), (ins GR32:$src),
                      "movd\t{$src, $dst|$dst, $src}",
                      [(set FR32:$dst, (bitconvert GR32:$src))],
                      IIC_SSE_MOVDQ>, Sched<[WriteMove]>;

def MOVDI2SSrm  : S2I<0x6E, MRMSrcMem, (outs FR32:$dst), (ins i32mem:$src),
                      "movd\t{$src, $dst|$dst, $src}",
                      [(set FR32:$dst, (bitconvert (loadi32 addr:$src)))],
                      IIC_SSE_MOVDQ>, Sched<[WriteLoad]>;

//===---------------------------------------------------------------------===//
// Move Packed Doubleword Int to Packed Double Int
//
def VMOVPDI2DIrr  : VS2I<0x7E, MRMDestReg, (outs GR32:$dst), (ins VR128:$src),
                       "movd\t{$src, $dst|$dst, $src}",
                       [(set GR32:$dst, (vector_extract (v4i32 VR128:$src),
                                        (iPTR 0)))], IIC_SSE_MOVD_ToGP>, VEX,
                    Sched<[WriteMove]>;
def VMOVPDI2DImr  : VS2I<0x7E, MRMDestMem, (outs),
                       (ins i32mem:$dst, VR128:$src),
                       "movd\t{$src, $dst|$dst, $src}",
                       [(store (i32 (vector_extract (v4i32 VR128:$src),
                                     (iPTR 0))), addr:$dst)], IIC_SSE_MOVDQ>,
                                     VEX, Sched<[WriteLoad]>;
def MOVPDI2DIrr  : S2I<0x7E, MRMDestReg, (outs GR32:$dst), (ins VR128:$src),
                       "movd\t{$src, $dst|$dst, $src}",
                       [(set GR32:$dst, (vector_extract (v4i32 VR128:$src),
                                        (iPTR 0)))], IIC_SSE_MOVD_ToGP>,
                   Sched<[WriteMove]>;
def MOVPDI2DImr  : S2I<0x7E, MRMDestMem, (outs), (ins i32mem:$dst, VR128:$src),
                       "movd\t{$src, $dst|$dst, $src}",
                       [(store (i32 (vector_extract (v4i32 VR128:$src),
                                     (iPTR 0))), addr:$dst)],
                                     IIC_SSE_MOVDQ>, Sched<[WriteLoad]>;

//===---------------------------------------------------------------------===//
// Move Packed Doubleword Int first element to Doubleword Int
//
let SchedRW = [WriteMove] in {
def VMOVPQIto64rr : VRS2I<0x7E, MRMDestReg, (outs GR64:$dst), (ins VR128:$src),
                          "mov{d|q}\t{$src, $dst|$dst, $src}",
                          [(set GR64:$dst, (vector_extract (v2i64 VR128:$src),
                                                           (iPTR 0)))],
                                                           IIC_SSE_MOVD_ToGP>,
                      VEX;

def MOVPQIto64rr : RS2I<0x7E, MRMDestReg, (outs GR64:$dst), (ins VR128:$src),
                        "mov{d|q}\t{$src, $dst|$dst, $src}",
                        [(set GR64:$dst, (vector_extract (v2i64 VR128:$src),
                                                         (iPTR 0)))],
                                                         IIC_SSE_MOVD_ToGP>;
} //SchedRW

//===---------------------------------------------------------------------===//
// Bitcast FR64 <-> GR64
//
let Predicates = [HasAVX] in
def VMOV64toSDrm : S2SI<0x7E, MRMSrcMem, (outs FR64:$dst), (ins i64mem:$src),
                        "vmovq\t{$src, $dst|$dst, $src}",
                        [(set FR64:$dst, (bitconvert (loadi64 addr:$src)))]>,
                        VEX, Sched<[WriteLoad]>;
def VMOVSDto64rr : VRS2I<0x7E, MRMDestReg, (outs GR64:$dst), (ins FR64:$src),
                         "mov{d|q}\t{$src, $dst|$dst, $src}",
                         [(set GR64:$dst, (bitconvert FR64:$src))],
                         IIC_SSE_MOVDQ>, VEX, Sched<[WriteMove]>;
def VMOVSDto64mr : VRS2I<0x7E, MRMDestMem, (outs), (ins i64mem:$dst, FR64:$src),
                         "movq\t{$src, $dst|$dst, $src}",
                         [(store (i64 (bitconvert FR64:$src)), addr:$dst)],
                         IIC_SSE_MOVDQ>, VEX, Sched<[WriteStore]>;

def MOV64toSDrm : S2SI<0x7E, MRMSrcMem, (outs FR64:$dst), (ins i64mem:$src),
                       "movq\t{$src, $dst|$dst, $src}",
                       [(set FR64:$dst, (bitconvert (loadi64 addr:$src)))],
                       IIC_SSE_MOVDQ>, Sched<[WriteLoad]>;
def MOVSDto64rr : RS2I<0x7E, MRMDestReg, (outs GR64:$dst), (ins FR64:$src),
                       "mov{d|q}\t{$src, $dst|$dst, $src}",
                       [(set GR64:$dst, (bitconvert FR64:$src))],
                       IIC_SSE_MOVD_ToGP>, Sched<[WriteMove]>;
def MOVSDto64mr : RS2I<0x7E, MRMDestMem, (outs), (ins i64mem:$dst, FR64:$src),
                       "movq\t{$src, $dst|$dst, $src}",
                       [(store (i64 (bitconvert FR64:$src)), addr:$dst)],
                       IIC_SSE_MOVDQ>, Sched<[WriteStore]>;

//===---------------------------------------------------------------------===//
// Move Scalar Single to Double Int
//
def VMOVSS2DIrr  : VS2I<0x7E, MRMDestReg, (outs GR32:$dst), (ins FR32:$src),
                      "movd\t{$src, $dst|$dst, $src}",
                      [(set GR32:$dst, (bitconvert FR32:$src))],
                      IIC_SSE_MOVD_ToGP>, VEX, Sched<[WriteMove]>;
def VMOVSS2DImr  : VS2I<0x7E, MRMDestMem, (outs), (ins i32mem:$dst, FR32:$src),
                      "movd\t{$src, $dst|$dst, $src}",
                      [(store (i32 (bitconvert FR32:$src)), addr:$dst)],
                      IIC_SSE_MOVDQ>, VEX, Sched<[WriteStore]>;
def MOVSS2DIrr  : S2I<0x7E, MRMDestReg, (outs GR32:$dst), (ins FR32:$src),
                      "movd\t{$src, $dst|$dst, $src}",
                      [(set GR32:$dst, (bitconvert FR32:$src))],
                      IIC_SSE_MOVD_ToGP>, Sched<[WriteMove]>;
def MOVSS2DImr  : S2I<0x7E, MRMDestMem, (outs), (ins i32mem:$dst, FR32:$src),
                      "movd\t{$src, $dst|$dst, $src}",
                      [(store (i32 (bitconvert FR32:$src)), addr:$dst)],
                      IIC_SSE_MOVDQ>, Sched<[WriteStore]>;

//===---------------------------------------------------------------------===//
// Patterns and instructions to describe movd/movq to XMM register zero-extends
//
let SchedRW = [WriteMove] in {
let AddedComplexity = 15 in {
def VMOVZDI2PDIrr : VS2I<0x6E, MRMSrcReg, (outs VR128:$dst), (ins GR32:$src),
                       "movd\t{$src, $dst|$dst, $src}",
                       [(set VR128:$dst, (v4i32 (X86vzmovl
                                      (v4i32 (scalar_to_vector GR32:$src)))))],
                                      IIC_SSE_MOVDQ>, VEX;
def VMOVZQI2PQIrr : VS2I<0x6E, MRMSrcReg, (outs VR128:$dst), (ins GR64:$src),
                       "mov{d|q}\t{$src, $dst|$dst, $src}", // X86-64 only
                       [(set VR128:$dst, (v2i64 (X86vzmovl
                                      (v2i64 (scalar_to_vector GR64:$src)))))],
                                      IIC_SSE_MOVDQ>,
                                      VEX, VEX_W;
}
let AddedComplexity = 15 in {
def MOVZDI2PDIrr : S2I<0x6E, MRMSrcReg, (outs VR128:$dst), (ins GR32:$src),
                       "movd\t{$src, $dst|$dst, $src}",
                       [(set VR128:$dst, (v4i32 (X86vzmovl
                                      (v4i32 (scalar_to_vector GR32:$src)))))],
                                      IIC_SSE_MOVDQ>;
def MOVZQI2PQIrr : RS2I<0x6E, MRMSrcReg, (outs VR128:$dst), (ins GR64:$src),
                       "mov{d|q}\t{$src, $dst|$dst, $src}", // X86-64 only
                       [(set VR128:$dst, (v2i64 (X86vzmovl
                                      (v2i64 (scalar_to_vector GR64:$src)))))],
                                      IIC_SSE_MOVDQ>;
}
} // SchedRW

let AddedComplexity = 20, SchedRW = [WriteLoad] in {
def VMOVZDI2PDIrm : VS2I<0x6E, MRMSrcMem, (outs VR128:$dst), (ins i32mem:$src),
                       "movd\t{$src, $dst|$dst, $src}",
                       [(set VR128:$dst,
                         (v4i32 (X86vzmovl (v4i32 (scalar_to_vector
                                                   (loadi32 addr:$src))))))],
                                                   IIC_SSE_MOVDQ>, VEX;
def MOVZDI2PDIrm : S2I<0x6E, MRMSrcMem, (outs VR128:$dst), (ins i32mem:$src),
                       "movd\t{$src, $dst|$dst, $src}",
                       [(set VR128:$dst,
                         (v4i32 (X86vzmovl (v4i32 (scalar_to_vector
                                                   (loadi32 addr:$src))))))],
                                                   IIC_SSE_MOVDQ>;
} // AddedComplexity, SchedRW

let Predicates = [HasAVX] in {
  // AVX 128-bit movd/movq instruction write zeros in the high 128-bit part.
  let AddedComplexity = 20 in {
    def : Pat<(v4i32 (X86vzmovl (bc_v4i32 (loadv4f32 addr:$src)))),
              (VMOVZDI2PDIrm addr:$src)>;
    def : Pat<(v4i32 (X86vzmovl (bc_v4i32 (loadv2i64 addr:$src)))),
              (VMOVZDI2PDIrm addr:$src)>;
  }
  // Use regular 128-bit instructions to match 256-bit scalar_to_vec+zext.
  def : Pat<(v8i32 (X86vzmovl (insert_subvector undef,
                               (v4i32 (scalar_to_vector GR32:$src)),(iPTR 0)))),
            (SUBREG_TO_REG (i32 0), (VMOVZDI2PDIrr GR32:$src), sub_xmm)>;
  def : Pat<(v4i64 (X86vzmovl (insert_subvector undef,
                               (v2i64 (scalar_to_vector GR64:$src)),(iPTR 0)))),
            (SUBREG_TO_REG (i64 0), (VMOVZQI2PQIrr GR64:$src), sub_xmm)>;
}

let Predicates = [UseSSE2], AddedComplexity = 20 in {
  def : Pat<(v4i32 (X86vzmovl (bc_v4i32 (loadv4f32 addr:$src)))),
            (MOVZDI2PDIrm addr:$src)>;
  def : Pat<(v4i32 (X86vzmovl (bc_v4i32 (loadv2i64 addr:$src)))),
            (MOVZDI2PDIrm addr:$src)>;
}

// These are the correct encodings of the instructions so that we know how to
// read correct assembly, even though we continue to emit the wrong ones for
// compatibility with Darwin's buggy assembler.
def : InstAlias<"movq\t{$src, $dst|$dst, $src}",
                (MOV64toPQIrr VR128:$dst, GR64:$src), 0>;
def : InstAlias<"movq\t{$src, $dst|$dst, $src}",
                (MOV64toSDrr FR64:$dst, GR64:$src), 0>;
def : InstAlias<"movq\t{$src, $dst|$dst, $src}",
                (MOVPQIto64rr GR64:$dst, VR128:$src), 0>;
def : InstAlias<"movq\t{$src, $dst|$dst, $src}",
                (MOVSDto64rr GR64:$dst, FR64:$src), 0>;
def : InstAlias<"movq\t{$src, $dst|$dst, $src}",
                (VMOVZQI2PQIrr VR128:$dst, GR64:$src), 0>;
def : InstAlias<"movq\t{$src, $dst|$dst, $src}",
                (MOVZQI2PQIrr VR128:$dst, GR64:$src), 0>;

//===---------------------------------------------------------------------===//
// SSE2 - Move Quadword
//===---------------------------------------------------------------------===//

//===---------------------------------------------------------------------===//
// Move Quadword Int to Packed Quadword Int
//

let SchedRW = [WriteLoad] in {
def VMOVQI2PQIrm : I<0x7E, MRMSrcMem, (outs VR128:$dst), (ins i64mem:$src),
                    "vmovq\t{$src, $dst|$dst, $src}",
                    [(set VR128:$dst,
                      (v2i64 (scalar_to_vector (loadi64 addr:$src))))]>, XS,
                    VEX, Requires<[HasAVX]>;
def MOVQI2PQIrm : I<0x7E, MRMSrcMem, (outs VR128:$dst), (ins i64mem:$src),
                    "movq\t{$src, $dst|$dst, $src}",
                    [(set VR128:$dst,
                      (v2i64 (scalar_to_vector (loadi64 addr:$src))))],
                      IIC_SSE_MOVDQ>, XS,
                    Requires<[UseSSE2]>; // SSE2 instruction with XS Prefix
} // SchedRW

//===---------------------------------------------------------------------===//
// Move Packed Quadword Int to Quadword Int
//
let SchedRW = [WriteStore] in {
def VMOVPQI2QImr : VS2I<0xD6, MRMDestMem, (outs), (ins i64mem:$dst, VR128:$src),
                      "movq\t{$src, $dst|$dst, $src}",
                      [(store (i64 (vector_extract (v2i64 VR128:$src),
                                    (iPTR 0))), addr:$dst)],
                                    IIC_SSE_MOVDQ>, VEX;
def MOVPQI2QImr : S2I<0xD6, MRMDestMem, (outs), (ins i64mem:$dst, VR128:$src),
                      "movq\t{$src, $dst|$dst, $src}",
                      [(store (i64 (vector_extract (v2i64 VR128:$src),
                                    (iPTR 0))), addr:$dst)],
                                    IIC_SSE_MOVDQ>;
} // SchedRW

//===---------------------------------------------------------------------===//
// Store / copy lower 64-bits of a XMM register.
//
def VMOVLQ128mr : VS2I<0xD6, MRMDestMem, (outs), (ins i64mem:$dst, VR128:$src),
                     "movq\t{$src, $dst|$dst, $src}",
                     [(int_x86_sse2_storel_dq addr:$dst, VR128:$src)]>, VEX,
                  Sched<[WriteStore]>;
def MOVLQ128mr : S2I<0xD6, MRMDestMem, (outs), (ins i64mem:$dst, VR128:$src),
                     "movq\t{$src, $dst|$dst, $src}",
                     [(int_x86_sse2_storel_dq addr:$dst, VR128:$src)],
                     IIC_SSE_MOVDQ>, Sched<[WriteStore]>;

let AddedComplexity = 20 in
def VMOVZQI2PQIrm : I<0x7E, MRMSrcMem, (outs VR128:$dst), (ins i64mem:$src),
                     "vmovq\t{$src, $dst|$dst, $src}",
                     [(set VR128:$dst,
                       (v2i64 (X86vzmovl (v2i64 (scalar_to_vector
                                                 (loadi64 addr:$src))))))],
                                                 IIC_SSE_MOVDQ>,
                     XS, VEX, Requires<[HasAVX]>, Sched<[WriteLoad]>;

let AddedComplexity = 20 in
def MOVZQI2PQIrm : I<0x7E, MRMSrcMem, (outs VR128:$dst), (ins i64mem:$src),
                     "movq\t{$src, $dst|$dst, $src}",
                     [(set VR128:$dst,
                       (v2i64 (X86vzmovl (v2i64 (scalar_to_vector
                                                 (loadi64 addr:$src))))))],
                                                 IIC_SSE_MOVDQ>,
                     XS, Requires<[UseSSE2]>, Sched<[WriteLoad]>;

let Predicates = [HasAVX], AddedComplexity = 20 in {
  def : Pat<(v2i64 (X86vzmovl (loadv2i64 addr:$src))),
            (VMOVZQI2PQIrm addr:$src)>;
  def : Pat<(v2i64 (X86vzmovl (bc_v2i64 (loadv4f32 addr:$src)))),
            (VMOVZQI2PQIrm addr:$src)>;
  def : Pat<(v2i64 (X86vzload addr:$src)),
            (VMOVZQI2PQIrm addr:$src)>;
}

let Predicates = [UseSSE2], AddedComplexity = 20 in {
  def : Pat<(v2i64 (X86vzmovl (loadv2i64 addr:$src))),
            (MOVZQI2PQIrm addr:$src)>;
  def : Pat<(v2i64 (X86vzmovl (bc_v2i64 (loadv4f32 addr:$src)))),
            (MOVZQI2PQIrm addr:$src)>;
  def : Pat<(v2i64 (X86vzload addr:$src)), (MOVZQI2PQIrm addr:$src)>;
}

let Predicates = [HasAVX] in {
def : Pat<(v4i64 (alignedX86vzload addr:$src)),
          (SUBREG_TO_REG (i32 0), (VMOVAPSrm addr:$src), sub_xmm)>;
def : Pat<(v4i64 (X86vzload addr:$src)),
          (SUBREG_TO_REG (i32 0), (VMOVUPSrm addr:$src), sub_xmm)>;
}

//===---------------------------------------------------------------------===//
// Moving from XMM to XMM and clear upper 64 bits. Note, there is a bug in
// IA32 document. movq xmm1, xmm2 does clear the high bits.
//
let SchedRW = [WriteVecLogic] in {
let AddedComplexity = 15 in
def VMOVZPQILo2PQIrr : I<0x7E, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                        "vmovq\t{$src, $dst|$dst, $src}",
                    [(set VR128:$dst, (v2i64 (X86vzmovl (v2i64 VR128:$src))))],
                    IIC_SSE_MOVQ_RR>,
                      XS, VEX, Requires<[HasAVX]>;
let AddedComplexity = 15 in
def MOVZPQILo2PQIrr : I<0x7E, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                        "movq\t{$src, $dst|$dst, $src}",
                    [(set VR128:$dst, (v2i64 (X86vzmovl (v2i64 VR128:$src))))],
                    IIC_SSE_MOVQ_RR>,
                      XS, Requires<[UseSSE2]>;
} // SchedRW

let SchedRW = [WriteVecLogicLd] in {
let AddedComplexity = 20 in
def VMOVZPQILo2PQIrm : I<0x7E, MRMSrcMem, (outs VR128:$dst), (ins i128mem:$src),
                        "vmovq\t{$src, $dst|$dst, $src}",
                    [(set VR128:$dst, (v2i64 (X86vzmovl
                                             (loadv2i64 addr:$src))))],
                                             IIC_SSE_MOVDQ>,
                      XS, VEX, Requires<[HasAVX]>;
let AddedComplexity = 20 in {
def MOVZPQILo2PQIrm : I<0x7E, MRMSrcMem, (outs VR128:$dst), (ins i128mem:$src),
                        "movq\t{$src, $dst|$dst, $src}",
                    [(set VR128:$dst, (v2i64 (X86vzmovl
                                             (loadv2i64 addr:$src))))],
                                             IIC_SSE_MOVDQ>,
                      XS, Requires<[UseSSE2]>;
}
} // SchedRW

let AddedComplexity = 20 in {
  let Predicates = [HasAVX] in {
    def : Pat<(v2i64 (X86vzmovl (loadv2i64 addr:$src))),
              (VMOVZPQILo2PQIrm addr:$src)>;
    def : Pat<(v2f64 (X86vzmovl (v2f64 VR128:$src))),
              (VMOVZPQILo2PQIrr VR128:$src)>;
  }
  let Predicates = [UseSSE2] in {
    def : Pat<(v2i64 (X86vzmovl (loadv2i64 addr:$src))),
              (MOVZPQILo2PQIrm addr:$src)>;
    def : Pat<(v2f64 (X86vzmovl (v2f64 VR128:$src))),
              (MOVZPQILo2PQIrr VR128:$src)>;
  }
}

// Instructions to match in the assembler
let SchedRW = [WriteMove] in {
def VMOVQs64rr : VS2I<0x6E, MRMSrcReg, (outs VR128:$dst), (ins GR64:$src),
                      "movq\t{$src, $dst|$dst, $src}", [],
                      IIC_SSE_MOVDQ>, VEX, VEX_W;
def VMOVQd64rr : VS2I<0x7E, MRMDestReg, (outs GR64:$dst), (ins VR128:$src),
                      "movq\t{$src, $dst|$dst, $src}", [],
                      IIC_SSE_MOVDQ>, VEX, VEX_W;
// Recognize "movd" with GR64 destination, but encode as a "movq"
def VMOVQd64rr_alt : VS2I<0x7E, MRMDestReg, (outs GR64:$dst), (ins VR128:$src),
                          "movd\t{$src, $dst|$dst, $src}", [],
                          IIC_SSE_MOVDQ>, VEX, VEX_W;
} // SchedRW

// Instructions for the disassembler
// xr = XMM register
// xm = mem64

let SchedRW = [WriteMove] in {
let Predicates = [HasAVX] in
def VMOVQxrxr: I<0x7E, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                 "vmovq\t{$src, $dst|$dst, $src}", []>, VEX, XS;
def MOVQxrxr : I<0x7E, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                 "movq\t{$src, $dst|$dst, $src}", [], IIC_SSE_MOVQ_RR>, XS;
} // SchedRW

//===---------------------------------------------------------------------===//
// SSE3 - Replicate Single FP - MOVSHDUP and MOVSLDUP
//===---------------------------------------------------------------------===//
multiclass sse3_replicate_sfp<bits<8> op, SDNode OpNode, string OpcodeStr,
                              ValueType vt, RegisterClass RC, PatFrag mem_frag,
                              X86MemOperand x86memop> {
def rr : S3SI<op, MRMSrcReg, (outs RC:$dst), (ins RC:$src),
                    !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                      [(set RC:$dst, (vt (OpNode RC:$src)))],
                      IIC_SSE_MOV_LH>, Sched<[WriteShuffle]>;
def rm : S3SI<op, MRMSrcMem, (outs RC:$dst), (ins x86memop:$src),
                    !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                      [(set RC:$dst, (OpNode (mem_frag addr:$src)))],
                      IIC_SSE_MOV_LH>, Sched<[WriteShuffleLd]>;
}

let Predicates = [HasAVX] in {
  defm VMOVSHDUP  : sse3_replicate_sfp<0x16, X86Movshdup, "vmovshdup",
                                       v4f32, VR128, memopv4f32, f128mem>, VEX;
  defm VMOVSLDUP  : sse3_replicate_sfp<0x12, X86Movsldup, "vmovsldup",
                                       v4f32, VR128, memopv4f32, f128mem>, VEX;
  defm VMOVSHDUPY : sse3_replicate_sfp<0x16, X86Movshdup, "vmovshdup",
                                 v8f32, VR256, memopv8f32, f256mem>, VEX, VEX_L;
  defm VMOVSLDUPY : sse3_replicate_sfp<0x12, X86Movsldup, "vmovsldup",
                                 v8f32, VR256, memopv8f32, f256mem>, VEX, VEX_L;
}
defm MOVSHDUP : sse3_replicate_sfp<0x16, X86Movshdup, "movshdup", v4f32, VR128,
                                   memopv4f32, f128mem>;
defm MOVSLDUP : sse3_replicate_sfp<0x12, X86Movsldup, "movsldup", v4f32, VR128,
                                   memopv4f32, f128mem>;

let Predicates = [HasAVX] in {
  def : Pat<(v4i32 (X86Movshdup VR128:$src)),
            (VMOVSHDUPrr VR128:$src)>;
  def : Pat<(v4i32 (X86Movshdup (bc_v4i32 (memopv2i64 addr:$src)))),
            (VMOVSHDUPrm addr:$src)>;
  def : Pat<(v4i32 (X86Movsldup VR128:$src)),
            (VMOVSLDUPrr VR128:$src)>;
  def : Pat<(v4i32 (X86Movsldup (bc_v4i32 (memopv2i64 addr:$src)))),
            (VMOVSLDUPrm addr:$src)>;
  def : Pat<(v8i32 (X86Movshdup VR256:$src)),
            (VMOVSHDUPYrr VR256:$src)>;
  def : Pat<(v8i32 (X86Movshdup (bc_v8i32 (memopv4i64 addr:$src)))),
            (VMOVSHDUPYrm addr:$src)>;
  def : Pat<(v8i32 (X86Movsldup VR256:$src)),
            (VMOVSLDUPYrr VR256:$src)>;
  def : Pat<(v8i32 (X86Movsldup (bc_v8i32 (memopv4i64 addr:$src)))),
            (VMOVSLDUPYrm addr:$src)>;
}

let Predicates = [UseSSE3] in {
  def : Pat<(v4i32 (X86Movshdup VR128:$src)),
            (MOVSHDUPrr VR128:$src)>;
  def : Pat<(v4i32 (X86Movshdup (bc_v4i32 (memopv2i64 addr:$src)))),
            (MOVSHDUPrm addr:$src)>;
  def : Pat<(v4i32 (X86Movsldup VR128:$src)),
            (MOVSLDUPrr VR128:$src)>;
  def : Pat<(v4i32 (X86Movsldup (bc_v4i32 (memopv2i64 addr:$src)))),
            (MOVSLDUPrm addr:$src)>;
}

//===---------------------------------------------------------------------===//
// SSE3 - Replicate Double FP - MOVDDUP
//===---------------------------------------------------------------------===//

multiclass sse3_replicate_dfp<string OpcodeStr> {
let neverHasSideEffects = 1 in
def rr  : S3DI<0x12, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                    !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                    [], IIC_SSE_MOV_LH>, Sched<[WriteShuffle]>;
def rm  : S3DI<0x12, MRMSrcMem, (outs VR128:$dst), (ins f64mem:$src),
                    !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                    [(set VR128:$dst,
                      (v2f64 (X86Movddup
                              (scalar_to_vector (loadf64 addr:$src)))))],
                              IIC_SSE_MOV_LH>, Sched<[WriteShuffleLd]>;
}

// FIXME: Merge with above classe when there're patterns for the ymm version
multiclass sse3_replicate_dfp_y<string OpcodeStr> {
def rr  : S3DI<0x12, MRMSrcReg, (outs VR256:$dst), (ins VR256:$src),
                    !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                    [(set VR256:$dst, (v4f64 (X86Movddup VR256:$src)))]>,
                    Sched<[WriteShuffle]>;
def rm  : S3DI<0x12, MRMSrcMem, (outs VR256:$dst), (ins f256mem:$src),
                    !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                    [(set VR256:$dst,
                      (v4f64 (X86Movddup
                              (scalar_to_vector (loadf64 addr:$src)))))]>,
                    Sched<[WriteShuffleLd]>;
}

let Predicates = [HasAVX] in {
  defm VMOVDDUP  : sse3_replicate_dfp<"vmovddup">, VEX;
  defm VMOVDDUPY : sse3_replicate_dfp_y<"vmovddup">, VEX, VEX_L;
}

defm MOVDDUP : sse3_replicate_dfp<"movddup">;

let Predicates = [HasAVX] in {
  def : Pat<(X86Movddup (memopv2f64 addr:$src)),
            (VMOVDDUPrm addr:$src)>, Requires<[HasAVX]>;
  def : Pat<(X86Movddup (bc_v2f64 (memopv4f32 addr:$src))),
            (VMOVDDUPrm addr:$src)>, Requires<[HasAVX]>;
  def : Pat<(X86Movddup (bc_v2f64 (memopv2i64 addr:$src))),
            (VMOVDDUPrm addr:$src)>, Requires<[HasAVX]>;
  def : Pat<(X86Movddup (bc_v2f64
                             (v2i64 (scalar_to_vector (loadi64 addr:$src))))),
            (VMOVDDUPrm addr:$src)>, Requires<[HasAVX]>;

  // 256-bit version
  def : Pat<(X86Movddup (memopv4f64 addr:$src)),
            (VMOVDDUPYrm addr:$src)>;
  def : Pat<(X86Movddup (memopv4i64 addr:$src)),
            (VMOVDDUPYrm addr:$src)>;
  def : Pat<(X86Movddup (v4i64 (scalar_to_vector (loadi64 addr:$src)))),
            (VMOVDDUPYrm addr:$src)>;
  def : Pat<(X86Movddup (v4i64 VR256:$src)),
            (VMOVDDUPYrr VR256:$src)>;
}

let Predicates = [UseSSE3] in {
  def : Pat<(X86Movddup (memopv2f64 addr:$src)),
            (MOVDDUPrm addr:$src)>;
  def : Pat<(X86Movddup (bc_v2f64 (memopv4f32 addr:$src))),
            (MOVDDUPrm addr:$src)>;
  def : Pat<(X86Movddup (bc_v2f64 (memopv2i64 addr:$src))),
            (MOVDDUPrm addr:$src)>;
  def : Pat<(X86Movddup (bc_v2f64
                             (v2i64 (scalar_to_vector (loadi64 addr:$src))))),
            (MOVDDUPrm addr:$src)>;
}

//===---------------------------------------------------------------------===//
// SSE3 - Move Unaligned Integer
//===---------------------------------------------------------------------===//

let SchedRW = [WriteLoad] in {
let Predicates = [HasAVX] in {
  def VLDDQUrm : S3DI<0xF0, MRMSrcMem, (outs VR128:$dst), (ins i128mem:$src),
                   "vlddqu\t{$src, $dst|$dst, $src}",
                   [(set VR128:$dst, (int_x86_sse3_ldu_dq addr:$src))]>, VEX;
  def VLDDQUYrm : S3DI<0xF0, MRMSrcMem, (outs VR256:$dst), (ins i256mem:$src),
                   "vlddqu\t{$src, $dst|$dst, $src}",
                   [(set VR256:$dst, (int_x86_avx_ldu_dq_256 addr:$src))]>,
                   VEX, VEX_L;
}
def LDDQUrm : S3DI<0xF0, MRMSrcMem, (outs VR128:$dst), (ins i128mem:$src),
                   "lddqu\t{$src, $dst|$dst, $src}",
                   [(set VR128:$dst, (int_x86_sse3_ldu_dq addr:$src))],
                   IIC_SSE_LDDQU>;
}

//===---------------------------------------------------------------------===//
// SSE3 - Arithmetic
//===---------------------------------------------------------------------===//

multiclass sse3_addsub<Intrinsic Int, string OpcodeStr, RegisterClass RC,
                       X86MemOperand x86memop, OpndItins itins,
                       bit Is2Addr = 1> {
  def rr : I<0xD0, MRMSrcReg,
       (outs RC:$dst), (ins RC:$src1, RC:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (Int RC:$src1, RC:$src2))], itins.rr>,
       Sched<[itins.Sched]>;
  def rm : I<0xD0, MRMSrcMem,
       (outs RC:$dst), (ins RC:$src1, x86memop:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (Int RC:$src1, (memop addr:$src2)))], itins.rr>,
       Sched<[itins.Sched.Folded, ReadAfterLd]>;
}

let Predicates = [HasAVX] in {
  let ExeDomain = SSEPackedSingle in {
    defm VADDSUBPS : sse3_addsub<int_x86_sse3_addsub_ps, "vaddsubps", VR128,
                                 f128mem, SSE_ALU_F32P, 0>, TB, XD, VEX_4V;
    defm VADDSUBPSY : sse3_addsub<int_x86_avx_addsub_ps_256, "vaddsubps", VR256,
                               f256mem, SSE_ALU_F32P, 0>, TB, XD, VEX_4V, VEX_L;
  }
  let ExeDomain = SSEPackedDouble in {
    defm VADDSUBPD : sse3_addsub<int_x86_sse3_addsub_pd, "vaddsubpd", VR128,
                                 f128mem, SSE_ALU_F64P, 0>, TB, OpSize, VEX_4V;
    defm VADDSUBPDY : sse3_addsub<int_x86_avx_addsub_pd_256, "vaddsubpd", VR256,
                           f256mem, SSE_ALU_F64P, 0>, TB, OpSize, VEX_4V, VEX_L;
  }
}
let Constraints = "$src1 = $dst", Predicates = [UseSSE3] in {
  let ExeDomain = SSEPackedSingle in
  defm ADDSUBPS : sse3_addsub<int_x86_sse3_addsub_ps, "addsubps", VR128,
                              f128mem, SSE_ALU_F32P>, TB, XD;
  let ExeDomain = SSEPackedDouble in
  defm ADDSUBPD : sse3_addsub<int_x86_sse3_addsub_pd, "addsubpd", VR128,
                              f128mem, SSE_ALU_F64P>, TB, OpSize;
}

//===---------------------------------------------------------------------===//
// SSE3 Instructions
//===---------------------------------------------------------------------===//

// Horizontal ops
multiclass S3D_Int<bits<8> o, string OpcodeStr, ValueType vt, RegisterClass RC,
                   X86MemOperand x86memop, SDNode OpNode, bit Is2Addr = 1> {
  def rr : S3DI<o, MRMSrcReg, (outs RC:$dst), (ins RC:$src1, RC:$src2),
       !if(Is2Addr,
         !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
         !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
      [(set RC:$dst, (vt (OpNode RC:$src1, RC:$src2)))], IIC_SSE_HADDSUB_RR>,
      Sched<[WriteFAdd]>;

  def rm : S3DI<o, MRMSrcMem, (outs RC:$dst), (ins RC:$src1, x86memop:$src2),
       !if(Is2Addr,
         !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
         !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
      [(set RC:$dst, (vt (OpNode RC:$src1, (memop addr:$src2))))],
        IIC_SSE_HADDSUB_RM>, Sched<[WriteFAddLd, ReadAfterLd]>;
}
multiclass S3_Int<bits<8> o, string OpcodeStr, ValueType vt, RegisterClass RC,
                  X86MemOperand x86memop, SDNode OpNode, bit Is2Addr = 1> {
  def rr : S3I<o, MRMSrcReg, (outs RC:$dst), (ins RC:$src1, RC:$src2),
       !if(Is2Addr,
         !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
         !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
      [(set RC:$dst, (vt (OpNode RC:$src1, RC:$src2)))], IIC_SSE_HADDSUB_RR>,
      Sched<[WriteFAdd]>;

  def rm : S3I<o, MRMSrcMem, (outs RC:$dst), (ins RC:$src1, x86memop:$src2),
       !if(Is2Addr,
         !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
         !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
      [(set RC:$dst, (vt (OpNode RC:$src1, (memop addr:$src2))))],
        IIC_SSE_HADDSUB_RM>, Sched<[WriteFAddLd, ReadAfterLd]>;
}

let Predicates = [HasAVX] in {
  let ExeDomain = SSEPackedSingle in {
    defm VHADDPS  : S3D_Int<0x7C, "vhaddps", v4f32, VR128, f128mem,
                            X86fhadd, 0>, VEX_4V;
    defm VHSUBPS  : S3D_Int<0x7D, "vhsubps", v4f32, VR128, f128mem,
                            X86fhsub, 0>, VEX_4V;
    defm VHADDPSY : S3D_Int<0x7C, "vhaddps", v8f32, VR256, f256mem,
                            X86fhadd, 0>, VEX_4V, VEX_L;
    defm VHSUBPSY : S3D_Int<0x7D, "vhsubps", v8f32, VR256, f256mem,
                            X86fhsub, 0>, VEX_4V, VEX_L;
  }
  let ExeDomain = SSEPackedDouble in {
    defm VHADDPD  : S3_Int <0x7C, "vhaddpd", v2f64, VR128, f128mem,
                            X86fhadd, 0>, VEX_4V;
    defm VHSUBPD  : S3_Int <0x7D, "vhsubpd", v2f64, VR128, f128mem,
                            X86fhsub, 0>, VEX_4V;
    defm VHADDPDY : S3_Int <0x7C, "vhaddpd", v4f64, VR256, f256mem,
                            X86fhadd, 0>, VEX_4V, VEX_L;
    defm VHSUBPDY : S3_Int <0x7D, "vhsubpd", v4f64, VR256, f256mem,
                            X86fhsub, 0>, VEX_4V, VEX_L;
  }
}

let Constraints = "$src1 = $dst" in {
  let ExeDomain = SSEPackedSingle in {
    defm HADDPS : S3D_Int<0x7C, "haddps", v4f32, VR128, f128mem, X86fhadd>;
    defm HSUBPS : S3D_Int<0x7D, "hsubps", v4f32, VR128, f128mem, X86fhsub>;
  }
  let ExeDomain = SSEPackedDouble in {
    defm HADDPD : S3_Int<0x7C, "haddpd", v2f64, VR128, f128mem, X86fhadd>;
    defm HSUBPD : S3_Int<0x7D, "hsubpd", v2f64, VR128, f128mem, X86fhsub>;
  }
}

//===---------------------------------------------------------------------===//
// SSSE3 - Packed Absolute Instructions
//===---------------------------------------------------------------------===//


/// SS3I_unop_rm_int - Simple SSSE3 unary op whose type can be v*{i8,i16,i32}.
multiclass SS3I_unop_rm_int<bits<8> opc, string OpcodeStr,
                            Intrinsic IntId128> {
  def rr128 : SS38I<opc, MRMSrcReg, (outs VR128:$dst),
                    (ins VR128:$src),
                    !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                    [(set VR128:$dst, (IntId128 VR128:$src))], IIC_SSE_PABS_RR>,
                    OpSize, Sched<[WriteVecALU]>;

  def rm128 : SS38I<opc, MRMSrcMem, (outs VR128:$dst),
                    (ins i128mem:$src),
                    !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                    [(set VR128:$dst,
                      (IntId128
                       (bitconvert (memopv2i64 addr:$src))))], IIC_SSE_PABS_RM>,
                    OpSize, Sched<[WriteVecALULd]>;
}

/// SS3I_unop_rm_int_y - Simple SSSE3 unary op whose type can be v*{i8,i16,i32}.
multiclass SS3I_unop_rm_int_y<bits<8> opc, string OpcodeStr,
                              Intrinsic IntId256> {
  def rr256 : SS38I<opc, MRMSrcReg, (outs VR256:$dst),
                    (ins VR256:$src),
                    !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                    [(set VR256:$dst, (IntId256 VR256:$src))]>,
                    OpSize, Sched<[WriteVecALU]>;

  def rm256 : SS38I<opc, MRMSrcMem, (outs VR256:$dst),
                    (ins i256mem:$src),
                    !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                    [(set VR256:$dst,
                      (IntId256
                       (bitconvert (memopv4i64 addr:$src))))]>, OpSize,
                    Sched<[WriteVecALULd]>;
}

// Helper fragments to match sext vXi1 to vXiY.
def v16i1sextv16i8 : PatLeaf<(v16i8 (X86pcmpgt (bc_v16i8 (v4i32 immAllZerosV)),
                                               VR128:$src))>;
def v8i1sextv8i16  : PatLeaf<(v8i16 (X86vsrai VR128:$src, (i32 15)))>;
def v4i1sextv4i32  : PatLeaf<(v4i32 (X86vsrai VR128:$src, (i32 31)))>;
def v32i1sextv32i8 : PatLeaf<(v32i8 (X86pcmpgt (bc_v32i8 (v8i32 immAllZerosV)),
                                               VR256:$src))>;
def v16i1sextv16i16: PatLeaf<(v16i16 (X86vsrai VR256:$src, (i32 15)))>;
def v8i1sextv8i32  : PatLeaf<(v8i32 (X86vsrai VR256:$src, (i32 31)))>;

let Predicates = [HasAVX] in {
  defm VPABSB  : SS3I_unop_rm_int<0x1C, "vpabsb",
                                  int_x86_ssse3_pabs_b_128>, VEX;
  defm VPABSW  : SS3I_unop_rm_int<0x1D, "vpabsw",
                                  int_x86_ssse3_pabs_w_128>, VEX;
  defm VPABSD  : SS3I_unop_rm_int<0x1E, "vpabsd",
                                  int_x86_ssse3_pabs_d_128>, VEX;

  def : Pat<(xor
            (bc_v2i64 (v16i1sextv16i8)),
            (bc_v2i64 (add (v16i8 VR128:$src), (v16i1sextv16i8)))),
            (VPABSBrr128 VR128:$src)>;
  def : Pat<(xor
            (bc_v2i64 (v8i1sextv8i16)),
            (bc_v2i64 (add (v8i16 VR128:$src), (v8i1sextv8i16)))),
            (VPABSWrr128 VR128:$src)>;
  def : Pat<(xor
            (bc_v2i64 (v4i1sextv4i32)),
            (bc_v2i64 (add (v4i32 VR128:$src), (v4i1sextv4i32)))),
            (VPABSDrr128 VR128:$src)>;
}

let Predicates = [HasAVX2] in {
  defm VPABSB  : SS3I_unop_rm_int_y<0x1C, "vpabsb",
                                    int_x86_avx2_pabs_b>, VEX, VEX_L;
  defm VPABSW  : SS3I_unop_rm_int_y<0x1D, "vpabsw",
                                    int_x86_avx2_pabs_w>, VEX, VEX_L;
  defm VPABSD  : SS3I_unop_rm_int_y<0x1E, "vpabsd",
                                    int_x86_avx2_pabs_d>, VEX, VEX_L;

  def : Pat<(xor
            (bc_v4i64 (v32i1sextv32i8)),
            (bc_v4i64 (add (v32i8 VR256:$src), (v32i1sextv32i8)))),
            (VPABSBrr256 VR256:$src)>;
  def : Pat<(xor
            (bc_v4i64 (v16i1sextv16i16)),
            (bc_v4i64 (add (v16i16 VR256:$src), (v16i1sextv16i16)))),
            (VPABSWrr256 VR256:$src)>;
  def : Pat<(xor
            (bc_v4i64 (v8i1sextv8i32)),
            (bc_v4i64 (add (v8i32 VR256:$src), (v8i1sextv8i32)))),
            (VPABSDrr256 VR256:$src)>;
}

defm PABSB : SS3I_unop_rm_int<0x1C, "pabsb",
                              int_x86_ssse3_pabs_b_128>;
defm PABSW : SS3I_unop_rm_int<0x1D, "pabsw",
                              int_x86_ssse3_pabs_w_128>;
defm PABSD : SS3I_unop_rm_int<0x1E, "pabsd",
                              int_x86_ssse3_pabs_d_128>;

let Predicates = [HasSSSE3] in {
  def : Pat<(xor
            (bc_v2i64 (v16i1sextv16i8)),
            (bc_v2i64 (add (v16i8 VR128:$src), (v16i1sextv16i8)))),
            (PABSBrr128 VR128:$src)>;
  def : Pat<(xor
            (bc_v2i64 (v8i1sextv8i16)),
            (bc_v2i64 (add (v8i16 VR128:$src), (v8i1sextv8i16)))),
            (PABSWrr128 VR128:$src)>;
  def : Pat<(xor
            (bc_v2i64 (v4i1sextv4i32)),
            (bc_v2i64 (add (v4i32 VR128:$src), (v4i1sextv4i32)))),
            (PABSDrr128 VR128:$src)>;
}

//===---------------------------------------------------------------------===//
// SSSE3 - Packed Binary Operator Instructions
//===---------------------------------------------------------------------===//

let Sched = WriteVecALU in {
def SSE_PHADDSUBD : OpndItins<
  IIC_SSE_PHADDSUBD_RR, IIC_SSE_PHADDSUBD_RM
>;
def SSE_PHADDSUBSW : OpndItins<
  IIC_SSE_PHADDSUBSW_RR, IIC_SSE_PHADDSUBSW_RM
>;
def SSE_PHADDSUBW : OpndItins<
  IIC_SSE_PHADDSUBW_RR, IIC_SSE_PHADDSUBW_RM
>;
}
let Sched = WriteShuffle in
def SSE_PSHUFB : OpndItins<
  IIC_SSE_PSHUFB_RR, IIC_SSE_PSHUFB_RM
>;
let Sched = WriteVecALU in
def SSE_PSIGN : OpndItins<
  IIC_SSE_PSIGN_RR, IIC_SSE_PSIGN_RM
>;
let Sched = WriteVecIMul in
def SSE_PMULHRSW : OpndItins<
  IIC_SSE_PMULHRSW, IIC_SSE_PMULHRSW
>;

/// SS3I_binop_rm - Simple SSSE3 bin op
multiclass SS3I_binop_rm<bits<8> opc, string OpcodeStr, SDNode OpNode,
                         ValueType OpVT, RegisterClass RC, PatFrag memop_frag,
                         X86MemOperand x86memop, OpndItins itins,
                         bit Is2Addr = 1> {
  let isCommutable = 1 in
  def rr : SS38I<opc, MRMSrcReg, (outs RC:$dst),
       (ins RC:$src1, RC:$src2),
       !if(Is2Addr,
         !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
         !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (OpVT (OpNode RC:$src1, RC:$src2)))], itins.rr>,
       OpSize, Sched<[itins.Sched]>;
  def rm : SS38I<opc, MRMSrcMem, (outs RC:$dst),
       (ins RC:$src1, x86memop:$src2),
       !if(Is2Addr,
         !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
         !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst,
         (OpVT (OpNode RC:$src1,
          (bitconvert (memop_frag addr:$src2)))))], itins.rm>, OpSize,
       Sched<[itins.Sched.Folded, ReadAfterLd]>;
}

/// SS3I_binop_rm_int - Simple SSSE3 bin op whose type can be v*{i8,i16,i32}.
multiclass SS3I_binop_rm_int<bits<8> opc, string OpcodeStr,
                             Intrinsic IntId128, OpndItins itins,
                             bit Is2Addr = 1> {
  let isCommutable = 1 in
  def rr128 : SS38I<opc, MRMSrcReg, (outs VR128:$dst),
       (ins VR128:$src1, VR128:$src2),
       !if(Is2Addr,
         !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
         !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set VR128:$dst, (IntId128 VR128:$src1, VR128:$src2))]>,
       OpSize, Sched<[itins.Sched]>;
  def rm128 : SS38I<opc, MRMSrcMem, (outs VR128:$dst),
       (ins VR128:$src1, i128mem:$src2),
       !if(Is2Addr,
         !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
         !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set VR128:$dst,
         (IntId128 VR128:$src1,
          (bitconvert (memopv2i64 addr:$src2))))]>, OpSize,
       Sched<[itins.Sched.Folded, ReadAfterLd]>;
}

multiclass SS3I_binop_rm_int_y<bits<8> opc, string OpcodeStr,
                               Intrinsic IntId256> {
  let isCommutable = 1 in
  def rr256 : SS38I<opc, MRMSrcReg, (outs VR256:$dst),
       (ins VR256:$src1, VR256:$src2),
       !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
       [(set VR256:$dst, (IntId256 VR256:$src1, VR256:$src2))]>,
       OpSize;
  def rm256 : SS38I<opc, MRMSrcMem, (outs VR256:$dst),
       (ins VR256:$src1, i256mem:$src2),
       !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
       [(set VR256:$dst,
         (IntId256 VR256:$src1,
          (bitconvert (memopv4i64 addr:$src2))))]>, OpSize;
}

let ImmT = NoImm, Predicates = [HasAVX] in {
let isCommutable = 0 in {
  defm VPHADDW    : SS3I_binop_rm<0x01, "vphaddw", X86hadd, v8i16, VR128,
                                  memopv2i64, i128mem,
                                  SSE_PHADDSUBW, 0>, VEX_4V;
  defm VPHADDD    : SS3I_binop_rm<0x02, "vphaddd", X86hadd, v4i32, VR128,
                                  memopv2i64, i128mem,
                                  SSE_PHADDSUBD, 0>, VEX_4V;
  defm VPHSUBW    : SS3I_binop_rm<0x05, "vphsubw", X86hsub, v8i16, VR128,
                                  memopv2i64, i128mem,
                                  SSE_PHADDSUBW, 0>, VEX_4V;
  defm VPHSUBD    : SS3I_binop_rm<0x06, "vphsubd", X86hsub, v4i32, VR128,
                                  memopv2i64, i128mem,
                                  SSE_PHADDSUBD, 0>, VEX_4V;
  defm VPSIGNB    : SS3I_binop_rm<0x08, "vpsignb", X86psign, v16i8, VR128,
                                  memopv2i64, i128mem,
                                  SSE_PSIGN, 0>, VEX_4V;
  defm VPSIGNW    : SS3I_binop_rm<0x09, "vpsignw", X86psign, v8i16, VR128,
                                  memopv2i64, i128mem,
                                  SSE_PSIGN, 0>, VEX_4V;
  defm VPSIGND    : SS3I_binop_rm<0x0A, "vpsignd", X86psign, v4i32, VR128,
                                  memopv2i64, i128mem,
                                  SSE_PSIGN, 0>, VEX_4V;
  defm VPSHUFB    : SS3I_binop_rm<0x00, "vpshufb", X86pshufb, v16i8, VR128,
                                  memopv2i64, i128mem,
                                  SSE_PSHUFB, 0>, VEX_4V;
  defm VPHADDSW   : SS3I_binop_rm_int<0x03, "vphaddsw",
                                      int_x86_ssse3_phadd_sw_128,
                                      SSE_PHADDSUBSW, 0>, VEX_4V;
  defm VPHSUBSW   : SS3I_binop_rm_int<0x07, "vphsubsw",
                                      int_x86_ssse3_phsub_sw_128,
                                      SSE_PHADDSUBSW, 0>, VEX_4V;
  defm VPMADDUBSW : SS3I_binop_rm_int<0x04, "vpmaddubsw",
                                      int_x86_ssse3_pmadd_ub_sw_128,
                                      SSE_PMADD, 0>, VEX_4V;
}
defm VPMULHRSW    : SS3I_binop_rm_int<0x0B, "vpmulhrsw",
                                      int_x86_ssse3_pmul_hr_sw_128,
                                      SSE_PMULHRSW, 0>, VEX_4V;
}

let ImmT = NoImm, Predicates = [HasAVX2] in {
let isCommutable = 0 in {
  defm VPHADDWY   : SS3I_binop_rm<0x01, "vphaddw", X86hadd, v16i16, VR256,
                                  memopv4i64, i256mem,
                                  SSE_PHADDSUBW, 0>, VEX_4V, VEX_L;
  defm VPHADDDY   : SS3I_binop_rm<0x02, "vphaddd", X86hadd, v8i32, VR256,
                                  memopv4i64, i256mem,
                                  SSE_PHADDSUBW, 0>, VEX_4V, VEX_L;
  defm VPHSUBWY   : SS3I_binop_rm<0x05, "vphsubw", X86hsub, v16i16, VR256,
                                  memopv4i64, i256mem,
                                  SSE_PHADDSUBW, 0>, VEX_4V, VEX_L;
  defm VPHSUBDY   : SS3I_binop_rm<0x06, "vphsubd", X86hsub, v8i32, VR256,
                                  memopv4i64, i256mem,
                                  SSE_PHADDSUBW, 0>, VEX_4V, VEX_L;
  defm VPSIGNBY   : SS3I_binop_rm<0x08, "vpsignb", X86psign, v32i8, VR256,
                                  memopv4i64, i256mem,
                                  SSE_PHADDSUBW, 0>, VEX_4V, VEX_L;
  defm VPSIGNWY   : SS3I_binop_rm<0x09, "vpsignw", X86psign, v16i16, VR256,
                                  memopv4i64, i256mem,
                                  SSE_PHADDSUBW, 0>, VEX_4V, VEX_L;
  defm VPSIGNDY   : SS3I_binop_rm<0x0A, "vpsignd", X86psign, v8i32, VR256,
                                  memopv4i64, i256mem,
                                  SSE_PHADDSUBW, 0>, VEX_4V, VEX_L;
  defm VPSHUFBY   : SS3I_binop_rm<0x00, "vpshufb", X86pshufb, v32i8, VR256,
                                  memopv4i64, i256mem,
                                  SSE_PHADDSUBW, 0>, VEX_4V, VEX_L;
  defm VPHADDSW   : SS3I_binop_rm_int_y<0x03, "vphaddsw",
                                        int_x86_avx2_phadd_sw>, VEX_4V, VEX_L;
  defm VPHSUBSW   : SS3I_binop_rm_int_y<0x07, "vphsubsw",
                                        int_x86_avx2_phsub_sw>, VEX_4V, VEX_L;
  defm VPMADDUBSW : SS3I_binop_rm_int_y<0x04, "vpmaddubsw",
                                       int_x86_avx2_pmadd_ub_sw>, VEX_4V, VEX_L;
}
defm VPMULHRSW    : SS3I_binop_rm_int_y<0x0B, "vpmulhrsw",
                                        int_x86_avx2_pmul_hr_sw>, VEX_4V, VEX_L;
}

// None of these have i8 immediate fields.
let ImmT = NoImm, Constraints = "$src1 = $dst" in {
let isCommutable = 0 in {
  defm PHADDW    : SS3I_binop_rm<0x01, "phaddw", X86hadd, v8i16, VR128,
                                 memopv2i64, i128mem, SSE_PHADDSUBW>;
  defm PHADDD    : SS3I_binop_rm<0x02, "phaddd", X86hadd, v4i32, VR128,
                                 memopv2i64, i128mem, SSE_PHADDSUBD>;
  defm PHSUBW    : SS3I_binop_rm<0x05, "phsubw", X86hsub, v8i16, VR128,
                                 memopv2i64, i128mem, SSE_PHADDSUBW>;
  defm PHSUBD    : SS3I_binop_rm<0x06, "phsubd", X86hsub, v4i32, VR128,
                                 memopv2i64, i128mem, SSE_PHADDSUBD>;
  defm PSIGNB    : SS3I_binop_rm<0x08, "psignb", X86psign, v16i8, VR128,
                                 memopv2i64, i128mem, SSE_PSIGN>;
  defm PSIGNW    : SS3I_binop_rm<0x09, "psignw", X86psign, v8i16, VR128,
                                 memopv2i64, i128mem, SSE_PSIGN>;
  defm PSIGND    : SS3I_binop_rm<0x0A, "psignd", X86psign, v4i32, VR128,
                                 memopv2i64, i128mem, SSE_PSIGN>;
  defm PSHUFB    : SS3I_binop_rm<0x00, "pshufb", X86pshufb, v16i8, VR128,
                                 memopv2i64, i128mem, SSE_PSHUFB>;
  defm PHADDSW   : SS3I_binop_rm_int<0x03, "phaddsw",
                                     int_x86_ssse3_phadd_sw_128,
                                     SSE_PHADDSUBSW>;
  defm PHSUBSW   : SS3I_binop_rm_int<0x07, "phsubsw",
                                     int_x86_ssse3_phsub_sw_128,
                                     SSE_PHADDSUBSW>;
  defm PMADDUBSW : SS3I_binop_rm_int<0x04, "pmaddubsw",
                                     int_x86_ssse3_pmadd_ub_sw_128, SSE_PMADD>;
}
defm PMULHRSW    : SS3I_binop_rm_int<0x0B, "pmulhrsw",
                                     int_x86_ssse3_pmul_hr_sw_128,
                                     SSE_PMULHRSW>;
}

//===---------------------------------------------------------------------===//
// SSSE3 - Packed Align Instruction Patterns
//===---------------------------------------------------------------------===//

multiclass ssse3_palignr<string asm, bit Is2Addr = 1> {
  let neverHasSideEffects = 1 in {
  def R128rr : SS3AI<0x0F, MRMSrcReg, (outs VR128:$dst),
      (ins VR128:$src1, VR128:$src2, i8imm:$src3),
      !if(Is2Addr,
        !strconcat(asm, "\t{$src3, $src2, $dst|$dst, $src2, $src3}"),
        !strconcat(asm,
                  "\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}")),
      [], IIC_SSE_PALIGNR>, OpSize, Sched<[WriteShuffle]>;
  let mayLoad = 1 in
  def R128rm : SS3AI<0x0F, MRMSrcMem, (outs VR128:$dst),
      (ins VR128:$src1, i128mem:$src2, i8imm:$src3),
      !if(Is2Addr,
        !strconcat(asm, "\t{$src3, $src2, $dst|$dst, $src2, $src3}"),
        !strconcat(asm,
                  "\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}")),
      [], IIC_SSE_PALIGNR>, OpSize, Sched<[WriteShuffleLd, ReadAfterLd]>;
  }
}

multiclass ssse3_palignr_y<string asm, bit Is2Addr = 1> {
  let neverHasSideEffects = 1 in {
  def R256rr : SS3AI<0x0F, MRMSrcReg, (outs VR256:$dst),
      (ins VR256:$src1, VR256:$src2, i8imm:$src3),
      !strconcat(asm,
                 "\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}"),
      []>, OpSize, Sched<[WriteShuffle]>;
  let mayLoad = 1 in
  def R256rm : SS3AI<0x0F, MRMSrcMem, (outs VR256:$dst),
      (ins VR256:$src1, i256mem:$src2, i8imm:$src3),
      !strconcat(asm,
                 "\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}"),
      []>, OpSize, Sched<[WriteShuffleLd, ReadAfterLd]>;
  }
}

let Predicates = [HasAVX] in
  defm VPALIGN : ssse3_palignr<"vpalignr", 0>, VEX_4V;
let Predicates = [HasAVX2] in
  defm VPALIGN : ssse3_palignr_y<"vpalignr", 0>, VEX_4V, VEX_L;
let Constraints = "$src1 = $dst", Predicates = [UseSSSE3] in
  defm PALIGN : ssse3_palignr<"palignr">;

let Predicates = [HasAVX2] in {
def : Pat<(v8i32 (X86PAlignr VR256:$src1, VR256:$src2, (i8 imm:$imm))),
          (VPALIGNR256rr VR256:$src2, VR256:$src1, imm:$imm)>;
def : Pat<(v8f32 (X86PAlignr VR256:$src1, VR256:$src2, (i8 imm:$imm))),
          (VPALIGNR256rr VR256:$src2, VR256:$src1, imm:$imm)>;
def : Pat<(v16i16 (X86PAlignr VR256:$src1, VR256:$src2, (i8 imm:$imm))),
          (VPALIGNR256rr VR256:$src2, VR256:$src1, imm:$imm)>;
def : Pat<(v32i8 (X86PAlignr VR256:$src1, VR256:$src2, (i8 imm:$imm))),
          (VPALIGNR256rr VR256:$src2, VR256:$src1, imm:$imm)>;
}

let Predicates = [HasAVX] in {
def : Pat<(v4i32 (X86PAlignr VR128:$src1, VR128:$src2, (i8 imm:$imm))),
          (VPALIGNR128rr VR128:$src2, VR128:$src1, imm:$imm)>;
def : Pat<(v4f32 (X86PAlignr VR128:$src1, VR128:$src2, (i8 imm:$imm))),
          (VPALIGNR128rr VR128:$src2, VR128:$src1, imm:$imm)>;
def : Pat<(v8i16 (X86PAlignr VR128:$src1, VR128:$src2, (i8 imm:$imm))),
          (VPALIGNR128rr VR128:$src2, VR128:$src1, imm:$imm)>;
def : Pat<(v16i8 (X86PAlignr VR128:$src1, VR128:$src2, (i8 imm:$imm))),
          (VPALIGNR128rr VR128:$src2, VR128:$src1, imm:$imm)>;
}

let Predicates = [UseSSSE3] in {
def : Pat<(v4i32 (X86PAlignr VR128:$src1, VR128:$src2, (i8 imm:$imm))),
          (PALIGNR128rr VR128:$src2, VR128:$src1, imm:$imm)>;
def : Pat<(v4f32 (X86PAlignr VR128:$src1, VR128:$src2, (i8 imm:$imm))),
          (PALIGNR128rr VR128:$src2, VR128:$src1, imm:$imm)>;
def : Pat<(v8i16 (X86PAlignr VR128:$src1, VR128:$src2, (i8 imm:$imm))),
          (PALIGNR128rr VR128:$src2, VR128:$src1, imm:$imm)>;
def : Pat<(v16i8 (X86PAlignr VR128:$src1, VR128:$src2, (i8 imm:$imm))),
          (PALIGNR128rr VR128:$src2, VR128:$src1, imm:$imm)>;
}

//===---------------------------------------------------------------------===//
// SSSE3 - Thread synchronization
//===---------------------------------------------------------------------===//

let SchedRW = [WriteSystem] in {
let usesCustomInserter = 1 in {
def MONITOR : PseudoI<(outs), (ins i32mem:$src1, GR32:$src2, GR32:$src3),
                [(int_x86_sse3_monitor addr:$src1, GR32:$src2, GR32:$src3)]>,
                Requires<[HasSSE3]>;
}

let Uses = [EAX, ECX, EDX] in
def MONITORrrr : I<0x01, MRM_C8, (outs), (ins), "monitor", [], IIC_SSE_MONITOR>,
                 TB, Requires<[HasSSE3]>;
let Uses = [ECX, EAX] in
def MWAITrr   : I<0x01, MRM_C9, (outs), (ins), "mwait",
                [(int_x86_sse3_mwait ECX, EAX)], IIC_SSE_MWAIT>,
                TB, Requires<[HasSSE3]>;
} // SchedRW

def : InstAlias<"mwait %eax, %ecx", (MWAITrr)>, Requires<[In32BitMode]>;
def : InstAlias<"mwait %rax, %rcx", (MWAITrr)>, Requires<[In64BitMode]>;

def : InstAlias<"monitor %eax, %ecx, %edx", (MONITORrrr)>,
      Requires<[In32BitMode]>;
def : InstAlias<"monitor %rax, %rcx, %rdx", (MONITORrrr)>,
      Requires<[In64BitMode]>;

//===----------------------------------------------------------------------===//
// SSE4.1 - Packed Move with Sign/Zero Extend
//===----------------------------------------------------------------------===//

multiclass SS41I_binop_rm_int8<bits<8> opc, string OpcodeStr, Intrinsic IntId> {
  def rr : SS48I<opc, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                 !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                 [(set VR128:$dst, (IntId VR128:$src))]>, OpSize;

  def rm : SS48I<opc, MRMSrcMem, (outs VR128:$dst), (ins i64mem:$src),
                 !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
       [(set VR128:$dst,
         (IntId (bitconvert (v2i64 (scalar_to_vector (loadi64 addr:$src))))))]>,
       OpSize;
}

multiclass SS41I_binop_rm_int16_y<bits<8> opc, string OpcodeStr,
                                 Intrinsic IntId> {
  def Yrr : SS48I<opc, MRMSrcReg, (outs VR256:$dst), (ins VR128:$src),
                  !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                  [(set VR256:$dst, (IntId VR128:$src))]>, OpSize;

  def Yrm : SS48I<opc, MRMSrcMem, (outs VR256:$dst), (ins i128mem:$src),
                  !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                  [(set VR256:$dst, (IntId (load addr:$src)))]>, OpSize;
}

let Predicates = [HasAVX] in {
defm VPMOVSXBW : SS41I_binop_rm_int8<0x20, "vpmovsxbw", int_x86_sse41_pmovsxbw>,
                                     VEX;
defm VPMOVSXWD : SS41I_binop_rm_int8<0x23, "vpmovsxwd", int_x86_sse41_pmovsxwd>,
                                     VEX;
defm VPMOVSXDQ : SS41I_binop_rm_int8<0x25, "vpmovsxdq", int_x86_sse41_pmovsxdq>,
                                     VEX;
defm VPMOVZXBW : SS41I_binop_rm_int8<0x30, "vpmovzxbw", int_x86_sse41_pmovzxbw>,
                                     VEX;
defm VPMOVZXWD : SS41I_binop_rm_int8<0x33, "vpmovzxwd", int_x86_sse41_pmovzxwd>,
                                     VEX;
defm VPMOVZXDQ : SS41I_binop_rm_int8<0x35, "vpmovzxdq", int_x86_sse41_pmovzxdq>,
                                     VEX;
}

let Predicates = [HasAVX2] in {
defm VPMOVSXBW : SS41I_binop_rm_int16_y<0x20, "vpmovsxbw",
                                        int_x86_avx2_pmovsxbw>, VEX, VEX_L;
defm VPMOVSXWD : SS41I_binop_rm_int16_y<0x23, "vpmovsxwd",
                                        int_x86_avx2_pmovsxwd>, VEX, VEX_L;
defm VPMOVSXDQ : SS41I_binop_rm_int16_y<0x25, "vpmovsxdq",
                                        int_x86_avx2_pmovsxdq>, VEX, VEX_L;
defm VPMOVZXBW : SS41I_binop_rm_int16_y<0x30, "vpmovzxbw",
                                        int_x86_avx2_pmovzxbw>, VEX, VEX_L;
defm VPMOVZXWD : SS41I_binop_rm_int16_y<0x33, "vpmovzxwd",
                                        int_x86_avx2_pmovzxwd>, VEX, VEX_L;
defm VPMOVZXDQ : SS41I_binop_rm_int16_y<0x35, "vpmovzxdq",
                                        int_x86_avx2_pmovzxdq>, VEX, VEX_L;
}

defm PMOVSXBW   : SS41I_binop_rm_int8<0x20, "pmovsxbw", int_x86_sse41_pmovsxbw>;
defm PMOVSXWD   : SS41I_binop_rm_int8<0x23, "pmovsxwd", int_x86_sse41_pmovsxwd>;
defm PMOVSXDQ   : SS41I_binop_rm_int8<0x25, "pmovsxdq", int_x86_sse41_pmovsxdq>;
defm PMOVZXBW   : SS41I_binop_rm_int8<0x30, "pmovzxbw", int_x86_sse41_pmovzxbw>;
defm PMOVZXWD   : SS41I_binop_rm_int8<0x33, "pmovzxwd", int_x86_sse41_pmovzxwd>;
defm PMOVZXDQ   : SS41I_binop_rm_int8<0x35, "pmovzxdq", int_x86_sse41_pmovzxdq>;

let Predicates = [HasAVX] in {
  // Common patterns involving scalar load.
  def : Pat<(int_x86_sse41_pmovsxbw (vzmovl_v2i64 addr:$src)),
            (VPMOVSXBWrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovsxbw (vzload_v2i64 addr:$src)),
            (VPMOVSXBWrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovsxbw (bc_v16i8 (loadv2i64 addr:$src))),
            (VPMOVSXBWrm addr:$src)>;

  def : Pat<(int_x86_sse41_pmovsxwd (vzmovl_v2i64 addr:$src)),
            (VPMOVSXWDrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovsxwd (vzload_v2i64 addr:$src)),
            (VPMOVSXWDrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovsxwd (bc_v8i16 (loadv2i64 addr:$src))),
            (VPMOVSXWDrm addr:$src)>;

  def : Pat<(int_x86_sse41_pmovsxdq (vzmovl_v2i64 addr:$src)),
            (VPMOVSXDQrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovsxdq (vzload_v2i64 addr:$src)),
            (VPMOVSXDQrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovsxdq (bc_v4i32 (loadv2i64 addr:$src))),
            (VPMOVSXDQrm addr:$src)>;

  def : Pat<(int_x86_sse41_pmovzxbw (vzmovl_v2i64 addr:$src)),
            (VPMOVZXBWrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovzxbw (vzload_v2i64 addr:$src)),
            (VPMOVZXBWrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovzxbw (bc_v16i8 (loadv2i64 addr:$src))),
            (VPMOVZXBWrm addr:$src)>;

  def : Pat<(int_x86_sse41_pmovzxwd (vzmovl_v2i64 addr:$src)),
            (VPMOVZXWDrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovzxwd (vzload_v2i64 addr:$src)),
            (VPMOVZXWDrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovzxwd (bc_v8i16 (loadv2i64 addr:$src))),
            (VPMOVZXWDrm addr:$src)>;

  def : Pat<(int_x86_sse41_pmovzxdq (vzmovl_v2i64 addr:$src)),
            (VPMOVZXDQrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovzxdq (vzload_v2i64 addr:$src)),
            (VPMOVZXDQrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovzxdq (bc_v4i32 (loadv2i64 addr:$src))),
            (VPMOVZXDQrm addr:$src)>;
}

let Predicates = [UseSSE41] in {
  // Common patterns involving scalar load.
  def : Pat<(int_x86_sse41_pmovsxbw (vzmovl_v2i64 addr:$src)),
            (PMOVSXBWrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovsxbw (vzload_v2i64 addr:$src)),
            (PMOVSXBWrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovsxbw (bc_v16i8 (loadv2i64 addr:$src))),
            (PMOVSXBWrm addr:$src)>;

  def : Pat<(int_x86_sse41_pmovsxwd (vzmovl_v2i64 addr:$src)),
            (PMOVSXWDrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovsxwd (vzload_v2i64 addr:$src)),
            (PMOVSXWDrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovsxwd (bc_v8i16 (loadv2i64 addr:$src))),
            (PMOVSXWDrm addr:$src)>;

  def : Pat<(int_x86_sse41_pmovsxdq (vzmovl_v2i64 addr:$src)),
            (PMOVSXDQrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovsxdq (vzload_v2i64 addr:$src)),
            (PMOVSXDQrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovsxdq (bc_v4i32 (loadv2i64 addr:$src))),
            (PMOVSXDQrm addr:$src)>;

  def : Pat<(int_x86_sse41_pmovzxbw (vzmovl_v2i64 addr:$src)),
            (PMOVZXBWrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovzxbw (vzload_v2i64 addr:$src)),
            (PMOVZXBWrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovzxbw (bc_v16i8 (loadv2i64 addr:$src))),
            (PMOVZXBWrm addr:$src)>;

  def : Pat<(int_x86_sse41_pmovzxwd (vzmovl_v2i64 addr:$src)),
            (PMOVZXWDrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovzxwd (vzload_v2i64 addr:$src)),
            (PMOVZXWDrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovzxwd (bc_v8i16 (loadv2i64 addr:$src))),
            (PMOVZXWDrm addr:$src)>;

  def : Pat<(int_x86_sse41_pmovzxdq (vzmovl_v2i64 addr:$src)),
            (PMOVZXDQrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovzxdq (vzload_v2i64 addr:$src)),
            (PMOVZXDQrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovzxdq (bc_v4i32 (loadv2i64 addr:$src))),
            (PMOVZXDQrm addr:$src)>;
}

let Predicates = [HasAVX2] in {
  let AddedComplexity = 15 in {
    def : Pat<(v4i64 (X86vzmovly (v4i32 VR128:$src))),
              (VPMOVZXDQYrr VR128:$src)>;
    def : Pat<(v8i32 (X86vzmovly (v8i16 VR128:$src))),
              (VPMOVZXWDYrr VR128:$src)>;
  }

  def : Pat<(v4i64 (X86vsmovl (v4i32 VR128:$src))), (VPMOVSXDQYrr VR128:$src)>;
  def : Pat<(v8i32 (X86vsmovl (v8i16 VR128:$src))), (VPMOVSXWDYrr VR128:$src)>;
}

let Predicates = [HasAVX] in {
  def : Pat<(v2i64 (X86vsmovl (v4i32 VR128:$src))), (VPMOVSXDQrr VR128:$src)>;
  def : Pat<(v4i32 (X86vsmovl (v8i16 VR128:$src))), (VPMOVSXWDrr VR128:$src)>;
}

let Predicates = [UseSSE41] in {
  def : Pat<(v2i64 (X86vsmovl (v4i32 VR128:$src))), (PMOVSXDQrr VR128:$src)>;
  def : Pat<(v4i32 (X86vsmovl (v8i16 VR128:$src))), (PMOVSXWDrr VR128:$src)>;
}


multiclass SS41I_binop_rm_int4<bits<8> opc, string OpcodeStr, Intrinsic IntId> {
  def rr : SS48I<opc, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                 !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                 [(set VR128:$dst, (IntId VR128:$src))]>, OpSize;

  def rm : SS48I<opc, MRMSrcMem, (outs VR128:$dst), (ins i32mem:$src),
                 !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
       [(set VR128:$dst,
         (IntId (bitconvert (v4i32 (scalar_to_vector (loadi32 addr:$src))))))]>,
          OpSize;
}

multiclass SS41I_binop_rm_int8_y<bits<8> opc, string OpcodeStr,
                                 Intrinsic IntId> {
  def Yrr : SS48I<opc, MRMSrcReg, (outs VR256:$dst), (ins VR128:$src),
                  !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                  [(set VR256:$dst, (IntId VR128:$src))]>, OpSize;

  def Yrm : SS48I<opc, MRMSrcMem, (outs VR256:$dst), (ins i32mem:$src),
                  !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
       [(set VR256:$dst,
         (IntId (bitconvert (v2i64 (scalar_to_vector (loadi64 addr:$src))))))]>,
          OpSize;
}

let Predicates = [HasAVX] in {
defm VPMOVSXBD : SS41I_binop_rm_int4<0x21, "vpmovsxbd", int_x86_sse41_pmovsxbd>,
                                     VEX;
defm VPMOVSXWQ : SS41I_binop_rm_int4<0x24, "vpmovsxwq", int_x86_sse41_pmovsxwq>,
                                     VEX;
defm VPMOVZXBD : SS41I_binop_rm_int4<0x31, "vpmovzxbd", int_x86_sse41_pmovzxbd>,
                                     VEX;
defm VPMOVZXWQ : SS41I_binop_rm_int4<0x34, "vpmovzxwq", int_x86_sse41_pmovzxwq>,
                                     VEX;
}

let Predicates = [HasAVX2] in {
defm VPMOVSXBD : SS41I_binop_rm_int8_y<0x21, "vpmovsxbd",
                                       int_x86_avx2_pmovsxbd>, VEX, VEX_L;
defm VPMOVSXWQ : SS41I_binop_rm_int8_y<0x24, "vpmovsxwq",
                                       int_x86_avx2_pmovsxwq>, VEX, VEX_L;
defm VPMOVZXBD : SS41I_binop_rm_int8_y<0x31, "vpmovzxbd",
                                       int_x86_avx2_pmovzxbd>, VEX, VEX_L;
defm VPMOVZXWQ : SS41I_binop_rm_int8_y<0x34, "vpmovzxwq",
                                       int_x86_avx2_pmovzxwq>, VEX, VEX_L;
}

defm PMOVSXBD   : SS41I_binop_rm_int4<0x21, "pmovsxbd", int_x86_sse41_pmovsxbd>;
defm PMOVSXWQ   : SS41I_binop_rm_int4<0x24, "pmovsxwq", int_x86_sse41_pmovsxwq>;
defm PMOVZXBD   : SS41I_binop_rm_int4<0x31, "pmovzxbd", int_x86_sse41_pmovzxbd>;
defm PMOVZXWQ   : SS41I_binop_rm_int4<0x34, "pmovzxwq", int_x86_sse41_pmovzxwq>;

let Predicates = [HasAVX] in {
  // Common patterns involving scalar load
  def : Pat<(int_x86_sse41_pmovsxbd (vzmovl_v4i32 addr:$src)),
            (VPMOVSXBDrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovsxwq (vzmovl_v4i32 addr:$src)),
            (VPMOVSXWQrm addr:$src)>;

  def : Pat<(int_x86_sse41_pmovzxbd (vzmovl_v4i32 addr:$src)),
            (VPMOVZXBDrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovzxwq (vzmovl_v4i32 addr:$src)),
            (VPMOVZXWQrm addr:$src)>;
}

let Predicates = [UseSSE41] in {
  // Common patterns involving scalar load
  def : Pat<(int_x86_sse41_pmovsxbd (vzmovl_v4i32 addr:$src)),
            (PMOVSXBDrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovsxwq (vzmovl_v4i32 addr:$src)),
            (PMOVSXWQrm addr:$src)>;

  def : Pat<(int_x86_sse41_pmovzxbd (vzmovl_v4i32 addr:$src)),
            (PMOVZXBDrm addr:$src)>;
  def : Pat<(int_x86_sse41_pmovzxwq (vzmovl_v4i32 addr:$src)),
            (PMOVZXWQrm addr:$src)>;
}

multiclass SS41I_binop_rm_int2<bits<8> opc, string OpcodeStr, Intrinsic IntId> {
  def rr : SS48I<opc, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                 !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                 [(set VR128:$dst, (IntId VR128:$src))]>, OpSize;

  // Expecting a i16 load any extended to i32 value.
  def rm : SS48I<opc, MRMSrcMem, (outs VR128:$dst), (ins i16mem:$src),
                 !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                 [(set VR128:$dst, (IntId (bitconvert
                     (v4i32 (scalar_to_vector (loadi16_anyext addr:$src))))))]>,
                 OpSize;
}

multiclass SS41I_binop_rm_int4_y<bits<8> opc, string OpcodeStr,
                                 Intrinsic IntId> {
  def Yrr : SS48I<opc, MRMSrcReg, (outs VR256:$dst), (ins VR128:$src),
                 !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                 [(set VR256:$dst, (IntId VR128:$src))]>, OpSize;

  // Expecting a i16 load any extended to i32 value.
  def Yrm : SS48I<opc, MRMSrcMem, (outs VR256:$dst), (ins i16mem:$src),
                  !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                  [(set VR256:$dst, (IntId (bitconvert
                      (v4i32 (scalar_to_vector (loadi32 addr:$src))))))]>,
                  OpSize;
}

let Predicates = [HasAVX] in {
defm VPMOVSXBQ : SS41I_binop_rm_int2<0x22, "vpmovsxbq", int_x86_sse41_pmovsxbq>,
                                     VEX;
defm VPMOVZXBQ : SS41I_binop_rm_int2<0x32, "vpmovzxbq", int_x86_sse41_pmovzxbq>,
                                     VEX;
}
let Predicates = [HasAVX2] in {
defm VPMOVSXBQ : SS41I_binop_rm_int4_y<0x22, "vpmovsxbq",
                                       int_x86_avx2_pmovsxbq>, VEX, VEX_L;
defm VPMOVZXBQ : SS41I_binop_rm_int4_y<0x32, "vpmovzxbq",
                                       int_x86_avx2_pmovzxbq>, VEX, VEX_L;
}
defm PMOVSXBQ   : SS41I_binop_rm_int2<0x22, "pmovsxbq", int_x86_sse41_pmovsxbq>;
defm PMOVZXBQ   : SS41I_binop_rm_int2<0x32, "pmovzxbq", int_x86_sse41_pmovzxbq>;

let Predicates = [HasAVX2] in {
  def : Pat<(v16i16 (X86vsext (v16i8 VR128:$src))), (VPMOVSXBWYrr VR128:$src)>;
  def : Pat<(v8i32  (X86vsext (v16i8 VR128:$src))), (VPMOVSXBDYrr VR128:$src)>;
  def : Pat<(v4i64  (X86vsext (v16i8 VR128:$src))), (VPMOVSXBQYrr VR128:$src)>;

  def : Pat<(v8i32  (X86vsext (v8i16 VR128:$src))), (VPMOVSXWDYrr VR128:$src)>;
  def : Pat<(v4i64  (X86vsext (v8i16 VR128:$src))), (VPMOVSXWQYrr VR128:$src)>;

  def : Pat<(v4i64  (X86vsext (v4i32 VR128:$src))), (VPMOVSXDQYrr VR128:$src)>;

  def : Pat<(v16i16 (X86vsext (v32i8 VR256:$src))),
            (VPMOVSXBWYrr (EXTRACT_SUBREG VR256:$src, sub_xmm))>;
  def : Pat<(v8i32 (X86vsext (v32i8 VR256:$src))),
            (VPMOVSXBDYrr (EXTRACT_SUBREG VR256:$src, sub_xmm))>;
  def : Pat<(v4i64 (X86vsext (v32i8 VR256:$src))),
            (VPMOVSXBQYrr (EXTRACT_SUBREG VR256:$src, sub_xmm))>;

  def : Pat<(v8i32 (X86vsext (v16i16 VR256:$src))),
            (VPMOVSXWDYrr (EXTRACT_SUBREG VR256:$src, sub_xmm))>;
  def : Pat<(v4i64 (X86vsext (v16i16 VR256:$src))),
            (VPMOVSXWQYrr (EXTRACT_SUBREG VR256:$src, sub_xmm))>;

  def : Pat<(v4i64 (X86vsext (v8i32 VR256:$src))),
            (VPMOVSXDQYrr (EXTRACT_SUBREG VR256:$src, sub_xmm))>;

  def : Pat<(v8i32 (X86vsmovl (v8i16 (bitconvert (v2i64 (load addr:$src)))))),
            (VPMOVSXWDYrm addr:$src)>;
  def : Pat<(v4i64 (X86vsmovl (v4i32 (bitconvert (v2i64 (load addr:$src)))))),
            (VPMOVSXDQYrm addr:$src)>;

  def : Pat<(v8i32 (X86vsext (v16i8 (bitconvert (v2i64 
                    (scalar_to_vector (loadi64 addr:$src))))))),
            (VPMOVSXBDYrm addr:$src)>;
  def : Pat<(v8i32 (X86vsext (v16i8 (bitconvert (v2f64 
                    (scalar_to_vector (loadf64 addr:$src))))))),
            (VPMOVSXBDYrm addr:$src)>;

  def : Pat<(v4i64 (X86vsext (v8i16 (bitconvert (v2i64 
                    (scalar_to_vector (loadi64 addr:$src))))))),
            (VPMOVSXWQYrm addr:$src)>;
  def : Pat<(v4i64 (X86vsext (v8i16 (bitconvert (v2f64 
                    (scalar_to_vector (loadf64 addr:$src))))))),
            (VPMOVSXWQYrm addr:$src)>;

  def : Pat<(v4i64 (X86vsext (v16i8 (bitconvert (v4i32 
                    (scalar_to_vector (loadi32 addr:$src))))))),
            (VPMOVSXBQYrm addr:$src)>;
}

let Predicates = [HasAVX] in {
  // Common patterns involving scalar load
  def : Pat<(int_x86_sse41_pmovsxbq
              (bitconvert (v4i32 (X86vzmovl
                            (v4i32 (scalar_to_vector (loadi32 addr:$src))))))),
            (VPMOVSXBQrm addr:$src)>;

  def : Pat<(int_x86_sse41_pmovzxbq
              (bitconvert (v4i32 (X86vzmovl
                            (v4i32 (scalar_to_vector (loadi32 addr:$src))))))),
            (VPMOVZXBQrm addr:$src)>;
}

let Predicates = [UseSSE41] in {
  def : Pat<(v8i16 (X86vsext (v16i8 VR128:$src))), (PMOVSXBWrr VR128:$src)>;
  def : Pat<(v4i32 (X86vsext (v16i8 VR128:$src))), (PMOVSXBDrr VR128:$src)>;
  def : Pat<(v2i64 (X86vsext (v16i8 VR128:$src))), (PMOVSXBQrr VR128:$src)>;

  def : Pat<(v4i32 (X86vsext (v8i16 VR128:$src))), (PMOVSXWDrr VR128:$src)>;
  def : Pat<(v2i64 (X86vsext (v8i16 VR128:$src))), (PMOVSXWQrr VR128:$src)>;

  def : Pat<(v2i64 (X86vsext (v4i32 VR128:$src))), (PMOVSXDQrr VR128:$src)>;

  // Common patterns involving scalar load
  def : Pat<(int_x86_sse41_pmovsxbq
              (bitconvert (v4i32 (X86vzmovl
                            (v4i32 (scalar_to_vector (loadi32 addr:$src))))))),
            (PMOVSXBQrm addr:$src)>;

  def : Pat<(int_x86_sse41_pmovzxbq
              (bitconvert (v4i32 (X86vzmovl
                            (v4i32 (scalar_to_vector (loadi32 addr:$src))))))),
            (PMOVZXBQrm addr:$src)>;

  def : Pat<(v4i32 (X86vsext (v8i16 (bitconvert (v2i64
                    (scalar_to_vector (loadi64 addr:$src))))))),
            (PMOVSXWDrm addr:$src)>;
  def : Pat<(v4i32 (X86vsext (v8i16 (bitconvert (v2f64
                    (scalar_to_vector (loadf64 addr:$src))))))),
            (PMOVSXWDrm addr:$src)>;
  def : Pat<(v4i32 (X86vsext (v16i8 (bitconvert (v4i32
                    (scalar_to_vector (loadi32 addr:$src))))))),
            (PMOVSXBDrm addr:$src)>;
  def : Pat<(v2i64 (X86vsext (v8i16 (bitconvert (v4i32
                    (scalar_to_vector (loadi32 addr:$src))))))),
            (PMOVSXWQrm addr:$src)>;
  def : Pat<(v2i64 (X86vsext (v16i8 (bitconvert (v4i32
                    (scalar_to_vector (extloadi32i16 addr:$src))))))),
            (PMOVSXBQrm addr:$src)>;
  def : Pat<(v2i64 (X86vsext (v4i32 (bitconvert (v2i64
                    (scalar_to_vector (loadi64 addr:$src))))))),
            (PMOVSXDQrm addr:$src)>;
  def : Pat<(v2i64 (X86vsext (v4i32 (bitconvert (v2f64
                    (scalar_to_vector (loadf64 addr:$src))))))),
            (PMOVSXDQrm addr:$src)>;
  def : Pat<(v8i16 (X86vsext (v16i8 (bitconvert (v2i64
                    (scalar_to_vector (loadi64 addr:$src))))))),
            (PMOVSXBWrm addr:$src)>;
  def : Pat<(v8i16 (X86vsext (v16i8 (bitconvert (v2f64
                    (scalar_to_vector (loadf64 addr:$src))))))),
            (PMOVSXBWrm addr:$src)>;
}

let Predicates = [HasAVX2] in {
  def : Pat<(v16i16 (X86vzext (v16i8 VR128:$src))), (VPMOVZXBWYrr VR128:$src)>;
  def : Pat<(v8i32  (X86vzext (v16i8 VR128:$src))), (VPMOVZXBDYrr VR128:$src)>;
  def : Pat<(v4i64  (X86vzext (v16i8 VR128:$src))), (VPMOVZXBQYrr VR128:$src)>;

  def : Pat<(v8i32  (X86vzext (v8i16 VR128:$src))), (VPMOVZXWDYrr VR128:$src)>;
  def : Pat<(v4i64  (X86vzext (v8i16 VR128:$src))), (VPMOVZXWQYrr VR128:$src)>;

  def : Pat<(v4i64  (X86vzext (v4i32 VR128:$src))), (VPMOVZXDQYrr VR128:$src)>;

  def : Pat<(v16i16 (X86vzext (v32i8 VR256:$src))),
            (VPMOVZXBWYrr (EXTRACT_SUBREG VR256:$src, sub_xmm))>;
  def : Pat<(v8i32 (X86vzext (v32i8 VR256:$src))),
            (VPMOVZXBDYrr (EXTRACT_SUBREG VR256:$src, sub_xmm))>;
  def : Pat<(v4i64 (X86vzext (v32i8 VR256:$src))),
            (VPMOVZXBQYrr (EXTRACT_SUBREG VR256:$src, sub_xmm))>;

  def : Pat<(v8i32 (X86vzext (v16i16 VR256:$src))),
            (VPMOVZXWDYrr (EXTRACT_SUBREG VR256:$src, sub_xmm))>;
  def : Pat<(v4i64 (X86vzext (v16i16 VR256:$src))),
            (VPMOVZXWQYrr (EXTRACT_SUBREG VR256:$src, sub_xmm))>;

  def : Pat<(v4i64 (X86vzext (v8i32 VR256:$src))),
            (VPMOVZXDQYrr (EXTRACT_SUBREG VR256:$src, sub_xmm))>;
}

let Predicates = [HasAVX] in {
  def : Pat<(v8i16 (X86vzext (v16i8 VR128:$src))), (VPMOVZXBWrr VR128:$src)>;
  def : Pat<(v4i32 (X86vzext (v16i8 VR128:$src))), (VPMOVZXBDrr VR128:$src)>;
  def : Pat<(v2i64 (X86vzext (v16i8 VR128:$src))), (VPMOVZXBQrr VR128:$src)>;

  def : Pat<(v4i32 (X86vzext (v8i16 VR128:$src))), (VPMOVZXWDrr VR128:$src)>;
  def : Pat<(v2i64 (X86vzext (v8i16 VR128:$src))), (VPMOVZXWQrr VR128:$src)>;

  def : Pat<(v2i64 (X86vzext (v4i32 VR128:$src))), (VPMOVZXDQrr VR128:$src)>;

  def : Pat<(v8i16 (X86vzext (v16i8 (bitconvert (v2i64 (scalar_to_vector (loadi64 addr:$src))))))),
            (VPMOVZXBWrm addr:$src)>;
  def : Pat<(v8i16 (X86vzext (v16i8 (bitconvert (v2f64 (scalar_to_vector (loadf64 addr:$src))))))),
            (VPMOVZXBWrm addr:$src)>;
  def : Pat<(v4i32 (X86vzext (v16i8 (bitconvert (v4i32 (scalar_to_vector (loadi32 addr:$src))))))),
            (VPMOVZXBDrm addr:$src)>;
  def : Pat<(v2i64 (X86vzext (v16i8 (bitconvert (v4i32 (scalar_to_vector (loadi16_anyext addr:$src))))))),
            (VPMOVZXBQrm addr:$src)>;

  def : Pat<(v4i32 (X86vzext (v8i16 (bitconvert (v2i64 (scalar_to_vector (loadi64 addr:$src))))))),
            (VPMOVZXWDrm addr:$src)>;
  def : Pat<(v4i32 (X86vzext (v8i16 (bitconvert (v2f64 (scalar_to_vector (loadf64 addr:$src))))))),
            (VPMOVZXWDrm addr:$src)>;
  def : Pat<(v2i64 (X86vzext (v8i16 (bitconvert (v4i32 (scalar_to_vector (loadi32 addr:$src))))))),
            (VPMOVZXWQrm addr:$src)>;

  def : Pat<(v2i64 (X86vzext (v4i32 (bitconvert (v2i64 (scalar_to_vector (loadi64 addr:$src))))))),
            (VPMOVZXDQrm addr:$src)>;
  def : Pat<(v2i64 (X86vzext (v4i32 (bitconvert (v2f64 (scalar_to_vector (loadf64 addr:$src))))))),
            (VPMOVZXDQrm addr:$src)>;
  def : Pat<(v2i64 (X86vzext (v4i32 (bitconvert (v2i64 (X86vzload addr:$src)))))),
            (VPMOVZXDQrm addr:$src)>;

  def : Pat<(v8i16 (X86vsext (v16i8 VR128:$src))), (VPMOVSXBWrr VR128:$src)>;
  def : Pat<(v4i32 (X86vsext (v16i8 VR128:$src))), (VPMOVSXBDrr VR128:$src)>;
  def : Pat<(v2i64 (X86vsext (v16i8 VR128:$src))), (VPMOVSXBQrr VR128:$src)>;

  def : Pat<(v4i32 (X86vsext (v8i16 VR128:$src))), (VPMOVSXWDrr VR128:$src)>;
  def : Pat<(v2i64 (X86vsext (v8i16 VR128:$src))), (VPMOVSXWQrr VR128:$src)>;

  def : Pat<(v2i64 (X86vsext (v4i32 VR128:$src))), (VPMOVSXDQrr VR128:$src)>;

  def : Pat<(v4i32 (X86vsext (v8i16 (bitconvert (v2i64
                    (scalar_to_vector (loadi64 addr:$src))))))),
            (VPMOVSXWDrm addr:$src)>;
  def : Pat<(v2i64 (X86vsext (v4i32 (bitconvert (v2i64
                    (scalar_to_vector (loadi64 addr:$src))))))),
            (VPMOVSXDQrm addr:$src)>;
  def : Pat<(v4i32 (X86vsext (v8i16 (bitconvert (v2f64
                    (scalar_to_vector (loadf64 addr:$src))))))),
            (VPMOVSXWDrm addr:$src)>;
  def : Pat<(v2i64 (X86vsext (v4i32 (bitconvert (v2f64
                    (scalar_to_vector (loadf64 addr:$src))))))),
            (VPMOVSXDQrm addr:$src)>;
  def : Pat<(v8i16 (X86vsext (v16i8 (bitconvert (v2i64
                    (scalar_to_vector (loadi64 addr:$src))))))),
            (VPMOVSXBWrm addr:$src)>;
  def : Pat<(v8i16 (X86vsext (v16i8 (bitconvert (v2f64
                    (scalar_to_vector (loadf64 addr:$src))))))),
            (VPMOVSXBWrm addr:$src)>;

  def : Pat<(v4i32 (X86vsext (v16i8 (bitconvert (v4i32
                    (scalar_to_vector (loadi32 addr:$src))))))),
            (VPMOVSXBDrm addr:$src)>;
  def : Pat<(v2i64 (X86vsext (v8i16 (bitconvert (v4i32
                    (scalar_to_vector (loadi32 addr:$src))))))),
            (VPMOVSXWQrm addr:$src)>;
  def : Pat<(v2i64 (X86vsext (v16i8 (bitconvert (v4i32
                    (scalar_to_vector (extloadi32i16 addr:$src))))))),
            (VPMOVSXBQrm addr:$src)>;
}

let Predicates = [UseSSE41] in {
  def : Pat<(v8i16 (X86vzext (v16i8 VR128:$src))), (PMOVZXBWrr VR128:$src)>;
  def : Pat<(v4i32 (X86vzext (v16i8 VR128:$src))), (PMOVZXBDrr VR128:$src)>;
  def : Pat<(v2i64 (X86vzext (v16i8 VR128:$src))), (PMOVZXBQrr VR128:$src)>;

  def : Pat<(v4i32 (X86vzext (v8i16 VR128:$src))), (PMOVZXWDrr VR128:$src)>;
  def : Pat<(v2i64 (X86vzext (v8i16 VR128:$src))), (PMOVZXWQrr VR128:$src)>;

  def : Pat<(v2i64 (X86vzext (v4i32 VR128:$src))), (PMOVZXDQrr VR128:$src)>;

  def : Pat<(v8i16 (X86vzext (v16i8 (bitconvert (v2i64 (scalar_to_vector (loadi64 addr:$src))))))),
            (PMOVZXBWrm addr:$src)>;
  def : Pat<(v8i16 (X86vzext (v16i8 (bitconvert (v2f64 (scalar_to_vector (loadf64 addr:$src))))))),
            (PMOVZXBWrm addr:$src)>;
  def : Pat<(v4i32 (X86vzext (v16i8 (bitconvert (v4i32 (scalar_to_vector (loadi32 addr:$src))))))),
            (PMOVZXBDrm addr:$src)>;
  def : Pat<(v2i64 (X86vzext (v16i8 (bitconvert (v4i32 (scalar_to_vector (loadi16_anyext addr:$src))))))),
            (PMOVZXBQrm addr:$src)>;

  def : Pat<(v4i32 (X86vzext (v8i16 (bitconvert (v2i64 (scalar_to_vector (loadi64 addr:$src))))))),
            (PMOVZXWDrm addr:$src)>;
  def : Pat<(v4i32 (X86vzext (v8i16 (bitconvert (v2f64 (scalar_to_vector (loadf64 addr:$src))))))),
            (PMOVZXWDrm addr:$src)>;
  def : Pat<(v2i64 (X86vzext (v8i16 (bitconvert (v4i32 (scalar_to_vector (loadi32 addr:$src))))))),
            (PMOVZXWQrm addr:$src)>;

  def : Pat<(v2i64 (X86vzext (v4i32 (bitconvert (v2i64 (scalar_to_vector (loadi64 addr:$src))))))),
            (PMOVZXDQrm addr:$src)>;
  def : Pat<(v2i64 (X86vzext (v4i32 (bitconvert (v2f64 (scalar_to_vector (loadf64 addr:$src))))))),
            (PMOVZXDQrm addr:$src)>;
  def : Pat<(v2i64 (X86vzext (v4i32 (bitconvert (v2i64 (X86vzload addr:$src)))))),
            (PMOVZXDQrm addr:$src)>;
}

//===----------------------------------------------------------------------===//
// SSE4.1 - Extract Instructions
//===----------------------------------------------------------------------===//

/// SS41I_binop_ext8 - SSE 4.1 extract 8 bits to 32 bit reg or 8 bit mem
multiclass SS41I_extract8<bits<8> opc, string OpcodeStr> {
  def rr : SS4AIi8<opc, MRMDestReg, (outs GR32:$dst),
                 (ins VR128:$src1, i32i8imm:$src2),
                 !strconcat(OpcodeStr,
                  "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                 [(set GR32:$dst, (X86pextrb (v16i8 VR128:$src1), imm:$src2))]>,
                 OpSize;
  let neverHasSideEffects = 1, mayStore = 1 in
  def mr : SS4AIi8<opc, MRMDestMem, (outs),
                 (ins i8mem:$dst, VR128:$src1, i32i8imm:$src2),
                 !strconcat(OpcodeStr,
                  "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                 []>, OpSize;
// FIXME:
// There's an AssertZext in the way of writing the store pattern
// (store (i8 (trunc (X86pextrb (v16i8 VR128:$src1), imm:$src2))), addr:$dst)
}

let Predicates = [HasAVX] in {
  defm VPEXTRB : SS41I_extract8<0x14, "vpextrb">, VEX;
  def  VPEXTRBrr64 : SS4AIi8<0x14, MRMDestReg, (outs GR64:$dst),
         (ins VR128:$src1, i32i8imm:$src2),
         "vpextrb\t{$src2, $src1, $dst|$dst, $src1, $src2}", []>, OpSize, VEX;
}

defm PEXTRB      : SS41I_extract8<0x14, "pextrb">;


/// SS41I_extract16 - SSE 4.1 extract 16 bits to memory destination
multiclass SS41I_extract16<bits<8> opc, string OpcodeStr> {
  let neverHasSideEffects = 1, mayStore = 1 in
  def mr : SS4AIi8<opc, MRMDestMem, (outs),
                 (ins i16mem:$dst, VR128:$src1, i32i8imm:$src2),
                 !strconcat(OpcodeStr,
                  "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                 []>, OpSize;
// FIXME:
// There's an AssertZext in the way of writing the store pattern
// (store (i16 (trunc (X86pextrw (v16i8 VR128:$src1), imm:$src2))), addr:$dst)
}

let Predicates = [HasAVX] in
  defm VPEXTRW : SS41I_extract16<0x15, "vpextrw">, VEX;

defm PEXTRW      : SS41I_extract16<0x15, "pextrw">;


/// SS41I_extract32 - SSE 4.1 extract 32 bits to int reg or memory destination
multiclass SS41I_extract32<bits<8> opc, string OpcodeStr> {
  def rr : SS4AIi8<opc, MRMDestReg, (outs GR32:$dst),
                 (ins VR128:$src1, i32i8imm:$src2),
                 !strconcat(OpcodeStr,
                  "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                 [(set GR32:$dst,
                  (extractelt (v4i32 VR128:$src1), imm:$src2))]>, OpSize;
  def mr : SS4AIi8<opc, MRMDestMem, (outs),
                 (ins i32mem:$dst, VR128:$src1, i32i8imm:$src2),
                 !strconcat(OpcodeStr,
                  "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                 [(store (extractelt (v4i32 VR128:$src1), imm:$src2),
                          addr:$dst)]>, OpSize;
}

let Predicates = [HasAVX] in
  defm VPEXTRD : SS41I_extract32<0x16, "vpextrd">, VEX;

defm PEXTRD      : SS41I_extract32<0x16, "pextrd">;

/// SS41I_extract32 - SSE 4.1 extract 32 bits to int reg or memory destination
multiclass SS41I_extract64<bits<8> opc, string OpcodeStr> {
  def rr : SS4AIi8<opc, MRMDestReg, (outs GR64:$dst),
                 (ins VR128:$src1, i32i8imm:$src2),
                 !strconcat(OpcodeStr,
                  "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                 [(set GR64:$dst,
                  (extractelt (v2i64 VR128:$src1), imm:$src2))]>, OpSize, REX_W;
  def mr : SS4AIi8<opc, MRMDestMem, (outs),
                 (ins i64mem:$dst, VR128:$src1, i32i8imm:$src2),
                 !strconcat(OpcodeStr,
                  "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                 [(store (extractelt (v2i64 VR128:$src1), imm:$src2),
                          addr:$dst)]>, OpSize, REX_W;
}

let Predicates = [HasAVX] in
  defm VPEXTRQ : SS41I_extract64<0x16, "vpextrq">, VEX, VEX_W;

defm PEXTRQ      : SS41I_extract64<0x16, "pextrq">;

/// SS41I_extractf32 - SSE 4.1 extract 32 bits fp value to int reg or memory
/// destination
multiclass SS41I_extractf32<bits<8> opc, string OpcodeStr> {
  def rr : SS4AIi8<opc, MRMDestReg, (outs GR32:$dst),
                 (ins VR128:$src1, i32i8imm:$src2),
                 !strconcat(OpcodeStr,
                  "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                 [(set GR32:$dst,
                    (extractelt (bc_v4i32 (v4f32 VR128:$src1)), imm:$src2))]>,
           OpSize;
  def mr : SS4AIi8<opc, MRMDestMem, (outs),
                 (ins f32mem:$dst, VR128:$src1, i32i8imm:$src2),
                 !strconcat(OpcodeStr,
                  "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                 [(store (extractelt (bc_v4i32 (v4f32 VR128:$src1)), imm:$src2),
                          addr:$dst)]>, OpSize;
}

let ExeDomain = SSEPackedSingle in {
  let Predicates = [HasAVX] in {
    defm VEXTRACTPS : SS41I_extractf32<0x17, "vextractps">, VEX;
    def VEXTRACTPSrr64 : SS4AIi8<0x17, MRMDestReg, (outs GR64:$dst),
                    (ins VR128:$src1, i32i8imm:$src2),
                    "vextractps \t{$src2, $src1, $dst|$dst, $src1, $src2}",
                    []>, OpSize, VEX;
  }
  defm EXTRACTPS   : SS41I_extractf32<0x17, "extractps">;
}

// Also match an EXTRACTPS store when the store is done as f32 instead of i32.
def : Pat<(store (f32 (bitconvert (extractelt (bc_v4i32 (v4f32 VR128:$src1)),
                                              imm:$src2))),
                 addr:$dst),
          (VEXTRACTPSmr addr:$dst, VR128:$src1, imm:$src2)>,
          Requires<[HasAVX]>;
def : Pat<(store (f32 (bitconvert (extractelt (bc_v4i32 (v4f32 VR128:$src1)),
                                              imm:$src2))),
                 addr:$dst),
          (EXTRACTPSmr addr:$dst, VR128:$src1, imm:$src2)>,
          Requires<[UseSSE41]>;

//===----------------------------------------------------------------------===//
// SSE4.1 - Insert Instructions
//===----------------------------------------------------------------------===//

multiclass SS41I_insert8<bits<8> opc, string asm, bit Is2Addr = 1> {
  def rr : SS4AIi8<opc, MRMSrcReg, (outs VR128:$dst),
      (ins VR128:$src1, GR32:$src2, i32i8imm:$src3),
      !if(Is2Addr,
        !strconcat(asm, "\t{$src3, $src2, $dst|$dst, $src2, $src3}"),
        !strconcat(asm,
                   "\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}")),
      [(set VR128:$dst,
        (X86pinsrb VR128:$src1, GR32:$src2, imm:$src3))]>, OpSize;
  def rm : SS4AIi8<opc, MRMSrcMem, (outs VR128:$dst),
      (ins VR128:$src1, i8mem:$src2, i32i8imm:$src3),
      !if(Is2Addr,
        !strconcat(asm, "\t{$src3, $src2, $dst|$dst, $src2, $src3}"),
        !strconcat(asm,
                   "\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}")),
      [(set VR128:$dst,
        (X86pinsrb VR128:$src1, (extloadi8 addr:$src2),
                   imm:$src3))]>, OpSize;
}

let Predicates = [HasAVX] in
  defm VPINSRB : SS41I_insert8<0x20, "vpinsrb", 0>, VEX_4V;
let Constraints = "$src1 = $dst" in
  defm PINSRB  : SS41I_insert8<0x20, "pinsrb">;

multiclass SS41I_insert32<bits<8> opc, string asm, bit Is2Addr = 1> {
  def rr : SS4AIi8<opc, MRMSrcReg, (outs VR128:$dst),
      (ins VR128:$src1, GR32:$src2, i32i8imm:$src3),
      !if(Is2Addr,
        !strconcat(asm, "\t{$src3, $src2, $dst|$dst, $src2, $src3}"),
        !strconcat(asm,
                   "\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}")),
      [(set VR128:$dst,
        (v4i32 (insertelt VR128:$src1, GR32:$src2, imm:$src3)))]>,
      OpSize;
  def rm : SS4AIi8<opc, MRMSrcMem, (outs VR128:$dst),
      (ins VR128:$src1, i32mem:$src2, i32i8imm:$src3),
      !if(Is2Addr,
        !strconcat(asm, "\t{$src3, $src2, $dst|$dst, $src2, $src3}"),
        !strconcat(asm,
                   "\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}")),
      [(set VR128:$dst,
        (v4i32 (insertelt VR128:$src1, (loadi32 addr:$src2),
                          imm:$src3)))]>, OpSize;
}

let Predicates = [HasAVX] in
  defm VPINSRD : SS41I_insert32<0x22, "vpinsrd", 0>, VEX_4V;
let Constraints = "$src1 = $dst" in
  defm PINSRD : SS41I_insert32<0x22, "pinsrd">;

multiclass SS41I_insert64<bits<8> opc, string asm, bit Is2Addr = 1> {
  def rr : SS4AIi8<opc, MRMSrcReg, (outs VR128:$dst),
      (ins VR128:$src1, GR64:$src2, i32i8imm:$src3),
      !if(Is2Addr,
        !strconcat(asm, "\t{$src3, $src2, $dst|$dst, $src2, $src3}"),
        !strconcat(asm,
                   "\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}")),
      [(set VR128:$dst,
        (v2i64 (insertelt VR128:$src1, GR64:$src2, imm:$src3)))]>,
      OpSize;
  def rm : SS4AIi8<opc, MRMSrcMem, (outs VR128:$dst),
      (ins VR128:$src1, i64mem:$src2, i32i8imm:$src3),
      !if(Is2Addr,
        !strconcat(asm, "\t{$src3, $src2, $dst|$dst, $src2, $src3}"),
        !strconcat(asm,
                   "\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}")),
      [(set VR128:$dst,
        (v2i64 (insertelt VR128:$src1, (loadi64 addr:$src2),
                          imm:$src3)))]>, OpSize;
}

let Predicates = [HasAVX] in
  defm VPINSRQ : SS41I_insert64<0x22, "vpinsrq", 0>, VEX_4V, VEX_W;
let Constraints = "$src1 = $dst" in
  defm PINSRQ : SS41I_insert64<0x22, "pinsrq">, REX_W;

// insertps has a few different modes, there's the first two here below which
// are optimized inserts that won't zero arbitrary elements in the destination
// vector. The next one matches the intrinsic and could zero arbitrary elements
// in the target vector.
multiclass SS41I_insertf32<bits<8> opc, string asm, bit Is2Addr = 1> {
  def rr : SS4AIi8<opc, MRMSrcReg, (outs VR128:$dst),
      (ins VR128:$src1, VR128:$src2, u32u8imm:$src3),
      !if(Is2Addr,
        !strconcat(asm, "\t{$src3, $src2, $dst|$dst, $src2, $src3}"),
        !strconcat(asm,
                   "\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}")),
      [(set VR128:$dst,
        (X86insrtps VR128:$src1, VR128:$src2, imm:$src3))]>,
      OpSize;
  def rm : SS4AIi8<opc, MRMSrcMem, (outs VR128:$dst),
      (ins VR128:$src1, f32mem:$src2, u32u8imm:$src3),
      !if(Is2Addr,
        !strconcat(asm, "\t{$src3, $src2, $dst|$dst, $src2, $src3}"),
        !strconcat(asm,
                   "\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}")),
      [(set VR128:$dst,
        (X86insrtps VR128:$src1,
                   (v4f32 (scalar_to_vector (loadf32 addr:$src2))),
                    imm:$src3))]>, OpSize;
}

let ExeDomain = SSEPackedSingle in {
  let Predicates = [HasAVX] in
    defm VINSERTPS : SS41I_insertf32<0x21, "vinsertps", 0>, VEX_4V;
  let Constraints = "$src1 = $dst" in
    defm INSERTPS : SS41I_insertf32<0x21, "insertps">;
}

//===----------------------------------------------------------------------===//
// SSE4.1 - Round Instructions
//===----------------------------------------------------------------------===//

multiclass sse41_fp_unop_rm<bits<8> opcps, bits<8> opcpd, string OpcodeStr,
                            X86MemOperand x86memop, RegisterClass RC,
                            PatFrag mem_frag32, PatFrag mem_frag64,
                            Intrinsic V4F32Int, Intrinsic V2F64Int> {
let ExeDomain = SSEPackedSingle in {
  // Intrinsic operation, reg.
  // Vector intrinsic operation, reg
  def PSr : SS4AIi8<opcps, MRMSrcReg,
                    (outs RC:$dst), (ins RC:$src1, i32i8imm:$src2),
                    !strconcat(OpcodeStr,
                    "ps\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                    [(set RC:$dst, (V4F32Int RC:$src1, imm:$src2))]>,
                    OpSize;

  // Vector intrinsic operation, mem
  def PSm : SS4AIi8<opcps, MRMSrcMem,
                    (outs RC:$dst), (ins x86memop:$src1, i32i8imm:$src2),
                    !strconcat(OpcodeStr,
                    "ps\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                    [(set RC:$dst,
                          (V4F32Int (mem_frag32 addr:$src1),imm:$src2))]>,
                    OpSize;
} // ExeDomain = SSEPackedSingle

let ExeDomain = SSEPackedDouble in {
  // Vector intrinsic operation, reg
  def PDr : SS4AIi8<opcpd, MRMSrcReg,
                    (outs RC:$dst), (ins RC:$src1, i32i8imm:$src2),
                    !strconcat(OpcodeStr,
                    "pd\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                    [(set RC:$dst, (V2F64Int RC:$src1, imm:$src2))]>,
                    OpSize;

  // Vector intrinsic operation, mem
  def PDm : SS4AIi8<opcpd, MRMSrcMem,
                    (outs RC:$dst), (ins x86memop:$src1, i32i8imm:$src2),
                    !strconcat(OpcodeStr,
                    "pd\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                    [(set RC:$dst,
                          (V2F64Int (mem_frag64 addr:$src1),imm:$src2))]>,
                    OpSize;
} // ExeDomain = SSEPackedDouble
}

multiclass sse41_fp_binop_rm<bits<8> opcss, bits<8> opcsd,
                            string OpcodeStr,
                            Intrinsic F32Int,
                            Intrinsic F64Int, bit Is2Addr = 1> {
let ExeDomain = GenericDomain in {
  // Operation, reg.
  let hasSideEffects = 0 in
  def SSr : SS4AIi8<opcss, MRMSrcReg,
      (outs FR32:$dst), (ins FR32:$src1, FR32:$src2, i32i8imm:$src3),
      !if(Is2Addr,
          !strconcat(OpcodeStr,
              "ss\t{$src3, $src2, $dst|$dst, $src2, $src3}"),
          !strconcat(OpcodeStr,
              "ss\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}")),
      []>, OpSize;

  // Intrinsic operation, reg.
  def SSr_Int : SS4AIi8<opcss, MRMSrcReg,
        (outs VR128:$dst), (ins VR128:$src1, VR128:$src2, i32i8imm:$src3),
        !if(Is2Addr,
            !strconcat(OpcodeStr,
                "ss\t{$src3, $src2, $dst|$dst, $src2, $src3}"),
            !strconcat(OpcodeStr,
                "ss\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}")),
        [(set VR128:$dst, (F32Int VR128:$src1, VR128:$src2, imm:$src3))]>,
        OpSize;

  // Intrinsic operation, mem.
  def SSm : SS4AIi8<opcss, MRMSrcMem,
        (outs VR128:$dst), (ins VR128:$src1, ssmem:$src2, i32i8imm:$src3),
        !if(Is2Addr,
            !strconcat(OpcodeStr,
                "ss\t{$src3, $src2, $dst|$dst, $src2, $src3}"),
            !strconcat(OpcodeStr,
                "ss\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}")),
        [(set VR128:$dst,
             (F32Int VR128:$src1, sse_load_f32:$src2, imm:$src3))]>,
        OpSize;

  // Operation, reg.
  let hasSideEffects = 0 in
  def SDr : SS4AIi8<opcsd, MRMSrcReg,
        (outs FR64:$dst), (ins FR64:$src1, FR64:$src2, i32i8imm:$src3),
        !if(Is2Addr,
            !strconcat(OpcodeStr,
                "sd\t{$src3, $src2, $dst|$dst, $src2, $src3}"),
            !strconcat(OpcodeStr,
                "sd\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}")),
        []>, OpSize;

  // Intrinsic operation, reg.
  def SDr_Int : SS4AIi8<opcsd, MRMSrcReg,
        (outs VR128:$dst), (ins VR128:$src1, VR128:$src2, i32i8imm:$src3),
        !if(Is2Addr,
            !strconcat(OpcodeStr,
                "sd\t{$src3, $src2, $dst|$dst, $src2, $src3}"),
            !strconcat(OpcodeStr,
                "sd\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}")),
        [(set VR128:$dst, (F64Int VR128:$src1, VR128:$src2, imm:$src3))]>,
        OpSize;

  // Intrinsic operation, mem.
  def SDm : SS4AIi8<opcsd, MRMSrcMem,
        (outs VR128:$dst), (ins VR128:$src1, sdmem:$src2, i32i8imm:$src3),
        !if(Is2Addr,
            !strconcat(OpcodeStr,
                "sd\t{$src3, $src2, $dst|$dst, $src2, $src3}"),
            !strconcat(OpcodeStr,
                "sd\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}")),
        [(set VR128:$dst,
              (F64Int VR128:$src1, sse_load_f64:$src2, imm:$src3))]>,
        OpSize;
} // ExeDomain = GenericDomain
}

// FP round - roundss, roundps, roundsd, roundpd
let Predicates = [HasAVX] in {
  // Intrinsic form
  defm VROUND  : sse41_fp_unop_rm<0x08, 0x09, "vround", f128mem, VR128,
                                  memopv4f32, memopv2f64,
                                  int_x86_sse41_round_ps,
                                  int_x86_sse41_round_pd>, VEX;
  defm VROUNDY : sse41_fp_unop_rm<0x08, 0x09, "vround", f256mem, VR256,
                                  memopv8f32, memopv4f64,
                                  int_x86_avx_round_ps_256,
                                  int_x86_avx_round_pd_256>, VEX, VEX_L;
  defm VROUND  : sse41_fp_binop_rm<0x0A, 0x0B, "vround",
                                  int_x86_sse41_round_ss,
                                  int_x86_sse41_round_sd, 0>, VEX_4V, VEX_LIG;

  def : Pat<(ffloor FR32:$src),
            (VROUNDSSr (f32 (IMPLICIT_DEF)), FR32:$src, (i32 0x1))>;
  def : Pat<(f64 (ffloor FR64:$src)),
            (VROUNDSDr (f64 (IMPLICIT_DEF)), FR64:$src, (i32 0x1))>;
  def : Pat<(f32 (fnearbyint FR32:$src)),
            (VROUNDSSr (f32 (IMPLICIT_DEF)), FR32:$src, (i32 0xC))>;
  def : Pat<(f64 (fnearbyint FR64:$src)),
            (VROUNDSDr (f64 (IMPLICIT_DEF)), FR64:$src, (i32 0xC))>;
  def : Pat<(f32 (fceil FR32:$src)),
            (VROUNDSSr (f32 (IMPLICIT_DEF)), FR32:$src, (i32 0x2))>;
  def : Pat<(f64 (fceil FR64:$src)),
            (VROUNDSDr (f64 (IMPLICIT_DEF)), FR64:$src, (i32 0x2))>;
  def : Pat<(f32 (frint FR32:$src)),
            (VROUNDSSr (f32 (IMPLICIT_DEF)), FR32:$src, (i32 0x4))>;
  def : Pat<(f64 (frint FR64:$src)),
            (VROUNDSDr (f64 (IMPLICIT_DEF)), FR64:$src, (i32 0x4))>;
  def : Pat<(f32 (ftrunc FR32:$src)),
            (VROUNDSSr (f32 (IMPLICIT_DEF)), FR32:$src, (i32 0x3))>;
  def : Pat<(f64 (ftrunc FR64:$src)),
            (VROUNDSDr (f64 (IMPLICIT_DEF)), FR64:$src, (i32 0x3))>;

  def : Pat<(v4f32 (ffloor VR128:$src)),
            (VROUNDPSr VR128:$src, (i32 0x1))>;
  def : Pat<(v4f32 (fnearbyint VR128:$src)),
            (VROUNDPSr VR128:$src, (i32 0xC))>;
  def : Pat<(v4f32 (fceil VR128:$src)),
            (VROUNDPSr VR128:$src, (i32 0x2))>;
  def : Pat<(v4f32 (frint VR128:$src)),
            (VROUNDPSr VR128:$src, (i32 0x4))>;
  def : Pat<(v4f32 (ftrunc VR128:$src)),
            (VROUNDPSr VR128:$src, (i32 0x3))>;

  def : Pat<(v2f64 (ffloor VR128:$src)),
            (VROUNDPDr VR128:$src, (i32 0x1))>;
  def : Pat<(v2f64 (fnearbyint VR128:$src)),
            (VROUNDPDr VR128:$src, (i32 0xC))>;
  def : Pat<(v2f64 (fceil VR128:$src)),
            (VROUNDPDr VR128:$src, (i32 0x2))>;
  def : Pat<(v2f64 (frint VR128:$src)),
            (VROUNDPDr VR128:$src, (i32 0x4))>;
  def : Pat<(v2f64 (ftrunc VR128:$src)),
            (VROUNDPDr VR128:$src, (i32 0x3))>;

  def : Pat<(v8f32 (ffloor VR256:$src)),
            (VROUNDYPSr VR256:$src, (i32 0x1))>;
  def : Pat<(v8f32 (fnearbyint VR256:$src)),
            (VROUNDYPSr VR256:$src, (i32 0xC))>;
  def : Pat<(v8f32 (fceil VR256:$src)),
            (VROUNDYPSr VR256:$src, (i32 0x2))>;
  def : Pat<(v8f32 (frint VR256:$src)),
            (VROUNDYPSr VR256:$src, (i32 0x4))>;
  def : Pat<(v8f32 (ftrunc VR256:$src)),
            (VROUNDYPSr VR256:$src, (i32 0x3))>;

  def : Pat<(v4f64 (ffloor VR256:$src)),
            (VROUNDYPDr VR256:$src, (i32 0x1))>;
  def : Pat<(v4f64 (fnearbyint VR256:$src)),
            (VROUNDYPDr VR256:$src, (i32 0xC))>;
  def : Pat<(v4f64 (fceil VR256:$src)),
            (VROUNDYPDr VR256:$src, (i32 0x2))>;
  def : Pat<(v4f64 (frint VR256:$src)),
            (VROUNDYPDr VR256:$src, (i32 0x4))>;
  def : Pat<(v4f64 (ftrunc VR256:$src)),
            (VROUNDYPDr VR256:$src, (i32 0x3))>;
}

defm ROUND  : sse41_fp_unop_rm<0x08, 0x09, "round", f128mem, VR128,
                               memopv4f32, memopv2f64,
                               int_x86_sse41_round_ps, int_x86_sse41_round_pd>;
let Constraints = "$src1 = $dst" in
defm ROUND  : sse41_fp_binop_rm<0x0A, 0x0B, "round",
                               int_x86_sse41_round_ss, int_x86_sse41_round_sd>;

let Predicates = [UseSSE41] in {
  def : Pat<(ffloor FR32:$src),
            (ROUNDSSr (f32 (IMPLICIT_DEF)), FR32:$src, (i32 0x1))>;
  def : Pat<(f64 (ffloor FR64:$src)),
            (ROUNDSDr (f64 (IMPLICIT_DEF)), FR64:$src, (i32 0x1))>;
  def : Pat<(f32 (fnearbyint FR32:$src)),
            (ROUNDSSr (f32 (IMPLICIT_DEF)), FR32:$src, (i32 0xC))>;
  def : Pat<(f64 (fnearbyint FR64:$src)),
            (ROUNDSDr (f64 (IMPLICIT_DEF)), FR64:$src, (i32 0xC))>;
  def : Pat<(f32 (fceil FR32:$src)),
            (ROUNDSSr (f32 (IMPLICIT_DEF)), FR32:$src, (i32 0x2))>;
  def : Pat<(f64 (fceil FR64:$src)),
            (ROUNDSDr (f64 (IMPLICIT_DEF)), FR64:$src, (i32 0x2))>;
  def : Pat<(f32 (frint FR32:$src)),
            (ROUNDSSr (f32 (IMPLICIT_DEF)), FR32:$src, (i32 0x4))>;
  def : Pat<(f64 (frint FR64:$src)),
            (ROUNDSDr (f64 (IMPLICIT_DEF)), FR64:$src, (i32 0x4))>;
  def : Pat<(f32 (ftrunc FR32:$src)),
            (ROUNDSSr (f32 (IMPLICIT_DEF)), FR32:$src, (i32 0x3))>;
  def : Pat<(f64 (ftrunc FR64:$src)),
            (ROUNDSDr (f64 (IMPLICIT_DEF)), FR64:$src, (i32 0x3))>;

  def : Pat<(v4f32 (ffloor VR128:$src)),
            (ROUNDPSr VR128:$src, (i32 0x1))>;
  def : Pat<(v4f32 (fnearbyint VR128:$src)),
            (ROUNDPSr VR128:$src, (i32 0xC))>;
  def : Pat<(v4f32 (fceil VR128:$src)),
            (ROUNDPSr VR128:$src, (i32 0x2))>;
  def : Pat<(v4f32 (frint VR128:$src)),
            (ROUNDPSr VR128:$src, (i32 0x4))>;
  def : Pat<(v4f32 (ftrunc VR128:$src)),
            (ROUNDPSr VR128:$src, (i32 0x3))>;

  def : Pat<(v2f64 (ffloor VR128:$src)),
            (ROUNDPDr VR128:$src, (i32 0x1))>;
  def : Pat<(v2f64 (fnearbyint VR128:$src)),
            (ROUNDPDr VR128:$src, (i32 0xC))>;
  def : Pat<(v2f64 (fceil VR128:$src)),
            (ROUNDPDr VR128:$src, (i32 0x2))>;
  def : Pat<(v2f64 (frint VR128:$src)),
            (ROUNDPDr VR128:$src, (i32 0x4))>;
  def : Pat<(v2f64 (ftrunc VR128:$src)),
            (ROUNDPDr VR128:$src, (i32 0x3))>;
}

//===----------------------------------------------------------------------===//
// SSE4.1 - Packed Bit Test
//===----------------------------------------------------------------------===//

// ptest instruction we'll lower to this in X86ISelLowering primarily from
// the intel intrinsic that corresponds to this.
let Defs = [EFLAGS], Predicates = [HasAVX] in {
def VPTESTrr  : SS48I<0x17, MRMSrcReg, (outs), (ins VR128:$src1, VR128:$src2),
                "vptest\t{$src2, $src1|$src1, $src2}",
                [(set EFLAGS, (X86ptest VR128:$src1, (v2i64 VR128:$src2)))]>,
                OpSize, VEX;
def VPTESTrm  : SS48I<0x17, MRMSrcMem, (outs), (ins VR128:$src1, f128mem:$src2),
                "vptest\t{$src2, $src1|$src1, $src2}",
                [(set EFLAGS,(X86ptest VR128:$src1, (memopv2i64 addr:$src2)))]>,
                OpSize, VEX;

def VPTESTYrr : SS48I<0x17, MRMSrcReg, (outs), (ins VR256:$src1, VR256:$src2),
                "vptest\t{$src2, $src1|$src1, $src2}",
                [(set EFLAGS, (X86ptest VR256:$src1, (v4i64 VR256:$src2)))]>,
                OpSize, VEX, VEX_L;
def VPTESTYrm : SS48I<0x17, MRMSrcMem, (outs), (ins VR256:$src1, i256mem:$src2),
                "vptest\t{$src2, $src1|$src1, $src2}",
                [(set EFLAGS,(X86ptest VR256:$src1, (memopv4i64 addr:$src2)))]>,
                OpSize, VEX, VEX_L;
}

let Defs = [EFLAGS] in {
def PTESTrr : SS48I<0x17, MRMSrcReg, (outs), (ins VR128:$src1, VR128:$src2),
              "ptest\t{$src2, $src1|$src1, $src2}",
              [(set EFLAGS, (X86ptest VR128:$src1, (v2i64 VR128:$src2)))]>,
              OpSize;
def PTESTrm : SS48I<0x17, MRMSrcMem, (outs), (ins VR128:$src1, f128mem:$src2),
              "ptest\t{$src2, $src1|$src1, $src2}",
              [(set EFLAGS, (X86ptest VR128:$src1, (memopv2i64 addr:$src2)))]>,
              OpSize;
}

// The bit test instructions below are AVX only
multiclass avx_bittest<bits<8> opc, string OpcodeStr, RegisterClass RC,
                       X86MemOperand x86memop, PatFrag mem_frag, ValueType vt> {
  def rr : SS48I<opc, MRMSrcReg, (outs), (ins RC:$src1, RC:$src2),
            !strconcat(OpcodeStr, "\t{$src2, $src1|$src1, $src2}"),
            [(set EFLAGS, (X86testp RC:$src1, (vt RC:$src2)))]>, OpSize, VEX;
  def rm : SS48I<opc, MRMSrcMem, (outs), (ins RC:$src1, x86memop:$src2),
            !strconcat(OpcodeStr, "\t{$src2, $src1|$src1, $src2}"),
            [(set EFLAGS, (X86testp RC:$src1, (mem_frag addr:$src2)))]>,
            OpSize, VEX;
}

let Defs = [EFLAGS], Predicates = [HasAVX] in {
let ExeDomain = SSEPackedSingle in {
defm VTESTPS  : avx_bittest<0x0E, "vtestps", VR128, f128mem, memopv4f32, v4f32>;
defm VTESTPSY : avx_bittest<0x0E, "vtestps", VR256, f256mem, memopv8f32, v8f32>,
                            VEX_L;
}
let ExeDomain = SSEPackedDouble in {
defm VTESTPD  : avx_bittest<0x0F, "vtestpd", VR128, f128mem, memopv2f64, v2f64>;
defm VTESTPDY : avx_bittest<0x0F, "vtestpd", VR256, f256mem, memopv4f64, v4f64>,
                            VEX_L;
}
}

//===----------------------------------------------------------------------===//
// SSE4.1 - Misc Instructions
//===----------------------------------------------------------------------===//

let Defs = [EFLAGS], Predicates = [HasPOPCNT] in {
  def POPCNT16rr : I<0xB8, MRMSrcReg, (outs GR16:$dst), (ins GR16:$src),
                     "popcnt{w}\t{$src, $dst|$dst, $src}",
                     [(set GR16:$dst, (ctpop GR16:$src)), (implicit EFLAGS)]>,
                     OpSize, XS;
  def POPCNT16rm : I<0xB8, MRMSrcMem, (outs GR16:$dst), (ins i16mem:$src),
                     "popcnt{w}\t{$src, $dst|$dst, $src}",
                     [(set GR16:$dst, (ctpop (loadi16 addr:$src))),
                      (implicit EFLAGS)]>, OpSize, XS;

  def POPCNT32rr : I<0xB8, MRMSrcReg, (outs GR32:$dst), (ins GR32:$src),
                     "popcnt{l}\t{$src, $dst|$dst, $src}",
                     [(set GR32:$dst, (ctpop GR32:$src)), (implicit EFLAGS)]>,
                     XS;
  def POPCNT32rm : I<0xB8, MRMSrcMem, (outs GR32:$dst), (ins i32mem:$src),
                     "popcnt{l}\t{$src, $dst|$dst, $src}",
                     [(set GR32:$dst, (ctpop (loadi32 addr:$src))),
                      (implicit EFLAGS)]>, XS;

  def POPCNT64rr : RI<0xB8, MRMSrcReg, (outs GR64:$dst), (ins GR64:$src),
                      "popcnt{q}\t{$src, $dst|$dst, $src}",
                      [(set GR64:$dst, (ctpop GR64:$src)), (implicit EFLAGS)]>,
                      XS;
  def POPCNT64rm : RI<0xB8, MRMSrcMem, (outs GR64:$dst), (ins i64mem:$src),
                      "popcnt{q}\t{$src, $dst|$dst, $src}",
                      [(set GR64:$dst, (ctpop (loadi64 addr:$src))),
                       (implicit EFLAGS)]>, XS;
}



// SS41I_unop_rm_int_v16 - SSE 4.1 unary operator whose type is v8i16.
multiclass SS41I_unop_rm_int_v16<bits<8> opc, string OpcodeStr,
                                 Intrinsic IntId128> {
  def rr128 : SS48I<opc, MRMSrcReg, (outs VR128:$dst),
                    (ins VR128:$src),
                    !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                    [(set VR128:$dst, (IntId128 VR128:$src))]>, OpSize;
  def rm128 : SS48I<opc, MRMSrcMem, (outs VR128:$dst),
                     (ins i128mem:$src),
                     !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                     [(set VR128:$dst,
                       (IntId128
                        (bitconvert (memopv2i64 addr:$src))))]>, OpSize;
}

let Predicates = [HasAVX] in
defm VPHMINPOSUW : SS41I_unop_rm_int_v16 <0x41, "vphminposuw",
                                         int_x86_sse41_phminposuw>, VEX;
defm PHMINPOSUW : SS41I_unop_rm_int_v16 <0x41, "phminposuw",
                                         int_x86_sse41_phminposuw>;

/// SS41I_binop_rm_int - Simple SSE 4.1 binary operator
multiclass SS41I_binop_rm_int<bits<8> opc, string OpcodeStr,
                              Intrinsic IntId128, bit Is2Addr = 1> {
  let isCommutable = 1 in
  def rr : SS48I<opc, MRMSrcReg, (outs VR128:$dst),
       (ins VR128:$src1, VR128:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set VR128:$dst, (IntId128 VR128:$src1, VR128:$src2))]>, OpSize;
  def rm : SS48I<opc, MRMSrcMem, (outs VR128:$dst),
       (ins VR128:$src1, i128mem:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set VR128:$dst,
         (IntId128 VR128:$src1,
          (bitconvert (memopv2i64 addr:$src2))))]>, OpSize;
}

/// SS41I_binop_rm_int_y - Simple SSE 4.1 binary operator
multiclass SS41I_binop_rm_int_y<bits<8> opc, string OpcodeStr,
                                Intrinsic IntId256> {
  let isCommutable = 1 in
  def Yrr : SS48I<opc, MRMSrcReg, (outs VR256:$dst),
       (ins VR256:$src1, VR256:$src2),
       !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
       [(set VR256:$dst, (IntId256 VR256:$src1, VR256:$src2))]>, OpSize;
  def Yrm : SS48I<opc, MRMSrcMem, (outs VR256:$dst),
       (ins VR256:$src1, i256mem:$src2),
       !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
       [(set VR256:$dst,
         (IntId256 VR256:$src1,
          (bitconvert (memopv4i64 addr:$src2))))]>, OpSize;
}


/// SS48I_binop_rm - Simple SSE41 binary operator.
multiclass SS48I_binop_rm<bits<8> opc, string OpcodeStr, SDNode OpNode,
                          ValueType OpVT, RegisterClass RC, PatFrag memop_frag,
                          X86MemOperand x86memop, bit Is2Addr = 1> {
  let isCommutable = 1 in
  def rr : SS48I<opc, MRMSrcReg, (outs RC:$dst),
       (ins RC:$src1, RC:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (OpVT (OpNode RC:$src1, RC:$src2)))]>, OpSize;
  def rm : SS48I<opc, MRMSrcMem, (outs RC:$dst),
       (ins RC:$src1, x86memop:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst,
         (OpVT (OpNode RC:$src1,
          (bitconvert (memop_frag addr:$src2)))))]>, OpSize;
}

let Predicates = [HasAVX] in {
  let isCommutable = 0 in
  defm VPACKUSDW : SS41I_binop_rm_int<0x2B, "vpackusdw", int_x86_sse41_packusdw,
                                                         0>, VEX_4V;
  defm VPMINSB   : SS48I_binop_rm<0x38, "vpminsb", X86smin, v16i8, VR128,
                                  memopv2i64, i128mem, 0>, VEX_4V;
  defm VPMINSD   : SS48I_binop_rm<0x39, "vpminsd", X86smin, v4i32, VR128,
                                  memopv2i64, i128mem, 0>, VEX_4V;
  defm VPMINUD   : SS48I_binop_rm<0x3B, "vpminud", X86umin, v4i32, VR128,
                                  memopv2i64, i128mem, 0>, VEX_4V;
  defm VPMINUW   : SS48I_binop_rm<0x3A, "vpminuw", X86umin, v8i16, VR128,
                                  memopv2i64, i128mem, 0>, VEX_4V;
  defm VPMAXSB   : SS48I_binop_rm<0x3C, "vpmaxsb", X86smax, v16i8, VR128,
                                  memopv2i64, i128mem, 0>, VEX_4V;
  defm VPMAXSD   : SS48I_binop_rm<0x3D, "vpmaxsd", X86smax, v4i32, VR128,
                                  memopv2i64, i128mem, 0>, VEX_4V;
  defm VPMAXUD   : SS48I_binop_rm<0x3F, "vpmaxud", X86umax, v4i32, VR128,
                                  memopv2i64, i128mem, 0>, VEX_4V;
  defm VPMAXUW   : SS48I_binop_rm<0x3E, "vpmaxuw", X86umax, v8i16, VR128,
                                  memopv2i64, i128mem, 0>, VEX_4V;
  defm VPMULDQ   : SS41I_binop_rm_int<0x28, "vpmuldq",   int_x86_sse41_pmuldq,
                                                         0>, VEX_4V;
}

let Predicates = [HasAVX2] in {
  let isCommutable = 0 in
  defm VPACKUSDW : SS41I_binop_rm_int_y<0x2B, "vpackusdw",
                                        int_x86_avx2_packusdw>, VEX_4V, VEX_L;
  defm VPMINSBY  : SS48I_binop_rm<0x38, "vpminsb", X86smin, v32i8, VR256,
                                  memopv4i64, i256mem, 0>, VEX_4V, VEX_L;
  defm VPMINSDY  : SS48I_binop_rm<0x39, "vpminsd", X86smin, v8i32, VR256,
                                  memopv4i64, i256mem, 0>, VEX_4V, VEX_L;
  defm VPMINUDY  : SS48I_binop_rm<0x3B, "vpminud", X86umin, v8i32, VR256,
                                  memopv4i64, i256mem, 0>, VEX_4V, VEX_L;
  defm VPMINUWY  : SS48I_binop_rm<0x3A, "vpminuw", X86umin, v16i16, VR256,
                                  memopv4i64, i256mem, 0>, VEX_4V, VEX_L;
  defm VPMAXSBY  : SS48I_binop_rm<0x3C, "vpmaxsb", X86smax, v32i8, VR256,
                                  memopv4i64, i256mem, 0>, VEX_4V, VEX_L;
  defm VPMAXSDY  : SS48I_binop_rm<0x3D, "vpmaxsd", X86smax, v8i32, VR256,
                                  memopv4i64, i256mem, 0>, VEX_4V, VEX_L;
  defm VPMAXUDY  : SS48I_binop_rm<0x3F, "vpmaxud", X86umax, v8i32, VR256,
                                  memopv4i64, i256mem, 0>, VEX_4V, VEX_L;
  defm VPMAXUWY  : SS48I_binop_rm<0x3E, "vpmaxuw", X86umax, v16i16, VR256,
                                  memopv4i64, i256mem, 0>, VEX_4V, VEX_L;
  defm VPMULDQ   : SS41I_binop_rm_int_y<0x28, "vpmuldq",
                                        int_x86_avx2_pmul_dq>, VEX_4V, VEX_L;
}

let Constraints = "$src1 = $dst" in {
  let isCommutable = 0 in
  defm PACKUSDW : SS41I_binop_rm_int<0x2B, "packusdw", int_x86_sse41_packusdw>;
  defm PMINSB   : SS48I_binop_rm<0x38, "pminsb", X86smin, v16i8, VR128,
                                 memopv2i64, i128mem>;
  defm PMINSD   : SS48I_binop_rm<0x39, "pminsd", X86smin, v4i32, VR128,
                                 memopv2i64, i128mem>;
  defm PMINUD   : SS48I_binop_rm<0x3B, "pminud", X86umin, v4i32, VR128,
                                 memopv2i64, i128mem>;
  defm PMINUW   : SS48I_binop_rm<0x3A, "pminuw", X86umin, v8i16, VR128,
                                 memopv2i64, i128mem>;
  defm PMAXSB   : SS48I_binop_rm<0x3C, "pmaxsb", X86smax, v16i8, VR128,
                                 memopv2i64, i128mem>;
  defm PMAXSD   : SS48I_binop_rm<0x3D, "pmaxsd", X86smax, v4i32, VR128,
                                 memopv2i64, i128mem>;
  defm PMAXUD   : SS48I_binop_rm<0x3F, "pmaxud", X86umax, v4i32, VR128,
                                 memopv2i64, i128mem>;
  defm PMAXUW   : SS48I_binop_rm<0x3E, "pmaxuw", X86umax, v8i16, VR128,
                                 memopv2i64, i128mem>;
  defm PMULDQ   : SS41I_binop_rm_int<0x28, "pmuldq",   int_x86_sse41_pmuldq>;
}

let Predicates = [HasAVX] in {
  defm VPMULLD  : SS48I_binop_rm<0x40, "vpmulld", mul, v4i32, VR128,
                                memopv2i64, i128mem, 0>, VEX_4V;
  defm VPCMPEQQ : SS48I_binop_rm<0x29, "vpcmpeqq", X86pcmpeq, v2i64, VR128,
                                 memopv2i64, i128mem, 0>, VEX_4V;
}
let Predicates = [HasAVX2] in {
  defm VPMULLDY  : SS48I_binop_rm<0x40, "vpmulld", mul, v8i32, VR256,
                                  memopv4i64, i256mem, 0>, VEX_4V, VEX_L;
  defm VPCMPEQQY : SS48I_binop_rm<0x29, "vpcmpeqq", X86pcmpeq, v4i64, VR256,
                                  memopv4i64, i256mem, 0>, VEX_4V, VEX_L;
}

let Constraints = "$src1 = $dst" in {
  defm PMULLD  : SS48I_binop_rm<0x40, "pmulld", mul, v4i32, VR128,
                                memopv2i64, i128mem>;
  defm PCMPEQQ : SS48I_binop_rm<0x29, "pcmpeqq", X86pcmpeq, v2i64, VR128,
                                memopv2i64, i128mem>;
}

/// SS41I_binop_rmi_int - SSE 4.1 binary operator with 8-bit immediate
multiclass SS41I_binop_rmi_int<bits<8> opc, string OpcodeStr,
                 Intrinsic IntId, RegisterClass RC, PatFrag memop_frag,
                 X86MemOperand x86memop, bit Is2Addr = 1> {
  let isCommutable = 1 in
  def rri : SS4AIi8<opc, MRMSrcReg, (outs RC:$dst),
        (ins RC:$src1, RC:$src2, u32u8imm:$src3),
        !if(Is2Addr,
            !strconcat(OpcodeStr,
                "\t{$src3, $src2, $dst|$dst, $src2, $src3}"),
            !strconcat(OpcodeStr,
                "\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}")),
        [(set RC:$dst, (IntId RC:$src1, RC:$src2, imm:$src3))]>,
        OpSize;
  def rmi : SS4AIi8<opc, MRMSrcMem, (outs RC:$dst),
        (ins RC:$src1, x86memop:$src2, u32u8imm:$src3),
        !if(Is2Addr,
            !strconcat(OpcodeStr,
                "\t{$src3, $src2, $dst|$dst, $src2, $src3}"),
            !strconcat(OpcodeStr,
                "\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}")),
        [(set RC:$dst,
          (IntId RC:$src1,
           (bitconvert (memop_frag addr:$src2)), imm:$src3))]>,
        OpSize;
}

let Predicates = [HasAVX] in {
  let isCommutable = 0 in {
    let ExeDomain = SSEPackedSingle in {
    defm VBLENDPS : SS41I_binop_rmi_int<0x0C, "vblendps", int_x86_sse41_blendps,
                                        VR128, memopv4f32, f128mem, 0>, VEX_4V;
    defm VBLENDPSY : SS41I_binop_rmi_int<0x0C, "vblendps",
                                    int_x86_avx_blend_ps_256, VR256, memopv8f32,
                                    f256mem, 0>, VEX_4V, VEX_L;
    }
    let ExeDomain = SSEPackedDouble in {
    defm VBLENDPD : SS41I_binop_rmi_int<0x0D, "vblendpd", int_x86_sse41_blendpd,
                                        VR128, memopv2f64, f128mem, 0>, VEX_4V;
    defm VBLENDPDY : SS41I_binop_rmi_int<0x0D, "vblendpd",
                                     int_x86_avx_blend_pd_256,VR256, memopv4f64,
                                     f256mem, 0>, VEX_4V, VEX_L;
    }
  defm VPBLENDW : SS41I_binop_rmi_int<0x0E, "vpblendw", int_x86_sse41_pblendw,
                                      VR128, memopv2i64, i128mem, 0>, VEX_4V;
  defm VMPSADBW : SS41I_binop_rmi_int<0x42, "vmpsadbw", int_x86_sse41_mpsadbw,
                                      VR128, memopv2i64, i128mem, 0>, VEX_4V;
  }
  let ExeDomain = SSEPackedSingle in
  defm VDPPS : SS41I_binop_rmi_int<0x40, "vdpps", int_x86_sse41_dpps,
                                   VR128, memopv4f32, f128mem, 0>, VEX_4V;
  let ExeDomain = SSEPackedDouble in
  defm VDPPD : SS41I_binop_rmi_int<0x41, "vdppd", int_x86_sse41_dppd,
                                   VR128, memopv2f64, f128mem, 0>, VEX_4V;
  let ExeDomain = SSEPackedSingle in
  defm VDPPSY : SS41I_binop_rmi_int<0x40, "vdpps", int_x86_avx_dp_ps_256,
                                  VR256, memopv8f32, i256mem, 0>, VEX_4V, VEX_L;
}

let Predicates = [HasAVX2] in {
  let isCommutable = 0 in {
  defm VPBLENDWY : SS41I_binop_rmi_int<0x0E, "vpblendw", int_x86_avx2_pblendw,
                                  VR256, memopv4i64, i256mem, 0>, VEX_4V, VEX_L;
  defm VMPSADBWY : SS41I_binop_rmi_int<0x42, "vmpsadbw", int_x86_avx2_mpsadbw,
                                  VR256, memopv4i64, i256mem, 0>, VEX_4V, VEX_L;
  }
}

let Constraints = "$src1 = $dst" in {
  let isCommutable = 0 in {
  let ExeDomain = SSEPackedSingle in
  defm BLENDPS : SS41I_binop_rmi_int<0x0C, "blendps", int_x86_sse41_blendps,
                                     VR128, memopv4f32, f128mem>;
  let ExeDomain = SSEPackedDouble in
  defm BLENDPD : SS41I_binop_rmi_int<0x0D, "blendpd", int_x86_sse41_blendpd,
                                     VR128, memopv2f64, f128mem>;
  defm PBLENDW : SS41I_binop_rmi_int<0x0E, "pblendw", int_x86_sse41_pblendw,
                                     VR128, memopv2i64, i128mem>;
  defm MPSADBW : SS41I_binop_rmi_int<0x42, "mpsadbw", int_x86_sse41_mpsadbw,
                                     VR128, memopv2i64, i128mem>;
  }
  let ExeDomain = SSEPackedSingle in
  defm DPPS : SS41I_binop_rmi_int<0x40, "dpps", int_x86_sse41_dpps,
                                  VR128, memopv4f32, f128mem>;
  let ExeDomain = SSEPackedDouble in
  defm DPPD : SS41I_binop_rmi_int<0x41, "dppd", int_x86_sse41_dppd,
                                  VR128, memopv2f64, f128mem>;
}

/// SS41I_quaternary_int_avx - AVX SSE 4.1 with 4 operators
multiclass SS41I_quaternary_int_avx<bits<8> opc, string OpcodeStr,
                                    RegisterClass RC, X86MemOperand x86memop,
                                    PatFrag mem_frag, Intrinsic IntId> {
  def rr : Ii8<opc, MRMSrcReg, (outs RC:$dst),
                  (ins RC:$src1, RC:$src2, RC:$src3),
                  !strconcat(OpcodeStr,
                    "\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}"),
                  [(set RC:$dst, (IntId RC:$src1, RC:$src2, RC:$src3))],
                  NoItinerary, SSEPackedInt>, OpSize, TA, VEX_4V, VEX_I8IMM;

  def rm : Ii8<opc, MRMSrcMem, (outs RC:$dst),
                  (ins RC:$src1, x86memop:$src2, RC:$src3),
                  !strconcat(OpcodeStr,
                    "\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}"),
                  [(set RC:$dst,
                        (IntId RC:$src1, (bitconvert (mem_frag addr:$src2)),
                               RC:$src3))],
                  NoItinerary, SSEPackedInt>, OpSize, TA, VEX_4V, VEX_I8IMM;
}

let Predicates = [HasAVX] in {
let ExeDomain = SSEPackedDouble in {
defm VBLENDVPD  : SS41I_quaternary_int_avx<0x4B, "vblendvpd", VR128, f128mem,
                                           memopv2f64, int_x86_sse41_blendvpd>;
defm VBLENDVPDY : SS41I_quaternary_int_avx<0x4B, "vblendvpd", VR256, f256mem,
                                  memopv4f64, int_x86_avx_blendv_pd_256>, VEX_L;
} // ExeDomain = SSEPackedDouble
let ExeDomain = SSEPackedSingle in {
defm VBLENDVPS  : SS41I_quaternary_int_avx<0x4A, "vblendvps", VR128, f128mem,
                                           memopv4f32, int_x86_sse41_blendvps>;
defm VBLENDVPSY : SS41I_quaternary_int_avx<0x4A, "vblendvps", VR256, f256mem,
                                  memopv8f32, int_x86_avx_blendv_ps_256>, VEX_L;
} // ExeDomain = SSEPackedSingle
defm VPBLENDVB  : SS41I_quaternary_int_avx<0x4C, "vpblendvb", VR128, i128mem,
                                           memopv2i64, int_x86_sse41_pblendvb>;
}

let Predicates = [HasAVX2] in {
defm VPBLENDVBY : SS41I_quaternary_int_avx<0x4C, "vpblendvb", VR256, i256mem,
                                      memopv4i64, int_x86_avx2_pblendvb>, VEX_L;
}

let Predicates = [HasAVX] in {
  def : Pat<(v16i8 (vselect (v16i8 VR128:$mask), (v16i8 VR128:$src1),
                            (v16i8 VR128:$src2))),
            (VPBLENDVBrr VR128:$src2, VR128:$src1, VR128:$mask)>;
  def : Pat<(v4i32 (vselect (v4i32 VR128:$mask), (v4i32 VR128:$src1),
                            (v4i32 VR128:$src2))),
            (VBLENDVPSrr VR128:$src2, VR128:$src1, VR128:$mask)>;
  def : Pat<(v4f32 (vselect (v4i32 VR128:$mask), (v4f32 VR128:$src1),
                            (v4f32 VR128:$src2))),
            (VBLENDVPSrr VR128:$src2, VR128:$src1, VR128:$mask)>;
  def : Pat<(v2i64 (vselect (v2i64 VR128:$mask), (v2i64 VR128:$src1),
                            (v2i64 VR128:$src2))),
            (VBLENDVPDrr VR128:$src2, VR128:$src1, VR128:$mask)>;
  def : Pat<(v2f64 (vselect (v2i64 VR128:$mask), (v2f64 VR128:$src1),
                            (v2f64 VR128:$src2))),
            (VBLENDVPDrr VR128:$src2, VR128:$src1, VR128:$mask)>;
  def : Pat<(v8i32 (vselect (v8i32 VR256:$mask), (v8i32 VR256:$src1),
                            (v8i32 VR256:$src2))),
            (VBLENDVPSYrr VR256:$src2, VR256:$src1, VR256:$mask)>;
  def : Pat<(v8f32 (vselect (v8i32 VR256:$mask), (v8f32 VR256:$src1),
                            (v8f32 VR256:$src2))),
            (VBLENDVPSYrr VR256:$src2, VR256:$src1, VR256:$mask)>;
  def : Pat<(v4i64 (vselect (v4i64 VR256:$mask), (v4i64 VR256:$src1),
                            (v4i64 VR256:$src2))),
            (VBLENDVPDYrr VR256:$src2, VR256:$src1, VR256:$mask)>;
  def : Pat<(v4f64 (vselect (v4i64 VR256:$mask), (v4f64 VR256:$src1),
                            (v4f64 VR256:$src2))),
            (VBLENDVPDYrr VR256:$src2, VR256:$src1, VR256:$mask)>;

  def : Pat<(v8f32 (X86Blendi (v8f32 VR256:$src1), (v8f32 VR256:$src2),
                               (imm:$mask))),
            (VBLENDPSYrri VR256:$src1, VR256:$src2, imm:$mask)>;
  def : Pat<(v4f64 (X86Blendi (v4f64 VR256:$src1), (v4f64 VR256:$src2),
                               (imm:$mask))),
            (VBLENDPDYrri VR256:$src1, VR256:$src2, imm:$mask)>;

  def : Pat<(v8i16 (X86Blendi (v8i16 VR128:$src1), (v8i16 VR128:$src2),
                               (imm:$mask))),
            (VPBLENDWrri VR128:$src1, VR128:$src2, imm:$mask)>;
  def : Pat<(v4f32 (X86Blendi (v4f32 VR128:$src1), (v4f32 VR128:$src2),
                               (imm:$mask))),
            (VBLENDPSrri VR128:$src1, VR128:$src2, imm:$mask)>;
  def : Pat<(v2f64 (X86Blendi (v2f64 VR128:$src1), (v2f64 VR128:$src2),
                               (imm:$mask))),
            (VBLENDPDrri VR128:$src1, VR128:$src2, imm:$mask)>;
}

let Predicates = [HasAVX2] in {
  def : Pat<(v32i8 (vselect (v32i8 VR256:$mask), (v32i8 VR256:$src1),
                            (v32i8 VR256:$src2))),
            (VPBLENDVBYrr VR256:$src1, VR256:$src2, VR256:$mask)>;
  def : Pat<(v16i16 (X86Blendi (v16i16 VR256:$src1), (v16i16 VR256:$src2),
                               (imm:$mask))),
            (VPBLENDWYrri VR256:$src1, VR256:$src2, imm:$mask)>;
}

/// SS41I_ternary_int - SSE 4.1 ternary operator
let Uses = [XMM0], Constraints = "$src1 = $dst" in {
  multiclass SS41I_ternary_int<bits<8> opc, string OpcodeStr, PatFrag mem_frag,
                               X86MemOperand x86memop, Intrinsic IntId> {
    def rr0 : SS48I<opc, MRMSrcReg, (outs VR128:$dst),
                    (ins VR128:$src1, VR128:$src2),
                    !strconcat(OpcodeStr,
                     "\t{$src2, $dst|$dst, $src2}"),
                    [(set VR128:$dst, (IntId VR128:$src1, VR128:$src2, XMM0))]>,
                    OpSize;

    def rm0 : SS48I<opc, MRMSrcMem, (outs VR128:$dst),
                    (ins VR128:$src1, x86memop:$src2),
                    !strconcat(OpcodeStr,
                     "\t{$src2, $dst|$dst, $src2}"),
                    [(set VR128:$dst,
                      (IntId VR128:$src1,
                       (bitconvert (mem_frag addr:$src2)), XMM0))]>, OpSize;
  }
}

let ExeDomain = SSEPackedDouble in
defm BLENDVPD : SS41I_ternary_int<0x15, "blendvpd", memopv2f64, f128mem,
                                  int_x86_sse41_blendvpd>;
let ExeDomain = SSEPackedSingle in
defm BLENDVPS : SS41I_ternary_int<0x14, "blendvps", memopv4f32, f128mem,
                                  int_x86_sse41_blendvps>;
defm PBLENDVB : SS41I_ternary_int<0x10, "pblendvb", memopv2i64, i128mem,
                                  int_x86_sse41_pblendvb>;

// Aliases with the implicit xmm0 argument
def : InstAlias<"blendvpd\t{%xmm0, $src2, $dst|$dst, $src2, %xmm0}",
                (BLENDVPDrr0 VR128:$dst, VR128:$src2)>;
def : InstAlias<"blendvpd\t{%xmm0, $src2, $dst|$dst, $src2, %xmm0}",
                (BLENDVPDrm0 VR128:$dst, f128mem:$src2)>;
def : InstAlias<"blendvps\t{%xmm0, $src2, $dst|$dst, $src2, %xmm0}",
                (BLENDVPSrr0 VR128:$dst, VR128:$src2)>;
def : InstAlias<"blendvps\t{%xmm0, $src2, $dst|$dst, $src2, %xmm0}",
                (BLENDVPSrm0 VR128:$dst, f128mem:$src2)>;
def : InstAlias<"pblendvb\t{%xmm0, $src2, $dst|$dst, $src2, %xmm0}",
                (PBLENDVBrr0 VR128:$dst, VR128:$src2)>;
def : InstAlias<"pblendvb\t{%xmm0, $src2, $dst|$dst, $src2, %xmm0}",
                (PBLENDVBrm0 VR128:$dst, i128mem:$src2)>;

let Predicates = [UseSSE41] in {
  def : Pat<(v16i8 (vselect (v16i8 XMM0), (v16i8 VR128:$src1),
                            (v16i8 VR128:$src2))),
            (PBLENDVBrr0 VR128:$src2, VR128:$src1)>;
  def : Pat<(v4i32 (vselect (v4i32 XMM0), (v4i32 VR128:$src1),
                            (v4i32 VR128:$src2))),
            (BLENDVPSrr0 VR128:$src2, VR128:$src1)>;
  def : Pat<(v4f32 (vselect (v4i32 XMM0), (v4f32 VR128:$src1),
                            (v4f32 VR128:$src2))),
            (BLENDVPSrr0 VR128:$src2, VR128:$src1)>;
  def : Pat<(v2i64 (vselect (v2i64 XMM0), (v2i64 VR128:$src1),
                            (v2i64 VR128:$src2))),
            (BLENDVPDrr0 VR128:$src2, VR128:$src1)>;
  def : Pat<(v2f64 (vselect (v2i64 XMM0), (v2f64 VR128:$src1),
                            (v2f64 VR128:$src2))),
            (BLENDVPDrr0 VR128:$src2, VR128:$src1)>;

  def : Pat<(v8i16 (X86Blendi (v8i16 VR128:$src1), (v8i16 VR128:$src2),
                               (imm:$mask))),
            (PBLENDWrri VR128:$src1, VR128:$src2, imm:$mask)>;
  def : Pat<(v4f32 (X86Blendi (v4f32 VR128:$src1), (v4f32 VR128:$src2),
                               (imm:$mask))),
            (BLENDPSrri VR128:$src1, VR128:$src2, imm:$mask)>;
  def : Pat<(v2f64 (X86Blendi (v2f64 VR128:$src1), (v2f64 VR128:$src2),
                               (imm:$mask))),
            (BLENDPDrri VR128:$src1, VR128:$src2, imm:$mask)>;

}

let Predicates = [HasAVX] in
def VMOVNTDQArm : SS48I<0x2A, MRMSrcMem, (outs VR128:$dst), (ins i128mem:$src),
                       "vmovntdqa\t{$src, $dst|$dst, $src}",
                       [(set VR128:$dst, (int_x86_sse41_movntdqa addr:$src))]>,
                       OpSize, VEX;
let Predicates = [HasAVX2] in
def VMOVNTDQAYrm : SS48I<0x2A, MRMSrcMem, (outs VR256:$dst), (ins i256mem:$src),
                         "vmovntdqa\t{$src, $dst|$dst, $src}",
                         [(set VR256:$dst, (int_x86_avx2_movntdqa addr:$src))]>,
                         OpSize, VEX, VEX_L;
def MOVNTDQArm : SS48I<0x2A, MRMSrcMem, (outs VR128:$dst), (ins i128mem:$src),
                       "movntdqa\t{$src, $dst|$dst, $src}",
                       [(set VR128:$dst, (int_x86_sse41_movntdqa addr:$src))]>,
                       OpSize;

//===----------------------------------------------------------------------===//
// SSE4.2 - Compare Instructions
//===----------------------------------------------------------------------===//

/// SS42I_binop_rm - Simple SSE 4.2 binary operator
multiclass SS42I_binop_rm<bits<8> opc, string OpcodeStr, SDNode OpNode,
                          ValueType OpVT, RegisterClass RC, PatFrag memop_frag,
                          X86MemOperand x86memop, bit Is2Addr = 1> {
  def rr : SS428I<opc, MRMSrcReg, (outs RC:$dst),
       (ins RC:$src1, RC:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst, (OpVT (OpNode RC:$src1, RC:$src2)))]>,
       OpSize;
  def rm : SS428I<opc, MRMSrcMem, (outs RC:$dst),
       (ins RC:$src1, x86memop:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set RC:$dst,
         (OpVT (OpNode RC:$src1, (memop_frag addr:$src2))))]>, OpSize;
}

let Predicates = [HasAVX] in
  defm VPCMPGTQ : SS42I_binop_rm<0x37, "vpcmpgtq", X86pcmpgt, v2i64, VR128,
                                 memopv2i64, i128mem, 0>, VEX_4V;

let Predicates = [HasAVX2] in
  defm VPCMPGTQY : SS42I_binop_rm<0x37, "vpcmpgtq", X86pcmpgt, v4i64, VR256,
                                  memopv4i64, i256mem, 0>, VEX_4V, VEX_L;

let Constraints = "$src1 = $dst" in
  defm PCMPGTQ : SS42I_binop_rm<0x37, "pcmpgtq", X86pcmpgt, v2i64, VR128,
                                memopv2i64, i128mem>;

//===----------------------------------------------------------------------===//
// SSE4.2 - String/text Processing Instructions
//===----------------------------------------------------------------------===//

// Packed Compare Implicit Length Strings, Return Mask
multiclass pseudo_pcmpistrm<string asm> {
  def REG : PseudoI<(outs VR128:$dst),
                    (ins VR128:$src1, VR128:$src2, i8imm:$src3),
    [(set VR128:$dst, (int_x86_sse42_pcmpistrm128 VR128:$src1, VR128:$src2,
                                                  imm:$src3))]>;
  def MEM : PseudoI<(outs VR128:$dst),
                    (ins VR128:$src1, i128mem:$src2, i8imm:$src3),
    [(set VR128:$dst, (int_x86_sse42_pcmpistrm128 VR128:$src1,
                       (bc_v16i8 (memopv2i64 addr:$src2)), imm:$src3))]>;
}

let Defs = [EFLAGS], usesCustomInserter = 1 in {
  defm VPCMPISTRM128 : pseudo_pcmpistrm<"#VPCMPISTRM128">, Requires<[HasAVX]>;
  defm PCMPISTRM128 : pseudo_pcmpistrm<"#PCMPISTRM128">, Requires<[UseSSE42]>;
}

multiclass pcmpistrm_SS42AI<string asm> {
  def rr : SS42AI<0x62, MRMSrcReg, (outs),
    (ins VR128:$src1, VR128:$src2, i8imm:$src3),
    !strconcat(asm, "\t{$src3, $src2, $src1|$src1, $src2, $src3}"),
    []>, OpSize;
  let mayLoad = 1 in
  def rm :SS42AI<0x62, MRMSrcMem, (outs),
    (ins VR128:$src1, i128mem:$src2, i8imm:$src3),
    !strconcat(asm, "\t{$src3, $src2, $src1|$src1, $src2, $src3}"),
    []>, OpSize;
}

let Defs = [XMM0, EFLAGS], neverHasSideEffects = 1 in {
  let Predicates = [HasAVX] in
  defm VPCMPISTRM128 : pcmpistrm_SS42AI<"vpcmpistrm">, VEX;
  defm PCMPISTRM128  : pcmpistrm_SS42AI<"pcmpistrm"> ;
}

// Packed Compare Explicit Length Strings, Return Mask
multiclass pseudo_pcmpestrm<string asm> {
  def REG : PseudoI<(outs VR128:$dst),
                    (ins VR128:$src1, VR128:$src3, i8imm:$src5),
    [(set VR128:$dst, (int_x86_sse42_pcmpestrm128
                       VR128:$src1, EAX, VR128:$src3, EDX, imm:$src5))]>;
  def MEM : PseudoI<(outs VR128:$dst),
                    (ins VR128:$src1, i128mem:$src3, i8imm:$src5),
    [(set VR128:$dst, (int_x86_sse42_pcmpestrm128 VR128:$src1, EAX,
                       (bc_v16i8 (memopv2i64 addr:$src3)), EDX, imm:$src5))]>;
}

let Defs = [EFLAGS], Uses = [EAX, EDX], usesCustomInserter = 1 in {
  defm VPCMPESTRM128 : pseudo_pcmpestrm<"#VPCMPESTRM128">, Requires<[HasAVX]>;
  defm PCMPESTRM128 : pseudo_pcmpestrm<"#PCMPESTRM128">, Requires<[UseSSE42]>;
}

multiclass SS42AI_pcmpestrm<string asm> {
  def rr : SS42AI<0x60, MRMSrcReg, (outs),
    (ins VR128:$src1, VR128:$src3, i8imm:$src5),
    !strconcat(asm, "\t{$src5, $src3, $src1|$src1, $src3, $src5}"),
    []>, OpSize;
  let mayLoad = 1 in
  def rm : SS42AI<0x60, MRMSrcMem, (outs),
    (ins VR128:$src1, i128mem:$src3, i8imm:$src5),
    !strconcat(asm, "\t{$src5, $src3, $src1|$src1, $src3, $src5}"),
    []>, OpSize;
}

let Defs = [XMM0, EFLAGS], Uses = [EAX, EDX], neverHasSideEffects = 1 in {
  let Predicates = [HasAVX] in
  defm VPCMPESTRM128 : SS42AI_pcmpestrm<"vpcmpestrm">, VEX;
  defm PCMPESTRM128 :  SS42AI_pcmpestrm<"pcmpestrm">;
}

// Packed Compare Implicit Length Strings, Return Index
multiclass pseudo_pcmpistri<string asm> {
  def REG : PseudoI<(outs GR32:$dst),
                    (ins VR128:$src1, VR128:$src2, i8imm:$src3),
    [(set GR32:$dst, EFLAGS,
      (X86pcmpistri VR128:$src1, VR128:$src2, imm:$src3))]>;
  def MEM : PseudoI<(outs GR32:$dst),
                    (ins VR128:$src1, i128mem:$src2, i8imm:$src3),
    [(set GR32:$dst, EFLAGS, (X86pcmpistri VR128:$src1,
                              (bc_v16i8 (memopv2i64 addr:$src2)), imm:$src3))]>;
}

let Defs = [EFLAGS], usesCustomInserter = 1 in {
  defm VPCMPISTRI : pseudo_pcmpistri<"#VPCMPISTRI">, Requires<[HasAVX]>;
  defm PCMPISTRI  : pseudo_pcmpistri<"#PCMPISTRI">, Requires<[UseSSE42]>;
}

multiclass SS42AI_pcmpistri<string asm> {
  def rr : SS42AI<0x63, MRMSrcReg, (outs),
    (ins VR128:$src1, VR128:$src2, i8imm:$src3),
    !strconcat(asm, "\t{$src3, $src2, $src1|$src1, $src2, $src3}"),
    []>, OpSize;
  let mayLoad = 1 in
  def rm : SS42AI<0x63, MRMSrcMem, (outs),
    (ins VR128:$src1, i128mem:$src2, i8imm:$src3),
    !strconcat(asm, "\t{$src3, $src2, $src1|$src1, $src2, $src3}"),
    []>, OpSize;
}

let Defs = [ECX, EFLAGS], neverHasSideEffects = 1 in {
  let Predicates = [HasAVX] in
  defm VPCMPISTRI : SS42AI_pcmpistri<"vpcmpistri">, VEX;
  defm PCMPISTRI  : SS42AI_pcmpistri<"pcmpistri">;
}

// Packed Compare Explicit Length Strings, Return Index
multiclass pseudo_pcmpestri<string asm> {
  def REG : PseudoI<(outs GR32:$dst),
                    (ins VR128:$src1, VR128:$src3, i8imm:$src5),
    [(set GR32:$dst, EFLAGS,
      (X86pcmpestri VR128:$src1, EAX, VR128:$src3, EDX, imm:$src5))]>;
  def MEM : PseudoI<(outs GR32:$dst),
                    (ins VR128:$src1, i128mem:$src3, i8imm:$src5),
    [(set GR32:$dst, EFLAGS,
      (X86pcmpestri VR128:$src1, EAX, (bc_v16i8 (memopv2i64 addr:$src3)), EDX,
       imm:$src5))]>;
}

let Defs = [EFLAGS], Uses = [EAX, EDX], usesCustomInserter = 1 in {
  defm VPCMPESTRI : pseudo_pcmpestri<"#VPCMPESTRI">, Requires<[HasAVX]>;
  defm PCMPESTRI  : pseudo_pcmpestri<"#PCMPESTRI">, Requires<[UseSSE42]>;
}

multiclass SS42AI_pcmpestri<string asm> {
  def rr : SS42AI<0x61, MRMSrcReg, (outs),
    (ins VR128:$src1, VR128:$src3, i8imm:$src5),
    !strconcat(asm, "\t{$src5, $src3, $src1|$src1, $src3, $src5}"),
    []>, OpSize;
  let mayLoad = 1 in
  def rm : SS42AI<0x61, MRMSrcMem, (outs),
    (ins VR128:$src1, i128mem:$src3, i8imm:$src5),
    !strconcat(asm, "\t{$src5, $src3, $src1|$src1, $src3, $src5}"),
    []>, OpSize;
}

let Defs = [ECX, EFLAGS], Uses = [EAX, EDX], neverHasSideEffects = 1 in {
  let Predicates = [HasAVX] in
  defm VPCMPESTRI : SS42AI_pcmpestri<"vpcmpestri">, VEX;
  defm PCMPESTRI  : SS42AI_pcmpestri<"pcmpestri">;
}

//===----------------------------------------------------------------------===//
// SSE4.2 - CRC Instructions
//===----------------------------------------------------------------------===//

// No CRC instructions have AVX equivalents

// crc intrinsic instruction
// This set of instructions are only rm, the only difference is the size
// of r and m.
let Constraints = "$src1 = $dst" in {
  def CRC32r32m8  : SS42FI<0xF0, MRMSrcMem, (outs GR32:$dst),
                      (ins GR32:$src1, i8mem:$src2),
                      "crc32{b} \t{$src2, $src1|$src1, $src2}",
                       [(set GR32:$dst,
                         (int_x86_sse42_crc32_32_8 GR32:$src1,
                         (load addr:$src2)))]>;
  def CRC32r32r8  : SS42FI<0xF0, MRMSrcReg, (outs GR32:$dst),
                      (ins GR32:$src1, GR8:$src2),
                      "crc32{b} \t{$src2, $src1|$src1, $src2}",
                       [(set GR32:$dst,
                         (int_x86_sse42_crc32_32_8 GR32:$src1, GR8:$src2))]>;
  def CRC32r32m16  : SS42FI<0xF1, MRMSrcMem, (outs GR32:$dst),
                      (ins GR32:$src1, i16mem:$src2),
                      "crc32{w} \t{$src2, $src1|$src1, $src2}",
                       [(set GR32:$dst,
                         (int_x86_sse42_crc32_32_16 GR32:$src1,
                         (load addr:$src2)))]>,
                         OpSize;
  def CRC32r32r16  : SS42FI<0xF1, MRMSrcReg, (outs GR32:$dst),
                      (ins GR32:$src1, GR16:$src2),
                      "crc32{w} \t{$src2, $src1|$src1, $src2}",
                       [(set GR32:$dst,
                         (int_x86_sse42_crc32_32_16 GR32:$src1, GR16:$src2))]>,
                         OpSize;
  def CRC32r32m32  : SS42FI<0xF1, MRMSrcMem, (outs GR32:$dst),
                      (ins GR32:$src1, i32mem:$src2),
                      "crc32{l} \t{$src2, $src1|$src1, $src2}",
                       [(set GR32:$dst,
                         (int_x86_sse42_crc32_32_32 GR32:$src1,
                         (load addr:$src2)))]>;
  def CRC32r32r32  : SS42FI<0xF1, MRMSrcReg, (outs GR32:$dst),
                      (ins GR32:$src1, GR32:$src2),
                      "crc32{l} \t{$src2, $src1|$src1, $src2}",
                       [(set GR32:$dst,
                         (int_x86_sse42_crc32_32_32 GR32:$src1, GR32:$src2))]>;
  def CRC32r64m8  : SS42FI<0xF0, MRMSrcMem, (outs GR64:$dst),
                      (ins GR64:$src1, i8mem:$src2),
                      "crc32{b} \t{$src2, $src1|$src1, $src2}",
                       [(set GR64:$dst,
                         (int_x86_sse42_crc32_64_8 GR64:$src1,
                         (load addr:$src2)))]>,
                         REX_W;
  def CRC32r64r8  : SS42FI<0xF0, MRMSrcReg, (outs GR64:$dst),
                      (ins GR64:$src1, GR8:$src2),
                      "crc32{b} \t{$src2, $src1|$src1, $src2}",
                       [(set GR64:$dst,
                         (int_x86_sse42_crc32_64_8 GR64:$src1, GR8:$src2))]>,
                         REX_W;
  def CRC32r64m64  : SS42FI<0xF1, MRMSrcMem, (outs GR64:$dst),
                      (ins GR64:$src1, i64mem:$src2),
                      "crc32{q} \t{$src2, $src1|$src1, $src2}",
                       [(set GR64:$dst,
                         (int_x86_sse42_crc32_64_64 GR64:$src1,
                         (load addr:$src2)))]>,
                         REX_W;
  def CRC32r64r64  : SS42FI<0xF1, MRMSrcReg, (outs GR64:$dst),
                      (ins GR64:$src1, GR64:$src2),
                      "crc32{q} \t{$src2, $src1|$src1, $src2}",
                       [(set GR64:$dst,
                         (int_x86_sse42_crc32_64_64 GR64:$src1, GR64:$src2))]>,
                         REX_W;
}

//===----------------------------------------------------------------------===//
// AES-NI Instructions
//===----------------------------------------------------------------------===//

multiclass AESI_binop_rm_int<bits<8> opc, string OpcodeStr,
                              Intrinsic IntId128, bit Is2Addr = 1> {
  def rr : AES8I<opc, MRMSrcReg, (outs VR128:$dst),
       (ins VR128:$src1, VR128:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set VR128:$dst, (IntId128 VR128:$src1, VR128:$src2))]>,
       OpSize;
  def rm : AES8I<opc, MRMSrcMem, (outs VR128:$dst),
       (ins VR128:$src1, i128mem:$src2),
       !if(Is2Addr,
           !strconcat(OpcodeStr, "\t{$src2, $dst|$dst, $src2}"),
           !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}")),
       [(set VR128:$dst,
         (IntId128 VR128:$src1, (memopv2i64 addr:$src2)))]>, OpSize;
}

// Perform One Round of an AES Encryption/Decryption Flow
let Predicates = [HasAVX, HasAES] in {
  defm VAESENC          : AESI_binop_rm_int<0xDC, "vaesenc",
                         int_x86_aesni_aesenc, 0>, VEX_4V;
  defm VAESENCLAST      : AESI_binop_rm_int<0xDD, "vaesenclast",
                         int_x86_aesni_aesenclast, 0>, VEX_4V;
  defm VAESDEC          : AESI_binop_rm_int<0xDE, "vaesdec",
                         int_x86_aesni_aesdec, 0>, VEX_4V;
  defm VAESDECLAST      : AESI_binop_rm_int<0xDF, "vaesdeclast",
                         int_x86_aesni_aesdeclast, 0>, VEX_4V;
}

let Constraints = "$src1 = $dst" in {
  defm AESENC          : AESI_binop_rm_int<0xDC, "aesenc",
                         int_x86_aesni_aesenc>;
  defm AESENCLAST      : AESI_binop_rm_int<0xDD, "aesenclast",
                         int_x86_aesni_aesenclast>;
  defm AESDEC          : AESI_binop_rm_int<0xDE, "aesdec",
                         int_x86_aesni_aesdec>;
  defm AESDECLAST      : AESI_binop_rm_int<0xDF, "aesdeclast",
                         int_x86_aesni_aesdeclast>;
}

// Perform the AES InvMixColumn Transformation
let Predicates = [HasAVX, HasAES] in {
  def VAESIMCrr : AES8I<0xDB, MRMSrcReg, (outs VR128:$dst),
      (ins VR128:$src1),
      "vaesimc\t{$src1, $dst|$dst, $src1}",
      [(set VR128:$dst,
        (int_x86_aesni_aesimc VR128:$src1))]>,
      OpSize, VEX;
  def VAESIMCrm : AES8I<0xDB, MRMSrcMem, (outs VR128:$dst),
      (ins i128mem:$src1),
      "vaesimc\t{$src1, $dst|$dst, $src1}",
      [(set VR128:$dst, (int_x86_aesni_aesimc (memopv2i64 addr:$src1)))]>,
      OpSize, VEX;
}
def AESIMCrr : AES8I<0xDB, MRMSrcReg, (outs VR128:$dst),
  (ins VR128:$src1),
  "aesimc\t{$src1, $dst|$dst, $src1}",
  [(set VR128:$dst,
    (int_x86_aesni_aesimc VR128:$src1))]>,
  OpSize;
def AESIMCrm : AES8I<0xDB, MRMSrcMem, (outs VR128:$dst),
  (ins i128mem:$src1),
  "aesimc\t{$src1, $dst|$dst, $src1}",
  [(set VR128:$dst, (int_x86_aesni_aesimc (memopv2i64 addr:$src1)))]>,
  OpSize;

// AES Round Key Generation Assist
let Predicates = [HasAVX, HasAES] in {
  def VAESKEYGENASSIST128rr : AESAI<0xDF, MRMSrcReg, (outs VR128:$dst),
      (ins VR128:$src1, i8imm:$src2),
      "vaeskeygenassist\t{$src2, $src1, $dst|$dst, $src1, $src2}",
      [(set VR128:$dst,
        (int_x86_aesni_aeskeygenassist VR128:$src1, imm:$src2))]>,
      OpSize, VEX;
  def VAESKEYGENASSIST128rm : AESAI<0xDF, MRMSrcMem, (outs VR128:$dst),
      (ins i128mem:$src1, i8imm:$src2),
      "vaeskeygenassist\t{$src2, $src1, $dst|$dst, $src1, $src2}",
      [(set VR128:$dst,
        (int_x86_aesni_aeskeygenassist (memopv2i64 addr:$src1), imm:$src2))]>,
      OpSize, VEX;
}
def AESKEYGENASSIST128rr : AESAI<0xDF, MRMSrcReg, (outs VR128:$dst),
  (ins VR128:$src1, i8imm:$src2),
  "aeskeygenassist\t{$src2, $src1, $dst|$dst, $src1, $src2}",
  [(set VR128:$dst,
    (int_x86_aesni_aeskeygenassist VR128:$src1, imm:$src2))]>,
  OpSize;
def AESKEYGENASSIST128rm : AESAI<0xDF, MRMSrcMem, (outs VR128:$dst),
  (ins i128mem:$src1, i8imm:$src2),
  "aeskeygenassist\t{$src2, $src1, $dst|$dst, $src1, $src2}",
  [(set VR128:$dst,
    (int_x86_aesni_aeskeygenassist (memopv2i64 addr:$src1), imm:$src2))]>,
  OpSize;

//===----------------------------------------------------------------------===//
// PCLMUL Instructions
//===----------------------------------------------------------------------===//

// AVX carry-less Multiplication instructions
def VPCLMULQDQrr : AVXPCLMULIi8<0x44, MRMSrcReg, (outs VR128:$dst),
           (ins VR128:$src1, VR128:$src2, i8imm:$src3),
           "vpclmulqdq\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}",
           [(set VR128:$dst,
             (int_x86_pclmulqdq VR128:$src1, VR128:$src2, imm:$src3))]>;

def VPCLMULQDQrm : AVXPCLMULIi8<0x44, MRMSrcMem, (outs VR128:$dst),
           (ins VR128:$src1, i128mem:$src2, i8imm:$src3),
           "vpclmulqdq\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}",
           [(set VR128:$dst, (int_x86_pclmulqdq VR128:$src1,
                              (memopv2i64 addr:$src2), imm:$src3))]>;

// Carry-less Multiplication instructions
let Constraints = "$src1 = $dst" in {
def PCLMULQDQrr : PCLMULIi8<0x44, MRMSrcReg, (outs VR128:$dst),
           (ins VR128:$src1, VR128:$src2, i8imm:$src3),
           "pclmulqdq\t{$src3, $src2, $dst|$dst, $src2, $src3}",
           [(set VR128:$dst,
             (int_x86_pclmulqdq VR128:$src1, VR128:$src2, imm:$src3))]>;

def PCLMULQDQrm : PCLMULIi8<0x44, MRMSrcMem, (outs VR128:$dst),
           (ins VR128:$src1, i128mem:$src2, i8imm:$src3),
           "pclmulqdq\t{$src3, $src2, $dst|$dst, $src2, $src3}",
           [(set VR128:$dst, (int_x86_pclmulqdq VR128:$src1,
                              (memopv2i64 addr:$src2), imm:$src3))]>;
} // Constraints = "$src1 = $dst"


multiclass pclmul_alias<string asm, int immop> {
  def : InstAlias<!strconcat("pclmul", asm, "dq {$src, $dst|$dst, $src}"),
                  (PCLMULQDQrr VR128:$dst, VR128:$src, immop)>;

  def : InstAlias<!strconcat("pclmul", asm, "dq {$src, $dst|$dst, $src}"),
                  (PCLMULQDQrm VR128:$dst, i128mem:$src, immop)>;

  def : InstAlias<!strconcat("vpclmul", asm,
                             "dq {$src2, $src1, $dst|$dst, $src1, $src2}"),
                  (VPCLMULQDQrr VR128:$dst, VR128:$src1, VR128:$src2, immop)>;

  def : InstAlias<!strconcat("vpclmul", asm,
                             "dq {$src2, $src1, $dst|$dst, $src1, $src2}"),
                  (VPCLMULQDQrm VR128:$dst, VR128:$src1, i128mem:$src2, immop)>;
}
defm : pclmul_alias<"hqhq", 0x11>;
defm : pclmul_alias<"hqlq", 0x01>;
defm : pclmul_alias<"lqhq", 0x10>;
defm : pclmul_alias<"lqlq", 0x00>;

//===----------------------------------------------------------------------===//
// SSE4A Instructions
//===----------------------------------------------------------------------===//

let Predicates = [HasSSE4A] in {

let Constraints = "$src = $dst" in {
def EXTRQI : Ii8<0x78, MRM0r, (outs VR128:$dst),
                 (ins VR128:$src, i8imm:$len, i8imm:$idx),
                 "extrq\t{$idx, $len, $src|$src, $len, $idx}",
                 [(set VR128:$dst, (int_x86_sse4a_extrqi VR128:$src, imm:$len,
                                    imm:$idx))]>, TB, OpSize;
def EXTRQ  : I<0x79, MRMSrcReg, (outs VR128:$dst),
              (ins VR128:$src, VR128:$mask),
              "extrq\t{$mask, $src|$src, $mask}",
              [(set VR128:$dst, (int_x86_sse4a_extrq VR128:$src,
                                 VR128:$mask))]>, TB, OpSize;

def INSERTQI : Ii8<0x78, MRMSrcReg, (outs VR128:$dst),
                   (ins VR128:$src, VR128:$src2, i8imm:$len, i8imm:$idx),
                   "insertq\t{$idx, $len, $src2, $src|$src, $src2, $len, $idx}",
                   [(set VR128:$dst, (int_x86_sse4a_insertqi VR128:$src,
                                      VR128:$src2, imm:$len, imm:$idx))]>, XD;
def INSERTQ  : I<0x79, MRMSrcReg, (outs VR128:$dst),
                 (ins VR128:$src, VR128:$mask),
                 "insertq\t{$mask, $src|$src, $mask}",
                 [(set VR128:$dst, (int_x86_sse4a_insertq VR128:$src,
                                    VR128:$mask))]>, XD;
}

def MOVNTSS : I<0x2B, MRMDestMem, (outs), (ins f32mem:$dst, VR128:$src),
                "movntss\t{$src, $dst|$dst, $src}",
                [(int_x86_sse4a_movnt_ss addr:$dst, VR128:$src)]>, XS;

def MOVNTSD : I<0x2B, MRMDestMem, (outs), (ins f64mem:$dst, VR128:$src),
                "movntsd\t{$src, $dst|$dst, $src}",
                [(int_x86_sse4a_movnt_sd addr:$dst, VR128:$src)]>, XD;
}

//===----------------------------------------------------------------------===//
// AVX Instructions
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// VBROADCAST - Load from memory and broadcast to all elements of the
//              destination operand
//
class avx_broadcast<bits<8> opc, string OpcodeStr, RegisterClass RC,
                    X86MemOperand x86memop, Intrinsic Int> :
  AVX8I<opc, MRMSrcMem, (outs RC:$dst), (ins x86memop:$src),
        !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
        [(set RC:$dst, (Int addr:$src))]>, VEX;

// AVX2 adds register forms
class avx2_broadcast_reg<bits<8> opc, string OpcodeStr, RegisterClass RC,
                         Intrinsic Int> :
  AVX28I<opc, MRMSrcReg, (outs RC:$dst), (ins VR128:$src),
         !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
         [(set RC:$dst, (Int VR128:$src))]>, VEX;

let ExeDomain = SSEPackedSingle in {
  def VBROADCASTSSrm  : avx_broadcast<0x18, "vbroadcastss", VR128, f32mem,
                                      int_x86_avx_vbroadcast_ss>;
  def VBROADCASTSSYrm : avx_broadcast<0x18, "vbroadcastss", VR256, f32mem,
                                      int_x86_avx_vbroadcast_ss_256>, VEX_L;
}
let ExeDomain = SSEPackedDouble in
def VBROADCASTSDYrm  : avx_broadcast<0x19, "vbroadcastsd", VR256, f64mem,
                                    int_x86_avx_vbroadcast_sd_256>, VEX_L;
def VBROADCASTF128 : avx_broadcast<0x1A, "vbroadcastf128", VR256, f128mem,
                                   int_x86_avx_vbroadcastf128_pd_256>, VEX_L;

let ExeDomain = SSEPackedSingle in {
  def VBROADCASTSSrr  : avx2_broadcast_reg<0x18, "vbroadcastss", VR128,
                                           int_x86_avx2_vbroadcast_ss_ps>;
  def VBROADCASTSSYrr : avx2_broadcast_reg<0x18, "vbroadcastss", VR256,
                                      int_x86_avx2_vbroadcast_ss_ps_256>, VEX_L;
}
let ExeDomain = SSEPackedDouble in
def VBROADCASTSDYrr  : avx2_broadcast_reg<0x19, "vbroadcastsd", VR256,
                                      int_x86_avx2_vbroadcast_sd_pd_256>, VEX_L;

let Predicates = [HasAVX2] in
def VBROADCASTI128 : avx_broadcast<0x5A, "vbroadcasti128", VR256, i128mem,
                                   int_x86_avx2_vbroadcasti128>, VEX_L;

let Predicates = [HasAVX] in
def : Pat<(int_x86_avx_vbroadcastf128_ps_256 addr:$src),
          (VBROADCASTF128 addr:$src)>;


//===----------------------------------------------------------------------===//
// VINSERTF128 - Insert packed floating-point values
//
let neverHasSideEffects = 1, ExeDomain = SSEPackedSingle in {
def VINSERTF128rr : AVXAIi8<0x18, MRMSrcReg, (outs VR256:$dst),
          (ins VR256:$src1, VR128:$src2, i8imm:$src3),
          "vinsertf128\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}",
          []>, VEX_4V, VEX_L;
let mayLoad = 1 in
def VINSERTF128rm : AVXAIi8<0x18, MRMSrcMem, (outs VR256:$dst),
          (ins VR256:$src1, f128mem:$src2, i8imm:$src3),
          "vinsertf128\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}",
          []>, VEX_4V, VEX_L;
}

let Predicates = [HasAVX] in {
def : Pat<(vinsertf128_insert:$ins (v8f32 VR256:$src1), (v4f32 VR128:$src2),
                                   (iPTR imm)),
          (VINSERTF128rr VR256:$src1, VR128:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;
def : Pat<(vinsertf128_insert:$ins (v4f64 VR256:$src1), (v2f64 VR128:$src2),
                                   (iPTR imm)),
          (VINSERTF128rr VR256:$src1, VR128:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;

def : Pat<(vinsertf128_insert:$ins (v8f32 VR256:$src1), (memopv4f32 addr:$src2),
                                   (iPTR imm)),
          (VINSERTF128rm VR256:$src1, addr:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;
def : Pat<(vinsertf128_insert:$ins (v4f64 VR256:$src1), (memopv2f64 addr:$src2),
                                   (iPTR imm)),
          (VINSERTF128rm VR256:$src1, addr:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;
}

let Predicates = [HasAVX1Only] in {
def : Pat<(vinsertf128_insert:$ins (v4i64 VR256:$src1), (v2i64 VR128:$src2),
                                   (iPTR imm)),
          (VINSERTF128rr VR256:$src1, VR128:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;
def : Pat<(vinsertf128_insert:$ins (v8i32 VR256:$src1), (v4i32 VR128:$src2),
                                   (iPTR imm)),
          (VINSERTF128rr VR256:$src1, VR128:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;
def : Pat<(vinsertf128_insert:$ins (v32i8 VR256:$src1), (v16i8 VR128:$src2),
                                   (iPTR imm)),
          (VINSERTF128rr VR256:$src1, VR128:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;
def : Pat<(vinsertf128_insert:$ins (v16i16 VR256:$src1), (v8i16 VR128:$src2),
                                   (iPTR imm)),
          (VINSERTF128rr VR256:$src1, VR128:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;

def : Pat<(vinsertf128_insert:$ins (v4i64 VR256:$src1), (memopv2i64 addr:$src2),
                                   (iPTR imm)),
          (VINSERTF128rm VR256:$src1, addr:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;
def : Pat<(vinsertf128_insert:$ins (v8i32 VR256:$src1),
                                   (bc_v4i32 (memopv2i64 addr:$src2)),
                                   (iPTR imm)),
          (VINSERTF128rm VR256:$src1, addr:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;
def : Pat<(vinsertf128_insert:$ins (v32i8 VR256:$src1),
                                   (bc_v16i8 (memopv2i64 addr:$src2)),
                                   (iPTR imm)),
          (VINSERTF128rm VR256:$src1, addr:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;
def : Pat<(vinsertf128_insert:$ins (v16i16 VR256:$src1),
                                   (bc_v8i16 (memopv2i64 addr:$src2)),
                                   (iPTR imm)),
          (VINSERTF128rm VR256:$src1, addr:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;
}

//===----------------------------------------------------------------------===//
// VEXTRACTF128 - Extract packed floating-point values
//
let neverHasSideEffects = 1, ExeDomain = SSEPackedSingle in {
def VEXTRACTF128rr : AVXAIi8<0x19, MRMDestReg, (outs VR128:$dst),
          (ins VR256:$src1, i8imm:$src2),
          "vextractf128\t{$src2, $src1, $dst|$dst, $src1, $src2}",
          []>, VEX, VEX_L;
let mayStore = 1 in
def VEXTRACTF128mr : AVXAIi8<0x19, MRMDestMem, (outs),
          (ins f128mem:$dst, VR256:$src1, i8imm:$src2),
          "vextractf128\t{$src2, $src1, $dst|$dst, $src1, $src2}",
          []>, VEX, VEX_L;
}

// AVX1 patterns
let Predicates = [HasAVX] in {
def : Pat<(vextractf128_extract:$ext VR256:$src1, (iPTR imm)),
          (v4f32 (VEXTRACTF128rr
                    (v8f32 VR256:$src1),
                    (EXTRACT_get_vextractf128_imm VR128:$ext)))>;
def : Pat<(vextractf128_extract:$ext VR256:$src1, (iPTR imm)),
          (v2f64 (VEXTRACTF128rr
                    (v4f64 VR256:$src1),
                    (EXTRACT_get_vextractf128_imm VR128:$ext)))>;

def : Pat<(alignedstore (v4f32 (vextractf128_extract:$ext (v8f32 VR256:$src1),
                                (iPTR imm))), addr:$dst),
          (VEXTRACTF128mr addr:$dst, VR256:$src1,
           (EXTRACT_get_vextractf128_imm VR128:$ext))>;
def : Pat<(alignedstore (v2f64 (vextractf128_extract:$ext (v4f64 VR256:$src1),
                                (iPTR imm))), addr:$dst),
          (VEXTRACTF128mr addr:$dst, VR256:$src1,
           (EXTRACT_get_vextractf128_imm VR128:$ext))>;
}

let Predicates = [HasAVX1Only] in {
def : Pat<(vextractf128_extract:$ext VR256:$src1, (iPTR imm)),
          (v2i64 (VEXTRACTF128rr
                  (v4i64 VR256:$src1),
                  (EXTRACT_get_vextractf128_imm VR128:$ext)))>;
def : Pat<(vextractf128_extract:$ext VR256:$src1, (iPTR imm)),
          (v4i32 (VEXTRACTF128rr
                  (v8i32 VR256:$src1),
                  (EXTRACT_get_vextractf128_imm VR128:$ext)))>;
def : Pat<(vextractf128_extract:$ext VR256:$src1, (iPTR imm)),
          (v8i16 (VEXTRACTF128rr
                  (v16i16 VR256:$src1),
                  (EXTRACT_get_vextractf128_imm VR128:$ext)))>;
def : Pat<(vextractf128_extract:$ext VR256:$src1, (iPTR imm)),
          (v16i8 (VEXTRACTF128rr
                  (v32i8 VR256:$src1),
                  (EXTRACT_get_vextractf128_imm VR128:$ext)))>;

def : Pat<(alignedstore (v2i64 (vextractf128_extract:$ext (v4i64 VR256:$src1),
                                (iPTR imm))), addr:$dst),
          (VEXTRACTF128mr addr:$dst, VR256:$src1,
           (EXTRACT_get_vextractf128_imm VR128:$ext))>;
def : Pat<(alignedstore (v4i32 (vextractf128_extract:$ext (v8i32 VR256:$src1),
                                (iPTR imm))), addr:$dst),
          (VEXTRACTF128mr addr:$dst, VR256:$src1,
           (EXTRACT_get_vextractf128_imm VR128:$ext))>;
def : Pat<(alignedstore (v8i16 (vextractf128_extract:$ext (v16i16 VR256:$src1),
                                (iPTR imm))), addr:$dst),
          (VEXTRACTF128mr addr:$dst, VR256:$src1,
           (EXTRACT_get_vextractf128_imm VR128:$ext))>;
def : Pat<(alignedstore (v16i8 (vextractf128_extract:$ext (v32i8 VR256:$src1),
                                (iPTR imm))), addr:$dst),
          (VEXTRACTF128mr addr:$dst, VR256:$src1,
           (EXTRACT_get_vextractf128_imm VR128:$ext))>;
}

//===----------------------------------------------------------------------===//
// VMASKMOV - Conditional SIMD Packed Loads and Stores
//
multiclass avx_movmask_rm<bits<8> opc_rm, bits<8> opc_mr, string OpcodeStr,
                          Intrinsic IntLd, Intrinsic IntLd256,
                          Intrinsic IntSt, Intrinsic IntSt256> {
  def rm  : AVX8I<opc_rm, MRMSrcMem, (outs VR128:$dst),
             (ins VR128:$src1, f128mem:$src2),
             !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
             [(set VR128:$dst, (IntLd addr:$src2, VR128:$src1))]>,
             VEX_4V;
  def Yrm : AVX8I<opc_rm, MRMSrcMem, (outs VR256:$dst),
             (ins VR256:$src1, f256mem:$src2),
             !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
             [(set VR256:$dst, (IntLd256 addr:$src2, VR256:$src1))]>,
             VEX_4V, VEX_L;
  def mr  : AVX8I<opc_mr, MRMDestMem, (outs),
             (ins f128mem:$dst, VR128:$src1, VR128:$src2),
             !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
             [(IntSt addr:$dst, VR128:$src1, VR128:$src2)]>, VEX_4V;
  def Ymr : AVX8I<opc_mr, MRMDestMem, (outs),
             (ins f256mem:$dst, VR256:$src1, VR256:$src2),
             !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
             [(IntSt256 addr:$dst, VR256:$src1, VR256:$src2)]>, VEX_4V, VEX_L;
}

let ExeDomain = SSEPackedSingle in
defm VMASKMOVPS : avx_movmask_rm<0x2C, 0x2E, "vmaskmovps",
                                 int_x86_avx_maskload_ps,
                                 int_x86_avx_maskload_ps_256,
                                 int_x86_avx_maskstore_ps,
                                 int_x86_avx_maskstore_ps_256>;
let ExeDomain = SSEPackedDouble in
defm VMASKMOVPD : avx_movmask_rm<0x2D, 0x2F, "vmaskmovpd",
                                 int_x86_avx_maskload_pd,
                                 int_x86_avx_maskload_pd_256,
                                 int_x86_avx_maskstore_pd,
                                 int_x86_avx_maskstore_pd_256>;

//===----------------------------------------------------------------------===//
// VPERMIL - Permute Single and Double Floating-Point Values
//
multiclass avx_permil<bits<8> opc_rm, bits<8> opc_rmi, string OpcodeStr,
                      RegisterClass RC, X86MemOperand x86memop_f,
                      X86MemOperand x86memop_i, PatFrag i_frag,
                      Intrinsic IntVar, ValueType vt> {
  def rr  : AVX8I<opc_rm, MRMSrcReg, (outs RC:$dst),
             (ins RC:$src1, RC:$src2),
             !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
             [(set RC:$dst, (IntVar RC:$src1, RC:$src2))]>, VEX_4V;
  def rm  : AVX8I<opc_rm, MRMSrcMem, (outs RC:$dst),
             (ins RC:$src1, x86memop_i:$src2),
             !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
             [(set RC:$dst, (IntVar RC:$src1,
                             (bitconvert (i_frag addr:$src2))))]>, VEX_4V;

  def ri  : AVXAIi8<opc_rmi, MRMSrcReg, (outs RC:$dst),
             (ins RC:$src1, i8imm:$src2),
             !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
             [(set RC:$dst, (vt (X86VPermilp RC:$src1, (i8 imm:$src2))))]>, VEX;
  def mi  : AVXAIi8<opc_rmi, MRMSrcMem, (outs RC:$dst),
             (ins x86memop_f:$src1, i8imm:$src2),
             !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
             [(set RC:$dst,
               (vt (X86VPermilp (memop addr:$src1), (i8 imm:$src2))))]>, VEX;
}

let ExeDomain = SSEPackedSingle in {
  defm VPERMILPS  : avx_permil<0x0C, 0x04, "vpermilps", VR128, f128mem, i128mem,
                               memopv2i64, int_x86_avx_vpermilvar_ps, v4f32>;
  defm VPERMILPSY : avx_permil<0x0C, 0x04, "vpermilps", VR256, f256mem, i256mem,
                       memopv4i64, int_x86_avx_vpermilvar_ps_256, v8f32>, VEX_L;
}
let ExeDomain = SSEPackedDouble in {
  defm VPERMILPD  : avx_permil<0x0D, 0x05, "vpermilpd", VR128, f128mem, i128mem,
                               memopv2i64, int_x86_avx_vpermilvar_pd, v2f64>;
  defm VPERMILPDY : avx_permil<0x0D, 0x05, "vpermilpd", VR256, f256mem, i256mem,
                       memopv4i64, int_x86_avx_vpermilvar_pd_256, v4f64>, VEX_L;
}

let Predicates = [HasAVX] in {
def : Pat<(v8i32 (X86VPermilp VR256:$src1, (i8 imm:$imm))),
          (VPERMILPSYri VR256:$src1, imm:$imm)>;
def : Pat<(v4i64 (X86VPermilp VR256:$src1, (i8 imm:$imm))),
          (VPERMILPDYri VR256:$src1, imm:$imm)>;
def : Pat<(v8i32 (X86VPermilp (bc_v8i32 (memopv4i64 addr:$src1)),
                               (i8 imm:$imm))),
          (VPERMILPSYmi addr:$src1, imm:$imm)>;
def : Pat<(v4i64 (X86VPermilp (memopv4i64 addr:$src1), (i8 imm:$imm))),
          (VPERMILPDYmi addr:$src1, imm:$imm)>;

def : Pat<(v2i64 (X86VPermilp VR128:$src1, (i8 imm:$imm))),
          (VPERMILPDri VR128:$src1, imm:$imm)>;
def : Pat<(v2i64 (X86VPermilp (memopv2i64 addr:$src1), (i8 imm:$imm))),
          (VPERMILPDmi addr:$src1, imm:$imm)>;
}

//===----------------------------------------------------------------------===//
// VPERM2F128 - Permute Floating-Point Values in 128-bit chunks
//
let ExeDomain = SSEPackedSingle in {
def VPERM2F128rr : AVXAIi8<0x06, MRMSrcReg, (outs VR256:$dst),
          (ins VR256:$src1, VR256:$src2, i8imm:$src3),
          "vperm2f128\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}",
          [(set VR256:$dst, (v8f32 (X86VPerm2x128 VR256:$src1, VR256:$src2,
                              (i8 imm:$src3))))]>, VEX_4V, VEX_L;
def VPERM2F128rm : AVXAIi8<0x06, MRMSrcMem, (outs VR256:$dst),
          (ins VR256:$src1, f256mem:$src2, i8imm:$src3),
          "vperm2f128\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}",
          [(set VR256:$dst, (X86VPerm2x128 VR256:$src1, (memopv8f32 addr:$src2),
                             (i8 imm:$src3)))]>, VEX_4V, VEX_L;
}

let Predicates = [HasAVX] in {
def : Pat<(v4f64 (X86VPerm2x128 VR256:$src1, VR256:$src2, (i8 imm:$imm))),
          (VPERM2F128rr VR256:$src1, VR256:$src2, imm:$imm)>;
def : Pat<(v4f64 (X86VPerm2x128 VR256:$src1,
                  (memopv4f64 addr:$src2), (i8 imm:$imm))),
          (VPERM2F128rm VR256:$src1, addr:$src2, imm:$imm)>;
}

let Predicates = [HasAVX1Only] in {
def : Pat<(v8i32 (X86VPerm2x128 VR256:$src1, VR256:$src2, (i8 imm:$imm))),
          (VPERM2F128rr VR256:$src1, VR256:$src2, imm:$imm)>;
def : Pat<(v4i64 (X86VPerm2x128 VR256:$src1, VR256:$src2, (i8 imm:$imm))),
          (VPERM2F128rr VR256:$src1, VR256:$src2, imm:$imm)>;
def : Pat<(v32i8 (X86VPerm2x128 VR256:$src1, VR256:$src2, (i8 imm:$imm))),
          (VPERM2F128rr VR256:$src1, VR256:$src2, imm:$imm)>;
def : Pat<(v16i16 (X86VPerm2x128 VR256:$src1, VR256:$src2, (i8 imm:$imm))),
          (VPERM2F128rr VR256:$src1, VR256:$src2, imm:$imm)>;

def : Pat<(v8i32 (X86VPerm2x128 VR256:$src1,
                  (bc_v8i32 (memopv4i64 addr:$src2)), (i8 imm:$imm))),
          (VPERM2F128rm VR256:$src1, addr:$src2, imm:$imm)>;
def : Pat<(v4i64 (X86VPerm2x128 VR256:$src1,
                  (memopv4i64 addr:$src2), (i8 imm:$imm))),
          (VPERM2F128rm VR256:$src1, addr:$src2, imm:$imm)>;
def : Pat<(v32i8 (X86VPerm2x128 VR256:$src1,
                  (bc_v32i8 (memopv4i64 addr:$src2)), (i8 imm:$imm))),
          (VPERM2F128rm VR256:$src1, addr:$src2, imm:$imm)>;
def : Pat<(v16i16 (X86VPerm2x128 VR256:$src1,
                  (bc_v16i16 (memopv4i64 addr:$src2)), (i8 imm:$imm))),
          (VPERM2F128rm VR256:$src1, addr:$src2, imm:$imm)>;
}

//===----------------------------------------------------------------------===//
// VZERO - Zero YMM registers
//
let Defs = [YMM0, YMM1, YMM2, YMM3, YMM4, YMM5, YMM6, YMM7,
            YMM8, YMM9, YMM10, YMM11, YMM12, YMM13, YMM14, YMM15] in {
  // Zero All YMM registers
  def VZEROALL : I<0x77, RawFrm, (outs), (ins), "vzeroall",
                  [(int_x86_avx_vzeroall)]>, TB, VEX, VEX_L, Requires<[HasAVX]>;

  // Zero Upper bits of YMM registers
  def VZEROUPPER : I<0x77, RawFrm, (outs), (ins), "vzeroupper",
                     [(int_x86_avx_vzeroupper)]>, TB, VEX, Requires<[HasAVX]>;
}

//===----------------------------------------------------------------------===//
// Half precision conversion instructions
//===----------------------------------------------------------------------===//
multiclass f16c_ph2ps<RegisterClass RC, X86MemOperand x86memop, Intrinsic Int> {
  def rr : I<0x13, MRMSrcReg, (outs RC:$dst), (ins VR128:$src),
             "vcvtph2ps\t{$src, $dst|$dst, $src}",
             [(set RC:$dst, (Int VR128:$src))]>,
             T8, OpSize, VEX;
  let neverHasSideEffects = 1, mayLoad = 1 in
  def rm : I<0x13, MRMSrcMem, (outs RC:$dst), (ins x86memop:$src),
             "vcvtph2ps\t{$src, $dst|$dst, $src}", []>, T8, OpSize, VEX;
}

multiclass f16c_ps2ph<RegisterClass RC, X86MemOperand x86memop, Intrinsic Int> {
  def rr : Ii8<0x1D, MRMDestReg, (outs VR128:$dst),
               (ins RC:$src1, i32i8imm:$src2),
               "vcvtps2ph\t{$src2, $src1, $dst|$dst, $src1, $src2}",
               [(set VR128:$dst, (Int RC:$src1, imm:$src2))]>,
               TA, OpSize, VEX;
  let neverHasSideEffects = 1, mayStore = 1 in
  def mr : Ii8<0x1D, MRMDestMem, (outs),
               (ins x86memop:$dst, RC:$src1, i32i8imm:$src2),
               "vcvtps2ph\t{$src2, $src1, $dst|$dst, $src1, $src2}", []>,
               TA, OpSize, VEX;
}

let Predicates = [HasAVX, HasF16C] in {
  defm VCVTPH2PS  : f16c_ph2ps<VR128, f64mem, int_x86_vcvtph2ps_128>;
  defm VCVTPH2PSY : f16c_ph2ps<VR256, f128mem, int_x86_vcvtph2ps_256>, VEX_L;
  defm VCVTPS2PH  : f16c_ps2ph<VR128, f64mem, int_x86_vcvtps2ph_128>;
  defm VCVTPS2PHY : f16c_ps2ph<VR256, f128mem, int_x86_vcvtps2ph_256>, VEX_L;
}

//===----------------------------------------------------------------------===//
// AVX2 Instructions
//===----------------------------------------------------------------------===//

/// AVX2_binop_rmi_int - AVX2 binary operator with 8-bit immediate
multiclass AVX2_binop_rmi_int<bits<8> opc, string OpcodeStr,
                 Intrinsic IntId, RegisterClass RC, PatFrag memop_frag,
                 X86MemOperand x86memop> {
  let isCommutable = 1 in
  def rri : AVX2AIi8<opc, MRMSrcReg, (outs RC:$dst),
        (ins RC:$src1, RC:$src2, u32u8imm:$src3),
        !strconcat(OpcodeStr,
            "\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}"),
        [(set RC:$dst, (IntId RC:$src1, RC:$src2, imm:$src3))]>,
        VEX_4V;
  def rmi : AVX2AIi8<opc, MRMSrcMem, (outs RC:$dst),
        (ins RC:$src1, x86memop:$src2, u32u8imm:$src3),
        !strconcat(OpcodeStr,
            "\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}"),
        [(set RC:$dst,
          (IntId RC:$src1,
           (bitconvert (memop_frag addr:$src2)), imm:$src3))]>,
        VEX_4V;
}

let isCommutable = 0 in {
defm VPBLENDD : AVX2_binop_rmi_int<0x02, "vpblendd", int_x86_avx2_pblendd_128,
                                   VR128, memopv2i64, i128mem>;
defm VPBLENDDY : AVX2_binop_rmi_int<0x02, "vpblendd", int_x86_avx2_pblendd_256,
                                    VR256, memopv4i64, i256mem>, VEX_L;
}

def : Pat<(v4i32 (X86Blendi (v4i32 VR128:$src1), (v4i32 VR128:$src2),
                  imm:$mask)),
          (VPBLENDDrri VR128:$src1, VR128:$src2, imm:$mask)>;
def : Pat<(v8i32 (X86Blendi (v8i32 VR256:$src1), (v8i32 VR256:$src2),
                  imm:$mask)),
          (VPBLENDDYrri VR256:$src1, VR256:$src2, imm:$mask)>;

//===----------------------------------------------------------------------===//
// VPBROADCAST - Load from memory and broadcast to all elements of the
//               destination operand
//
multiclass avx2_broadcast<bits<8> opc, string OpcodeStr,
                          X86MemOperand x86memop, PatFrag ld_frag,
                          Intrinsic Int128, Intrinsic Int256> {
  def rr : AVX28I<opc, MRMSrcReg, (outs VR128:$dst), (ins VR128:$src),
                  !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                  [(set VR128:$dst, (Int128 VR128:$src))]>, VEX;
  def rm : AVX28I<opc, MRMSrcMem, (outs VR128:$dst), (ins x86memop:$src),
                  !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                  [(set VR128:$dst,
                    (Int128 (scalar_to_vector (ld_frag addr:$src))))]>, VEX;
  def Yrr : AVX28I<opc, MRMSrcReg, (outs VR256:$dst), (ins VR128:$src),
                   !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                   [(set VR256:$dst, (Int256 VR128:$src))]>, VEX, VEX_L;
  def Yrm : AVX28I<opc, MRMSrcMem, (outs VR256:$dst), (ins x86memop:$src),
                   !strconcat(OpcodeStr, "\t{$src, $dst|$dst, $src}"),
                   [(set VR256:$dst,
                    (Int256 (scalar_to_vector (ld_frag addr:$src))))]>,
                   VEX, VEX_L;
}

defm VPBROADCASTB  : avx2_broadcast<0x78, "vpbroadcastb", i8mem, loadi8,
                                    int_x86_avx2_pbroadcastb_128,
                                    int_x86_avx2_pbroadcastb_256>;
defm VPBROADCASTW  : avx2_broadcast<0x79, "vpbroadcastw", i16mem, loadi16,
                                    int_x86_avx2_pbroadcastw_128,
                                    int_x86_avx2_pbroadcastw_256>;
defm VPBROADCASTD  : avx2_broadcast<0x58, "vpbroadcastd", i32mem, loadi32,
                                    int_x86_avx2_pbroadcastd_128,
                                    int_x86_avx2_pbroadcastd_256>;
defm VPBROADCASTQ  : avx2_broadcast<0x59, "vpbroadcastq", i64mem, loadi64,
                                    int_x86_avx2_pbroadcastq_128,
                                    int_x86_avx2_pbroadcastq_256>;

let Predicates = [HasAVX2] in {
  def : Pat<(v16i8 (X86VBroadcast (loadi8 addr:$src))),
          (VPBROADCASTBrm addr:$src)>;
  def : Pat<(v32i8 (X86VBroadcast (loadi8 addr:$src))),
          (VPBROADCASTBYrm addr:$src)>;
  def : Pat<(v8i16 (X86VBroadcast (loadi16 addr:$src))),
          (VPBROADCASTWrm addr:$src)>;
  def : Pat<(v16i16 (X86VBroadcast (loadi16 addr:$src))),
          (VPBROADCASTWYrm addr:$src)>;
  def : Pat<(v4i32 (X86VBroadcast (loadi32 addr:$src))),
          (VPBROADCASTDrm addr:$src)>;
  def : Pat<(v8i32 (X86VBroadcast (loadi32 addr:$src))),
          (VPBROADCASTDYrm addr:$src)>;
  def : Pat<(v2i64 (X86VBroadcast (loadi64 addr:$src))),
          (VPBROADCASTQrm addr:$src)>;
  def : Pat<(v4i64 (X86VBroadcast (loadi64 addr:$src))),
          (VPBROADCASTQYrm addr:$src)>;

  def : Pat<(v16i8 (X86VBroadcast (v16i8 VR128:$src))),
          (VPBROADCASTBrr VR128:$src)>;
  def : Pat<(v32i8 (X86VBroadcast (v16i8 VR128:$src))),
          (VPBROADCASTBYrr VR128:$src)>;
  def : Pat<(v8i16 (X86VBroadcast (v8i16 VR128:$src))),
          (VPBROADCASTWrr VR128:$src)>;
  def : Pat<(v16i16 (X86VBroadcast (v8i16 VR128:$src))),
          (VPBROADCASTWYrr VR128:$src)>;
  def : Pat<(v4i32 (X86VBroadcast (v4i32 VR128:$src))),
          (VPBROADCASTDrr VR128:$src)>;
  def : Pat<(v8i32 (X86VBroadcast (v4i32 VR128:$src))),
          (VPBROADCASTDYrr VR128:$src)>;
  def : Pat<(v2i64 (X86VBroadcast (v2i64 VR128:$src))),
          (VPBROADCASTQrr VR128:$src)>;
  def : Pat<(v4i64 (X86VBroadcast (v2i64 VR128:$src))),
          (VPBROADCASTQYrr VR128:$src)>;
  def : Pat<(v4f32 (X86VBroadcast (v4f32 VR128:$src))),
          (VBROADCASTSSrr VR128:$src)>;
  def : Pat<(v8f32 (X86VBroadcast (v4f32 VR128:$src))),
          (VBROADCASTSSYrr VR128:$src)>;
  def : Pat<(v2f64 (X86VBroadcast (v2f64 VR128:$src))),
          (VPBROADCASTQrr VR128:$src)>;
  def : Pat<(v4f64 (X86VBroadcast (v2f64 VR128:$src))),
          (VBROADCASTSDYrr VR128:$src)>;

  // Provide fallback in case the load node that is used in the patterns above
  // is used by additional users, which prevents the pattern selection.
  let AddedComplexity = 20 in {
    def : Pat<(v4f32 (X86VBroadcast FR32:$src)),
              (VBROADCASTSSrr (COPY_TO_REGCLASS FR32:$src, VR128))>;
    def : Pat<(v8f32 (X86VBroadcast FR32:$src)),
              (VBROADCASTSSYrr (COPY_TO_REGCLASS FR32:$src, VR128))>;
    def : Pat<(v4f64 (X86VBroadcast FR64:$src)),
              (VBROADCASTSDYrr (COPY_TO_REGCLASS FR64:$src, VR128))>;

    def : Pat<(v4i32 (X86VBroadcast GR32:$src)),
              (VBROADCASTSSrr (COPY_TO_REGCLASS GR32:$src, VR128))>;
    def : Pat<(v8i32 (X86VBroadcast GR32:$src)),
              (VBROADCASTSSYrr (COPY_TO_REGCLASS GR32:$src, VR128))>;
    def : Pat<(v4i64 (X86VBroadcast GR64:$src)),
              (VBROADCASTSDYrr (COPY_TO_REGCLASS GR64:$src, VR128))>;
  }
}

// AVX1 broadcast patterns
let Predicates = [HasAVX1Only] in {
def : Pat<(v8i32 (X86VBroadcast (loadi32 addr:$src))),
          (VBROADCASTSSYrm addr:$src)>;
def : Pat<(v4i64 (X86VBroadcast (loadi64 addr:$src))),
          (VBROADCASTSDYrm addr:$src)>;
def : Pat<(v4i32 (X86VBroadcast (loadi32 addr:$src))),
          (VBROADCASTSSrm addr:$src)>;
}

let Predicates = [HasAVX] in {
def : Pat<(v8f32 (X86VBroadcast (loadf32 addr:$src))),
          (VBROADCASTSSYrm addr:$src)>;
def : Pat<(v4f64 (X86VBroadcast (loadf64 addr:$src))),
          (VBROADCASTSDYrm addr:$src)>;
def : Pat<(v4f32 (X86VBroadcast (loadf32 addr:$src))),
          (VBROADCASTSSrm addr:$src)>;

  // Provide fallback in case the load node that is used in the patterns above
  // is used by additional users, which prevents the pattern selection.
  let AddedComplexity = 20 in {
  // 128bit broadcasts:
  def : Pat<(v4f32 (X86VBroadcast FR32:$src)),
            (VPSHUFDri (COPY_TO_REGCLASS FR32:$src, VR128), 0)>;
  def : Pat<(v8f32 (X86VBroadcast FR32:$src)),
            (VINSERTF128rr (INSERT_SUBREG (v8f32 (IMPLICIT_DEF)),
              (VPSHUFDri (COPY_TO_REGCLASS FR32:$src, VR128), 0), sub_xmm),
              (VPSHUFDri (COPY_TO_REGCLASS FR32:$src, VR128), 0), 1)>;
  def : Pat<(v4f64 (X86VBroadcast FR64:$src)),
            (VINSERTF128rr (INSERT_SUBREG (v4f64 (IMPLICIT_DEF)),
              (VPSHUFDri (COPY_TO_REGCLASS FR64:$src, VR128), 0x44), sub_xmm),
              (VPSHUFDri (COPY_TO_REGCLASS FR64:$src, VR128), 0x44), 1)>;

  def : Pat<(v4i32 (X86VBroadcast GR32:$src)),
            (VPSHUFDri (COPY_TO_REGCLASS GR32:$src, VR128), 0)>;
  def : Pat<(v8i32 (X86VBroadcast GR32:$src)),
            (VINSERTF128rr (INSERT_SUBREG (v8i32 (IMPLICIT_DEF)),
              (VPSHUFDri (COPY_TO_REGCLASS GR32:$src, VR128), 0), sub_xmm),
              (VPSHUFDri (COPY_TO_REGCLASS GR32:$src, VR128), 0), 1)>;
  def : Pat<(v4i64 (X86VBroadcast GR64:$src)),
            (VINSERTF128rr (INSERT_SUBREG (v4i64 (IMPLICIT_DEF)),
              (VPSHUFDri (COPY_TO_REGCLASS GR64:$src, VR128), 0x44), sub_xmm),
              (VPSHUFDri (COPY_TO_REGCLASS GR64:$src, VR128), 0x44), 1)>;
  }
}

//===----------------------------------------------------------------------===//
// VPERM - Permute instructions
//

multiclass avx2_perm<bits<8> opc, string OpcodeStr, PatFrag mem_frag,
                     ValueType OpVT> {
  def Yrr : AVX28I<opc, MRMSrcReg, (outs VR256:$dst),
                   (ins VR256:$src1, VR256:$src2),
                   !strconcat(OpcodeStr,
                       "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                   [(set VR256:$dst,
                     (OpVT (X86VPermv VR256:$src1, VR256:$src2)))]>,
                   VEX_4V, VEX_L;
  def Yrm : AVX28I<opc, MRMSrcMem, (outs VR256:$dst),
                   (ins VR256:$src1, i256mem:$src2),
                   !strconcat(OpcodeStr,
                       "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                   [(set VR256:$dst,
                     (OpVT (X86VPermv VR256:$src1,
                            (bitconvert (mem_frag addr:$src2)))))]>,
                   VEX_4V, VEX_L;
}

defm VPERMD : avx2_perm<0x36, "vpermd", memopv4i64, v8i32>;
let ExeDomain = SSEPackedSingle in
defm VPERMPS : avx2_perm<0x16, "vpermps", memopv8f32, v8f32>;

multiclass avx2_perm_imm<bits<8> opc, string OpcodeStr, PatFrag mem_frag,
                         ValueType OpVT> {
  def Yri : AVX2AIi8<opc, MRMSrcReg, (outs VR256:$dst),
                     (ins VR256:$src1, i8imm:$src2),
                     !strconcat(OpcodeStr,
                         "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                     [(set VR256:$dst,
                       (OpVT (X86VPermi VR256:$src1, (i8 imm:$src2))))]>,
                     VEX, VEX_L;
  def Ymi : AVX2AIi8<opc, MRMSrcMem, (outs VR256:$dst),
                     (ins i256mem:$src1, i8imm:$src2),
                     !strconcat(OpcodeStr,
                         "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
                     [(set VR256:$dst,
                       (OpVT (X86VPermi (mem_frag addr:$src1),
                              (i8 imm:$src2))))]>, VEX, VEX_L;
}

defm VPERMQ : avx2_perm_imm<0x00, "vpermq", memopv4i64, v4i64>, VEX_W;
let ExeDomain = SSEPackedDouble in
defm VPERMPD : avx2_perm_imm<0x01, "vpermpd", memopv4f64, v4f64>, VEX_W;

//===----------------------------------------------------------------------===//
// VPERM2I128 - Permute Floating-Point Values in 128-bit chunks
//
def VPERM2I128rr : AVX2AIi8<0x46, MRMSrcReg, (outs VR256:$dst),
          (ins VR256:$src1, VR256:$src2, i8imm:$src3),
          "vperm2i128\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}",
          [(set VR256:$dst, (v4i64 (X86VPerm2x128 VR256:$src1, VR256:$src2,
                            (i8 imm:$src3))))]>, VEX_4V, VEX_L;
def VPERM2I128rm : AVX2AIi8<0x46, MRMSrcMem, (outs VR256:$dst),
          (ins VR256:$src1, f256mem:$src2, i8imm:$src3),
          "vperm2i128\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}",
          [(set VR256:$dst, (X86VPerm2x128 VR256:$src1, (memopv4i64 addr:$src2),
                             (i8 imm:$src3)))]>, VEX_4V, VEX_L;

let Predicates = [HasAVX2] in {
def : Pat<(v8i32 (X86VPerm2x128 VR256:$src1, VR256:$src2, (i8 imm:$imm))),
          (VPERM2I128rr VR256:$src1, VR256:$src2, imm:$imm)>;
def : Pat<(v32i8 (X86VPerm2x128 VR256:$src1, VR256:$src2, (i8 imm:$imm))),
          (VPERM2I128rr VR256:$src1, VR256:$src2, imm:$imm)>;
def : Pat<(v16i16 (X86VPerm2x128 VR256:$src1, VR256:$src2, (i8 imm:$imm))),
          (VPERM2I128rr VR256:$src1, VR256:$src2, imm:$imm)>;

def : Pat<(v32i8 (X86VPerm2x128 VR256:$src1, (bc_v32i8 (memopv4i64 addr:$src2)),
                  (i8 imm:$imm))),
          (VPERM2I128rm VR256:$src1, addr:$src2, imm:$imm)>;
def : Pat<(v16i16 (X86VPerm2x128 VR256:$src1,
                   (bc_v16i16 (memopv4i64 addr:$src2)), (i8 imm:$imm))),
          (VPERM2I128rm VR256:$src1, addr:$src2, imm:$imm)>;
def : Pat<(v8i32 (X86VPerm2x128 VR256:$src1, (bc_v8i32 (memopv4i64 addr:$src2)),
                  (i8 imm:$imm))),
          (VPERM2I128rm VR256:$src1, addr:$src2, imm:$imm)>;
}


//===----------------------------------------------------------------------===//
// VINSERTI128 - Insert packed integer values
//
let neverHasSideEffects = 1 in {
def VINSERTI128rr : AVX2AIi8<0x38, MRMSrcReg, (outs VR256:$dst),
          (ins VR256:$src1, VR128:$src2, i8imm:$src3),
          "vinserti128\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}",
          []>, VEX_4V, VEX_L;
let mayLoad = 1 in
def VINSERTI128rm : AVX2AIi8<0x38, MRMSrcMem, (outs VR256:$dst),
          (ins VR256:$src1, i128mem:$src2, i8imm:$src3),
          "vinserti128\t{$src3, $src2, $src1, $dst|$dst, $src1, $src2, $src3}",
          []>, VEX_4V, VEX_L;
}

let Predicates = [HasAVX2] in {
def : Pat<(vinsertf128_insert:$ins (v4i64 VR256:$src1), (v2i64 VR128:$src2),
                                   (iPTR imm)),
          (VINSERTI128rr VR256:$src1, VR128:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;
def : Pat<(vinsertf128_insert:$ins (v8i32 VR256:$src1), (v4i32 VR128:$src2),
                                   (iPTR imm)),
          (VINSERTI128rr VR256:$src1, VR128:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;
def : Pat<(vinsertf128_insert:$ins (v32i8 VR256:$src1), (v16i8 VR128:$src2),
                                   (iPTR imm)),
          (VINSERTI128rr VR256:$src1, VR128:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;
def : Pat<(vinsertf128_insert:$ins (v16i16 VR256:$src1), (v8i16 VR128:$src2),
                                   (iPTR imm)),
          (VINSERTI128rr VR256:$src1, VR128:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;

def : Pat<(vinsertf128_insert:$ins (v4i64 VR256:$src1), (memopv2i64 addr:$src2),
                                   (iPTR imm)),
          (VINSERTI128rm VR256:$src1, addr:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;
def : Pat<(vinsertf128_insert:$ins (v8i32 VR256:$src1),
                                   (bc_v4i32 (memopv2i64 addr:$src2)),
                                   (iPTR imm)),
          (VINSERTI128rm VR256:$src1, addr:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;
def : Pat<(vinsertf128_insert:$ins (v32i8 VR256:$src1),
                                   (bc_v16i8 (memopv2i64 addr:$src2)),
                                   (iPTR imm)),
          (VINSERTI128rm VR256:$src1, addr:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;
def : Pat<(vinsertf128_insert:$ins (v16i16 VR256:$src1),
                                   (bc_v8i16 (memopv2i64 addr:$src2)),
                                   (iPTR imm)),
          (VINSERTI128rm VR256:$src1, addr:$src2,
                         (INSERT_get_vinsertf128_imm VR256:$ins))>;
}

//===----------------------------------------------------------------------===//
// VEXTRACTI128 - Extract packed integer values
//
def VEXTRACTI128rr : AVX2AIi8<0x39, MRMDestReg, (outs VR128:$dst),
          (ins VR256:$src1, i8imm:$src2),
          "vextracti128\t{$src2, $src1, $dst|$dst, $src1, $src2}",
          [(set VR128:$dst,
            (int_x86_avx2_vextracti128 VR256:$src1, imm:$src2))]>,
          VEX, VEX_L;
let neverHasSideEffects = 1, mayStore = 1 in
def VEXTRACTI128mr : AVX2AIi8<0x39, MRMDestMem, (outs),
          (ins i128mem:$dst, VR256:$src1, i8imm:$src2),
          "vextracti128\t{$src2, $src1, $dst|$dst, $src1, $src2}", []>,
          VEX, VEX_L;

let Predicates = [HasAVX2] in {
def : Pat<(vextractf128_extract:$ext VR256:$src1, (iPTR imm)),
          (v2i64 (VEXTRACTI128rr
                    (v4i64 VR256:$src1),
                    (EXTRACT_get_vextractf128_imm VR128:$ext)))>;
def : Pat<(vextractf128_extract:$ext VR256:$src1, (iPTR imm)),
          (v4i32 (VEXTRACTI128rr
                    (v8i32 VR256:$src1),
                    (EXTRACT_get_vextractf128_imm VR128:$ext)))>;
def : Pat<(vextractf128_extract:$ext VR256:$src1, (iPTR imm)),
          (v8i16 (VEXTRACTI128rr
                    (v16i16 VR256:$src1),
                    (EXTRACT_get_vextractf128_imm VR128:$ext)))>;
def : Pat<(vextractf128_extract:$ext VR256:$src1, (iPTR imm)),
          (v16i8 (VEXTRACTI128rr
                    (v32i8 VR256:$src1),
                    (EXTRACT_get_vextractf128_imm VR128:$ext)))>;

def : Pat<(alignedstore (v2i64 (vextractf128_extract:$ext (v4i64 VR256:$src1),
                                (iPTR imm))), addr:$dst),
          (VEXTRACTI128mr addr:$dst, VR256:$src1,
           (EXTRACT_get_vextractf128_imm VR128:$ext))>;
def : Pat<(alignedstore (v4i32 (vextractf128_extract:$ext (v8i32 VR256:$src1),
                                (iPTR imm))), addr:$dst),
          (VEXTRACTI128mr addr:$dst, VR256:$src1,
           (EXTRACT_get_vextractf128_imm VR128:$ext))>;
def : Pat<(alignedstore (v8i16 (vextractf128_extract:$ext (v16i16 VR256:$src1),
                                (iPTR imm))), addr:$dst),
          (VEXTRACTI128mr addr:$dst, VR256:$src1,
           (EXTRACT_get_vextractf128_imm VR128:$ext))>;
def : Pat<(alignedstore (v16i8 (vextractf128_extract:$ext (v32i8 VR256:$src1),
                                (iPTR imm))), addr:$dst),
          (VEXTRACTI128mr addr:$dst, VR256:$src1,
           (EXTRACT_get_vextractf128_imm VR128:$ext))>;
}

//===----------------------------------------------------------------------===//
// VPMASKMOV - Conditional SIMD Integer Packed Loads and Stores
//
multiclass avx2_pmovmask<string OpcodeStr,
                         Intrinsic IntLd128, Intrinsic IntLd256,
                         Intrinsic IntSt128, Intrinsic IntSt256> {
  def rm  : AVX28I<0x8c, MRMSrcMem, (outs VR128:$dst),
             (ins VR128:$src1, i128mem:$src2),
             !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
             [(set VR128:$dst, (IntLd128 addr:$src2, VR128:$src1))]>, VEX_4V;
  def Yrm : AVX28I<0x8c, MRMSrcMem, (outs VR256:$dst),
             (ins VR256:$src1, i256mem:$src2),
             !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
             [(set VR256:$dst, (IntLd256 addr:$src2, VR256:$src1))]>,
             VEX_4V, VEX_L;
  def mr  : AVX28I<0x8e, MRMDestMem, (outs),
             (ins i128mem:$dst, VR128:$src1, VR128:$src2),
             !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
             [(IntSt128 addr:$dst, VR128:$src1, VR128:$src2)]>, VEX_4V;
  def Ymr : AVX28I<0x8e, MRMDestMem, (outs),
             (ins i256mem:$dst, VR256:$src1, VR256:$src2),
             !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
             [(IntSt256 addr:$dst, VR256:$src1, VR256:$src2)]>, VEX_4V, VEX_L;
}

defm VPMASKMOVD : avx2_pmovmask<"vpmaskmovd",
                                int_x86_avx2_maskload_d,
                                int_x86_avx2_maskload_d_256,
                                int_x86_avx2_maskstore_d,
                                int_x86_avx2_maskstore_d_256>;
defm VPMASKMOVQ : avx2_pmovmask<"vpmaskmovq",
                                int_x86_avx2_maskload_q,
                                int_x86_avx2_maskload_q_256,
                                int_x86_avx2_maskstore_q,
                                int_x86_avx2_maskstore_q_256>, VEX_W;


//===----------------------------------------------------------------------===//
// Variable Bit Shifts
//
multiclass avx2_var_shift<bits<8> opc, string OpcodeStr, SDNode OpNode,
                          ValueType vt128, ValueType vt256> {
  def rr  : AVX28I<opc, MRMSrcReg, (outs VR128:$dst),
             (ins VR128:$src1, VR128:$src2),
             !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
             [(set VR128:$dst,
               (vt128 (OpNode VR128:$src1, (vt128 VR128:$src2))))]>,
             VEX_4V;
  def rm  : AVX28I<opc, MRMSrcMem, (outs VR128:$dst),
             (ins VR128:$src1, i128mem:$src2),
             !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
             [(set VR128:$dst,
               (vt128 (OpNode VR128:$src1,
                       (vt128 (bitconvert (memopv2i64 addr:$src2))))))]>,
             VEX_4V;
  def Yrr : AVX28I<opc, MRMSrcReg, (outs VR256:$dst),
             (ins VR256:$src1, VR256:$src2),
             !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
             [(set VR256:$dst,
               (vt256 (OpNode VR256:$src1, (vt256 VR256:$src2))))]>,
             VEX_4V, VEX_L;
  def Yrm : AVX28I<opc, MRMSrcMem, (outs VR256:$dst),
             (ins VR256:$src1, i256mem:$src2),
             !strconcat(OpcodeStr, "\t{$src2, $src1, $dst|$dst, $src1, $src2}"),
             [(set VR256:$dst,
               (vt256 (OpNode VR256:$src1,
                       (vt256 (bitconvert (memopv4i64 addr:$src2))))))]>,
             VEX_4V, VEX_L;
}

defm VPSLLVD : avx2_var_shift<0x47, "vpsllvd", shl, v4i32, v8i32>;
defm VPSLLVQ : avx2_var_shift<0x47, "vpsllvq", shl, v2i64, v4i64>, VEX_W;
defm VPSRLVD : avx2_var_shift<0x45, "vpsrlvd", srl, v4i32, v8i32>;
defm VPSRLVQ : avx2_var_shift<0x45, "vpsrlvq", srl, v2i64, v4i64>, VEX_W;
defm VPSRAVD : avx2_var_shift<0x46, "vpsravd", sra, v4i32, v8i32>;

//===----------------------------------------------------------------------===//
// VGATHER - GATHER Operations
multiclass avx2_gather<bits<8> opc, string OpcodeStr, RegisterClass RC256,
                       X86MemOperand memop128, X86MemOperand memop256> {
  def rm  : AVX28I<opc, MRMSrcMem, (outs VR128:$dst, VR128:$mask_wb),
            (ins VR128:$src1, memop128:$src2, VR128:$mask),
            !strconcat(OpcodeStr,
              "\t{$mask, $src2, $dst|$dst, $src2, $mask}"),
            []>, VEX_4VOp3;
  def Yrm : AVX28I<opc, MRMSrcMem, (outs RC256:$dst, RC256:$mask_wb),
            (ins RC256:$src1, memop256:$src2, RC256:$mask),
            !strconcat(OpcodeStr,
              "\t{$mask, $src2, $dst|$dst, $src2, $mask}"),
            []>, VEX_4VOp3, VEX_L;
}

let mayLoad = 1, Constraints
  = "@earlyclobber $dst,@earlyclobber $mask_wb, $src1 = $dst, $mask = $mask_wb"
  in {
  defm VGATHERDPD : avx2_gather<0x92, "vgatherdpd", VR256, vx64mem, vx64mem>, VEX_W;
  defm VGATHERQPD : avx2_gather<0x93, "vgatherqpd", VR256, vx64mem, vy64mem>, VEX_W;
  defm VGATHERDPS : avx2_gather<0x92, "vgatherdps", VR256, vx32mem, vy32mem>;
  defm VGATHERQPS : avx2_gather<0x93, "vgatherqps", VR128, vx32mem, vy32mem>;
  defm VPGATHERDQ : avx2_gather<0x90, "vpgatherdq", VR256, vx64mem, vx64mem>, VEX_W;
  defm VPGATHERQQ : avx2_gather<0x91, "vpgatherqq", VR256, vx64mem, vy64mem>, VEX_W;
  defm VPGATHERDD : avx2_gather<0x90, "vpgatherdd", VR256, vx32mem, vy32mem>;
  defm VPGATHERQD : avx2_gather<0x91, "vpgatherqd", VR128, vx32mem, vy32mem>;
}
//===-- ARMInstrNEON.td - NEON support for ARM -------------*- tablegen -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file describes the ARM NEON instruction set.
//
//===----------------------------------------------------------------------===//


//===----------------------------------------------------------------------===//
// NEON-specific Operands.
//===----------------------------------------------------------------------===//
def nModImm : Operand<i32> {
  let PrintMethod = "printNEONModImmOperand";
}

def nImmSplatI8AsmOperand : AsmOperandClass { let Name = "NEONi8splat"; }
def nImmSplatI8 : Operand<i32> {
  let PrintMethod = "printNEONModImmOperand";
  let ParserMatchClass = nImmSplatI8AsmOperand;
}
def nImmSplatI16AsmOperand : AsmOperandClass { let Name = "NEONi16splat"; }
def nImmSplatI16 : Operand<i32> {
  let PrintMethod = "printNEONModImmOperand";
  let ParserMatchClass = nImmSplatI16AsmOperand;
}
def nImmSplatI32AsmOperand : AsmOperandClass { let Name = "NEONi32splat"; }
def nImmSplatI32 : Operand<i32> {
  let PrintMethod = "printNEONModImmOperand";
  let ParserMatchClass = nImmSplatI32AsmOperand;
}
def nImmVMOVI32AsmOperand : AsmOperandClass { let Name = "NEONi32vmov"; }
def nImmVMOVI32 : Operand<i32> {
  let PrintMethod = "printNEONModImmOperand";
  let ParserMatchClass = nImmVMOVI32AsmOperand;
}
def nImmVMOVI32NegAsmOperand : AsmOperandClass { let Name = "NEONi32vmovNeg"; }
def nImmVMOVI32Neg : Operand<i32> {
  let PrintMethod = "printNEONModImmOperand";
  let ParserMatchClass = nImmVMOVI32NegAsmOperand;
}
def nImmVMOVF32 : Operand<i32> {
  let PrintMethod = "printFPImmOperand";
  let ParserMatchClass = FPImmOperand;
}
def nImmSplatI64AsmOperand : AsmOperandClass { let Name = "NEONi64splat"; }
def nImmSplatI64 : Operand<i32> {
  let PrintMethod = "printNEONModImmOperand";
  let ParserMatchClass = nImmSplatI64AsmOperand;
}

def VectorIndex8Operand  : AsmOperandClass { let Name = "VectorIndex8"; }
def VectorIndex16Operand : AsmOperandClass { let Name = "VectorIndex16"; }
def VectorIndex32Operand : AsmOperandClass { let Name = "VectorIndex32"; }
def VectorIndex8 : Operand<i32>, ImmLeaf<i32, [{
  return ((uint64_t)Imm) < 8;
}]> {
  let ParserMatchClass = VectorIndex8Operand;
  let PrintMethod = "printVectorIndex";
  let MIOperandInfo = (ops i32imm);
}
def VectorIndex16 : Operand<i32>, ImmLeaf<i32, [{
  return ((uint64_t)Imm) < 4;
}]> {
  let ParserMatchClass = VectorIndex16Operand;
  let PrintMethod = "printVectorIndex";
  let MIOperandInfo = (ops i32imm);
}
def VectorIndex32 : Operand<i32>, ImmLeaf<i32, [{
  return ((uint64_t)Imm) < 2;
}]> {
  let ParserMatchClass = VectorIndex32Operand;
  let PrintMethod = "printVectorIndex";
  let MIOperandInfo = (ops i32imm);
}

// Register list of one D register.
def VecListOneDAsmOperand : AsmOperandClass {
  let Name = "VecListOneD";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListOperands";
}
def VecListOneD : RegisterOperand<DPR, "printVectorListOne"> {
  let ParserMatchClass = VecListOneDAsmOperand;
}
// Register list of two sequential D registers.
def VecListDPairAsmOperand : AsmOperandClass {
  let Name = "VecListDPair";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListOperands";
}
def VecListDPair : RegisterOperand<DPair, "printVectorListTwo"> {
  let ParserMatchClass = VecListDPairAsmOperand;
}
// Register list of three sequential D registers.
def VecListThreeDAsmOperand : AsmOperandClass {
  let Name = "VecListThreeD";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListOperands";
}
def VecListThreeD : RegisterOperand<DPR, "printVectorListThree"> {
  let ParserMatchClass = VecListThreeDAsmOperand;
}
// Register list of four sequential D registers.
def VecListFourDAsmOperand : AsmOperandClass {
  let Name = "VecListFourD";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListOperands";
}
def VecListFourD : RegisterOperand<DPR, "printVectorListFour"> {
  let ParserMatchClass = VecListFourDAsmOperand;
}
// Register list of two D registers spaced by 2 (two sequential Q registers).
def VecListDPairSpacedAsmOperand : AsmOperandClass {
  let Name = "VecListDPairSpaced";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListOperands";
}
def VecListDPairSpaced : RegisterOperand<DPair, "printVectorListTwoSpaced"> {
  let ParserMatchClass = VecListDPairSpacedAsmOperand;
}
// Register list of three D registers spaced by 2 (three Q registers).
def VecListThreeQAsmOperand : AsmOperandClass {
  let Name = "VecListThreeQ";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListOperands";
}
def VecListThreeQ : RegisterOperand<DPR, "printVectorListThreeSpaced"> {
  let ParserMatchClass = VecListThreeQAsmOperand;
}
// Register list of three D registers spaced by 2 (three Q registers).
def VecListFourQAsmOperand : AsmOperandClass {
  let Name = "VecListFourQ";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListOperands";
}
def VecListFourQ : RegisterOperand<DPR, "printVectorListFourSpaced"> {
  let ParserMatchClass = VecListFourQAsmOperand;
}

// Register list of one D register, with "all lanes" subscripting.
def VecListOneDAllLanesAsmOperand : AsmOperandClass {
  let Name = "VecListOneDAllLanes";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListOperands";
}
def VecListOneDAllLanes : RegisterOperand<DPR, "printVectorListOneAllLanes"> {
  let ParserMatchClass = VecListOneDAllLanesAsmOperand;
}
// Register list of two D registers, with "all lanes" subscripting.
def VecListDPairAllLanesAsmOperand : AsmOperandClass {
  let Name = "VecListDPairAllLanes";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListOperands";
}
def VecListDPairAllLanes : RegisterOperand<DPair,
                                           "printVectorListTwoAllLanes"> {
  let ParserMatchClass = VecListDPairAllLanesAsmOperand;
}
// Register list of two D registers spaced by 2 (two sequential Q registers).
def VecListDPairSpacedAllLanesAsmOperand : AsmOperandClass {
  let Name = "VecListDPairSpacedAllLanes";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListOperands";
}
def VecListDPairSpacedAllLanes : RegisterOperand<DPair,
                                         "printVectorListTwoSpacedAllLanes"> {
  let ParserMatchClass = VecListDPairSpacedAllLanesAsmOperand;
}
// Register list of three D registers, with "all lanes" subscripting.
def VecListThreeDAllLanesAsmOperand : AsmOperandClass {
  let Name = "VecListThreeDAllLanes";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListOperands";
}
def VecListThreeDAllLanes : RegisterOperand<DPR,
                                            "printVectorListThreeAllLanes"> {
  let ParserMatchClass = VecListThreeDAllLanesAsmOperand;
}
// Register list of three D registers spaced by 2 (three sequential Q regs).
def VecListThreeQAllLanesAsmOperand : AsmOperandClass {
  let Name = "VecListThreeQAllLanes";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListOperands";
}
def VecListThreeQAllLanes : RegisterOperand<DPR,
                                         "printVectorListThreeSpacedAllLanes"> {
  let ParserMatchClass = VecListThreeQAllLanesAsmOperand;
}
// Register list of four D registers, with "all lanes" subscripting.
def VecListFourDAllLanesAsmOperand : AsmOperandClass {
  let Name = "VecListFourDAllLanes";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListOperands";
}
def VecListFourDAllLanes : RegisterOperand<DPR, "printVectorListFourAllLanes"> {
  let ParserMatchClass = VecListFourDAllLanesAsmOperand;
}
// Register list of four D registers spaced by 2 (four sequential Q regs).
def VecListFourQAllLanesAsmOperand : AsmOperandClass {
  let Name = "VecListFourQAllLanes";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListOperands";
}
def VecListFourQAllLanes : RegisterOperand<DPR,
                                         "printVectorListFourSpacedAllLanes"> {
  let ParserMatchClass = VecListFourQAllLanesAsmOperand;
}


// Register list of one D register, with byte lane subscripting.
def VecListOneDByteIndexAsmOperand : AsmOperandClass {
  let Name = "VecListOneDByteIndexed";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListIndexedOperands";
}
def VecListOneDByteIndexed : Operand<i32> {
  let ParserMatchClass = VecListOneDByteIndexAsmOperand;
  let MIOperandInfo = (ops DPR:$Vd, i32imm:$idx);
}
// ...with half-word lane subscripting.
def VecListOneDHWordIndexAsmOperand : AsmOperandClass {
  let Name = "VecListOneDHWordIndexed";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListIndexedOperands";
}
def VecListOneDHWordIndexed : Operand<i32> {
  let ParserMatchClass = VecListOneDHWordIndexAsmOperand;
  let MIOperandInfo = (ops DPR:$Vd, i32imm:$idx);
}
// ...with word lane subscripting.
def VecListOneDWordIndexAsmOperand : AsmOperandClass {
  let Name = "VecListOneDWordIndexed";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListIndexedOperands";
}
def VecListOneDWordIndexed : Operand<i32> {
  let ParserMatchClass = VecListOneDWordIndexAsmOperand;
  let MIOperandInfo = (ops DPR:$Vd, i32imm:$idx);
}

// Register list of two D registers with byte lane subscripting.
def VecListTwoDByteIndexAsmOperand : AsmOperandClass {
  let Name = "VecListTwoDByteIndexed";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListIndexedOperands";
}
def VecListTwoDByteIndexed : Operand<i32> {
  let ParserMatchClass = VecListTwoDByteIndexAsmOperand;
  let MIOperandInfo = (ops DPR:$Vd, i32imm:$idx);
}
// ...with half-word lane subscripting.
def VecListTwoDHWordIndexAsmOperand : AsmOperandClass {
  let Name = "VecListTwoDHWordIndexed";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListIndexedOperands";
}
def VecListTwoDHWordIndexed : Operand<i32> {
  let ParserMatchClass = VecListTwoDHWordIndexAsmOperand;
  let MIOperandInfo = (ops DPR:$Vd, i32imm:$idx);
}
// ...with word lane subscripting.
def VecListTwoDWordIndexAsmOperand : AsmOperandClass {
  let Name = "VecListTwoDWordIndexed";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListIndexedOperands";
}
def VecListTwoDWordIndexed : Operand<i32> {
  let ParserMatchClass = VecListTwoDWordIndexAsmOperand;
  let MIOperandInfo = (ops DPR:$Vd, i32imm:$idx);
}
// Register list of two Q registers with half-word lane subscripting.
def VecListTwoQHWordIndexAsmOperand : AsmOperandClass {
  let Name = "VecListTwoQHWordIndexed";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListIndexedOperands";
}
def VecListTwoQHWordIndexed : Operand<i32> {
  let ParserMatchClass = VecListTwoQHWordIndexAsmOperand;
  let MIOperandInfo = (ops DPR:$Vd, i32imm:$idx);
}
// ...with word lane subscripting.
def VecListTwoQWordIndexAsmOperand : AsmOperandClass {
  let Name = "VecListTwoQWordIndexed";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListIndexedOperands";
}
def VecListTwoQWordIndexed : Operand<i32> {
  let ParserMatchClass = VecListTwoQWordIndexAsmOperand;
  let MIOperandInfo = (ops DPR:$Vd, i32imm:$idx);
}


// Register list of three D registers with byte lane subscripting.
def VecListThreeDByteIndexAsmOperand : AsmOperandClass {
  let Name = "VecListThreeDByteIndexed";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListIndexedOperands";
}
def VecListThreeDByteIndexed : Operand<i32> {
  let ParserMatchClass = VecListThreeDByteIndexAsmOperand;
  let MIOperandInfo = (ops DPR:$Vd, i32imm:$idx);
}
// ...with half-word lane subscripting.
def VecListThreeDHWordIndexAsmOperand : AsmOperandClass {
  let Name = "VecListThreeDHWordIndexed";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListIndexedOperands";
}
def VecListThreeDHWordIndexed : Operand<i32> {
  let ParserMatchClass = VecListThreeDHWordIndexAsmOperand;
  let MIOperandInfo = (ops DPR:$Vd, i32imm:$idx);
}
// ...with word lane subscripting.
def VecListThreeDWordIndexAsmOperand : AsmOperandClass {
  let Name = "VecListThreeDWordIndexed";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListIndexedOperands";
}
def VecListThreeDWordIndexed : Operand<i32> {
  let ParserMatchClass = VecListThreeDWordIndexAsmOperand;
  let MIOperandInfo = (ops DPR:$Vd, i32imm:$idx);
}
// Register list of three Q registers with half-word lane subscripting.
def VecListThreeQHWordIndexAsmOperand : AsmOperandClass {
  let Name = "VecListThreeQHWordIndexed";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListIndexedOperands";
}
def VecListThreeQHWordIndexed : Operand<i32> {
  let ParserMatchClass = VecListThreeQHWordIndexAsmOperand;
  let MIOperandInfo = (ops DPR:$Vd, i32imm:$idx);
}
// ...with word lane subscripting.
def VecListThreeQWordIndexAsmOperand : AsmOperandClass {
  let Name = "VecListThreeQWordIndexed";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListIndexedOperands";
}
def VecListThreeQWordIndexed : Operand<i32> {
  let ParserMatchClass = VecListThreeQWordIndexAsmOperand;
  let MIOperandInfo = (ops DPR:$Vd, i32imm:$idx);
}

// Register list of four D registers with byte lane subscripting.
def VecListFourDByteIndexAsmOperand : AsmOperandClass {
  let Name = "VecListFourDByteIndexed";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListIndexedOperands";
}
def VecListFourDByteIndexed : Operand<i32> {
  let ParserMatchClass = VecListFourDByteIndexAsmOperand;
  let MIOperandInfo = (ops DPR:$Vd, i32imm:$idx);
}
// ...with half-word lane subscripting.
def VecListFourDHWordIndexAsmOperand : AsmOperandClass {
  let Name = "VecListFourDHWordIndexed";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListIndexedOperands";
}
def VecListFourDHWordIndexed : Operand<i32> {
  let ParserMatchClass = VecListFourDHWordIndexAsmOperand;
  let MIOperandInfo = (ops DPR:$Vd, i32imm:$idx);
}
// ...with word lane subscripting.
def VecListFourDWordIndexAsmOperand : AsmOperandClass {
  let Name = "VecListFourDWordIndexed";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListIndexedOperands";
}
def VecListFourDWordIndexed : Operand<i32> {
  let ParserMatchClass = VecListFourDWordIndexAsmOperand;
  let MIOperandInfo = (ops DPR:$Vd, i32imm:$idx);
}
// Register list of four Q registers with half-word lane subscripting.
def VecListFourQHWordIndexAsmOperand : AsmOperandClass {
  let Name = "VecListFourQHWordIndexed";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListIndexedOperands";
}
def VecListFourQHWordIndexed : Operand<i32> {
  let ParserMatchClass = VecListFourQHWordIndexAsmOperand;
  let MIOperandInfo = (ops DPR:$Vd, i32imm:$idx);
}
// ...with word lane subscripting.
def VecListFourQWordIndexAsmOperand : AsmOperandClass {
  let Name = "VecListFourQWordIndexed";
  let ParserMethod = "parseVectorList";
  let RenderMethod = "addVecListIndexedOperands";
}
def VecListFourQWordIndexed : Operand<i32> {
  let ParserMatchClass = VecListFourQWordIndexAsmOperand;
  let MIOperandInfo = (ops DPR:$Vd, i32imm:$idx);
}

def dword_alignedload : PatFrag<(ops node:$ptr), (load node:$ptr), [{
  return cast<LoadSDNode>(N)->getAlignment() >= 8;
}]>;
def dword_alignedstore : PatFrag<(ops node:$val, node:$ptr),
                                 (store node:$val, node:$ptr), [{
  return cast<StoreSDNode>(N)->getAlignment() >= 8;
}]>;
def word_alignedload : PatFrag<(ops node:$ptr), (load node:$ptr), [{
  return cast<LoadSDNode>(N)->getAlignment() == 4;
}]>;
def word_alignedstore : PatFrag<(ops node:$val, node:$ptr),
                                 (store node:$val, node:$ptr), [{
  return cast<StoreSDNode>(N)->getAlignment() == 4;
}]>;
def hword_alignedload : PatFrag<(ops node:$ptr), (load node:$ptr), [{
  return cast<LoadSDNode>(N)->getAlignment() == 2;
}]>;
def hword_alignedstore : PatFrag<(ops node:$val, node:$ptr),
                                 (store node:$val, node:$ptr), [{
  return cast<StoreSDNode>(N)->getAlignment() == 2;
}]>;
def byte_alignedload : PatFrag<(ops node:$ptr), (load node:$ptr), [{
  return cast<LoadSDNode>(N)->getAlignment() == 1;
}]>;
def byte_alignedstore : PatFrag<(ops node:$val, node:$ptr),
                             (store node:$val, node:$ptr), [{
  return cast<StoreSDNode>(N)->getAlignment() == 1;
}]>;
def non_word_alignedload : PatFrag<(ops node:$ptr), (load node:$ptr), [{
  return cast<LoadSDNode>(N)->getAlignment() < 4;
}]>;
def non_word_alignedstore : PatFrag<(ops node:$val, node:$ptr),
                                    (store node:$val, node:$ptr), [{
  return cast<StoreSDNode>(N)->getAlignment() < 4;
}]>;

//===----------------------------------------------------------------------===//
// NEON-specific DAG Nodes.
//===----------------------------------------------------------------------===//

def SDTARMVCMP    : SDTypeProfile<1, 2, [SDTCisInt<0>, SDTCisSameAs<1, 2>]>;
def SDTARMVCMPZ   : SDTypeProfile<1, 1, []>;

def NEONvceq      : SDNode<"ARMISD::VCEQ", SDTARMVCMP>;
def NEONvceqz     : SDNode<"ARMISD::VCEQZ", SDTARMVCMPZ>;
def NEONvcge      : SDNode<"ARMISD::VCGE", SDTARMVCMP>;
def NEONvcgez     : SDNode<"ARMISD::VCGEZ", SDTARMVCMPZ>;
def NEONvclez     : SDNode<"ARMISD::VCLEZ", SDTARMVCMPZ>;
def NEONvcgeu     : SDNode<"ARMISD::VCGEU", SDTARMVCMP>;
def NEONvcgt      : SDNode<"ARMISD::VCGT", SDTARMVCMP>;
def NEONvcgtz     : SDNode<"ARMISD::VCGTZ", SDTARMVCMPZ>;
def NEONvcltz     : SDNode<"ARMISD::VCLTZ", SDTARMVCMPZ>;
def NEONvcgtu     : SDNode<"ARMISD::VCGTU", SDTARMVCMP>;
def NEONvtst      : SDNode<"ARMISD::VTST", SDTARMVCMP>;

// Types for vector shift by immediates.  The "SHX" version is for long and
// narrow operations where the source and destination vectors have different
// types.  The "SHINS" version is for shift and insert operations.
def SDTARMVSH     : SDTypeProfile<1, 2, [SDTCisInt<0>, SDTCisSameAs<0, 1>,
                                         SDTCisVT<2, i32>]>;
def SDTARMVSHX    : SDTypeProfile<1, 2, [SDTCisInt<0>, SDTCisInt<1>,
                                         SDTCisVT<2, i32>]>;
def SDTARMVSHINS  : SDTypeProfile<1, 3, [SDTCisInt<0>, SDTCisSameAs<0, 1>,
                                         SDTCisSameAs<0, 2>, SDTCisVT<3, i32>]>;

def NEONvshl      : SDNode<"ARMISD::VSHL", SDTARMVSH>;
def NEONvshrs     : SDNode<"ARMISD::VSHRs", SDTARMVSH>;
def NEONvshru     : SDNode<"ARMISD::VSHRu", SDTARMVSH>;
def NEONvshlls    : SDNode<"ARMISD::VSHLLs", SDTARMVSHX>;
def NEONvshllu    : SDNode<"ARMISD::VSHLLu", SDTARMVSHX>;
def NEONvshlli    : SDNode<"ARMISD::VSHLLi", SDTARMVSHX>;
def NEONvshrn     : SDNode<"ARMISD::VSHRN", SDTARMVSHX>;

def NEONvrshrs    : SDNode<"ARMISD::VRSHRs", SDTARMVSH>;
def NEONvrshru    : SDNode<"ARMISD::VRSHRu", SDTARMVSH>;
def NEONvrshrn    : SDNode<"ARMISD::VRSHRN", SDTARMVSHX>;

def NEONvqshls    : SDNode<"ARMISD::VQSHLs", SDTARMVSH>;
def NEONvqshlu    : SDNode<"ARMISD::VQSHLu", SDTARMVSH>;
def NEONvqshlsu   : SDNode<"ARMISD::VQSHLsu", SDTARMVSH>;
def NEONvqshrns   : SDNode<"ARMISD::VQSHRNs", SDTARMVSHX>;
def NEONvqshrnu   : SDNode<"ARMISD::VQSHRNu", SDTARMVSHX>;
def NEONvqshrnsu  : SDNode<"ARMISD::VQSHRNsu", SDTARMVSHX>;

def NEONvqrshrns  : SDNode<"ARMISD::VQRSHRNs", SDTARMVSHX>;
def NEONvqrshrnu  : SDNode<"ARMISD::VQRSHRNu", SDTARMVSHX>;
def NEONvqrshrnsu : SDNode<"ARMISD::VQRSHRNsu", SDTARMVSHX>;

def NEONvsli      : SDNode<"ARMISD::VSLI", SDTARMVSHINS>;
def NEONvsri      : SDNode<"ARMISD::VSRI", SDTARMVSHINS>;

def SDTARMVGETLN  : SDTypeProfile<1, 2, [SDTCisVT<0, i32>, SDTCisInt<1>,
                                         SDTCisVT<2, i32>]>;
def NEONvgetlaneu : SDNode<"ARMISD::VGETLANEu", SDTARMVGETLN>;
def NEONvgetlanes : SDNode<"ARMISD::VGETLANEs", SDTARMVGETLN>;

def SDTARMVMOVIMM : SDTypeProfile<1, 1, [SDTCisVec<0>, SDTCisVT<1, i32>]>;
def NEONvmovImm   : SDNode<"ARMISD::VMOVIMM", SDTARMVMOVIMM>;
def NEONvmvnImm   : SDNode<"ARMISD::VMVNIMM", SDTARMVMOVIMM>;
def NEONvmovFPImm : SDNode<"ARMISD::VMOVFPIMM", SDTARMVMOVIMM>;

def SDTARMVORRIMM : SDTypeProfile<1, 2, [SDTCisVec<0>, SDTCisSameAs<0, 1>,
                                           SDTCisVT<2, i32>]>;
def NEONvorrImm   : SDNode<"ARMISD::VORRIMM", SDTARMVORRIMM>;
def NEONvbicImm   : SDNode<"ARMISD::VBICIMM", SDTARMVORRIMM>;

def NEONvbsl      : SDNode<"ARMISD::VBSL",
                           SDTypeProfile<1, 3, [SDTCisVec<0>,
                                                SDTCisSameAs<0, 1>,
                                                SDTCisSameAs<0, 2>,
                                                SDTCisSameAs<0, 3>]>>;

def NEONvdup      : SDNode<"ARMISD::VDUP", SDTypeProfile<1, 1, [SDTCisVec<0>]>>;

// VDUPLANE can produce a quad-register result from a double-register source,
// so the result is not constrained to match the source.
def NEONvduplane  : SDNode<"ARMISD::VDUPLANE",
                           SDTypeProfile<1, 2, [SDTCisVec<0>, SDTCisVec<1>,
                                                SDTCisVT<2, i32>]>>;

def SDTARMVEXT    : SDTypeProfile<1, 3, [SDTCisVec<0>, SDTCisSameAs<0, 1>,
                                         SDTCisSameAs<0, 2>, SDTCisVT<3, i32>]>;
def NEONvext      : SDNode<"ARMISD::VEXT", SDTARMVEXT>;

def SDTARMVSHUF   : SDTypeProfile<1, 1, [SDTCisVec<0>, SDTCisSameAs<0, 1>]>;
def NEONvrev64    : SDNode<"ARMISD::VREV64", SDTARMVSHUF>;
def NEONvrev32    : SDNode<"ARMISD::VREV32", SDTARMVSHUF>;
def NEONvrev16    : SDNode<"ARMISD::VREV16", SDTARMVSHUF>;

def SDTARMVSHUF2  : SDTypeProfile<2, 2, [SDTCisVec<0>, SDTCisSameAs<0, 1>,
                                         SDTCisSameAs<0, 2>,
                                         SDTCisSameAs<0, 3>]>;
def NEONzip       : SDNode<"ARMISD::VZIP", SDTARMVSHUF2>;
def NEONuzp       : SDNode<"ARMISD::VUZP", SDTARMVSHUF2>;
def NEONtrn       : SDNode<"ARMISD::VTRN", SDTARMVSHUF2>;

def SDTARMVMULL   : SDTypeProfile<1, 2, [SDTCisInt<0>, SDTCisInt<1>,
                                         SDTCisSameAs<1, 2>]>;
def NEONvmulls    : SDNode<"ARMISD::VMULLs", SDTARMVMULL>;
def NEONvmullu    : SDNode<"ARMISD::VMULLu", SDTARMVMULL>;

def SDTARMFMAX    : SDTypeProfile<1, 2, [SDTCisVT<0, f32>, SDTCisSameAs<0, 1>,
                                         SDTCisSameAs<0, 2>]>;
def NEONfmax      : SDNode<"ARMISD::FMAX", SDTARMFMAX>;
def NEONfmin      : SDNode<"ARMISD::FMIN", SDTARMFMAX>;

def NEONimmAllZerosV: PatLeaf<(NEONvmovImm (i32 timm)), [{
  ConstantSDNode *ConstVal = cast<ConstantSDNode>(N->getOperand(0));
  unsigned EltBits = 0;
  uint64_t EltVal = ARM_AM::decodeNEONModImm(ConstVal->getZExtValue(), EltBits);
  return (EltBits == 32 && EltVal == 0);
}]>;

def NEONimmAllOnesV: PatLeaf<(NEONvmovImm (i32 timm)), [{
  ConstantSDNode *ConstVal = cast<ConstantSDNode>(N->getOperand(0));
  unsigned EltBits = 0;
  uint64_t EltVal = ARM_AM::decodeNEONModImm(ConstVal->getZExtValue(), EltBits);
  return (EltBits == 8 && EltVal == 0xff);
}]>;

//===----------------------------------------------------------------------===//
// NEON load / store instructions
//===----------------------------------------------------------------------===//

// Use VLDM to load a Q register as a D register pair.
// This is a pseudo instruction that is expanded to VLDMD after reg alloc.
def VLDMQIA
  : PseudoVFPLdStM<(outs DPair:$dst), (ins GPR:$Rn),
                    IIC_fpLoad_m, "",
                   [(set DPair:$dst, (v2f64 (load GPR:$Rn)))]>;

// Use VSTM to store a Q register as a D register pair.
// This is a pseudo instruction that is expanded to VSTMD after reg alloc.
def VSTMQIA
  : PseudoVFPLdStM<(outs), (ins DPair:$src, GPR:$Rn),
                    IIC_fpStore_m, "",
                   [(store (v2f64 DPair:$src), GPR:$Rn)]>;

// Classes for VLD* pseudo-instructions with multi-register operands.
// These are expanded to real instructions after register allocation.
class VLDQPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs QPR:$dst), (ins addrmode6:$addr), itin, "">;
class VLDQWBPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs QPR:$dst, GPR:$wb),
                (ins addrmode6:$addr, am6offset:$offset), itin,
                "$addr.addr = $wb">;
class VLDQWBfixedPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs QPR:$dst, GPR:$wb),
                (ins addrmode6:$addr), itin,
                "$addr.addr = $wb">;
class VLDQWBregisterPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs QPR:$dst, GPR:$wb),
                (ins addrmode6:$addr, rGPR:$offset), itin,
                "$addr.addr = $wb">;

class VLDQQPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs QQPR:$dst), (ins addrmode6:$addr), itin, "">;
class VLDQQWBPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs QQPR:$dst, GPR:$wb),
                (ins addrmode6:$addr, am6offset:$offset), itin,
                "$addr.addr = $wb">;
class VLDQQWBfixedPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs QQPR:$dst, GPR:$wb),
                (ins addrmode6:$addr), itin,
                "$addr.addr = $wb">;
class VLDQQWBregisterPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs QQPR:$dst, GPR:$wb),
                (ins addrmode6:$addr, rGPR:$offset), itin,
                "$addr.addr = $wb">;


class VLDQQQQPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs QQQQPR:$dst), (ins addrmode6:$addr, QQQQPR:$src),itin,
                "$src = $dst">;
class VLDQQQQWBPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs QQQQPR:$dst, GPR:$wb),
                (ins addrmode6:$addr, am6offset:$offset, QQQQPR:$src), itin,
                "$addr.addr = $wb, $src = $dst">;

let mayLoad = 1, neverHasSideEffects = 1, hasExtraDefRegAllocReq = 1 in {

//   VLD1     : Vector Load (multiple single elements)
class VLD1D<bits<4> op7_4, string Dt>
  : NLdSt<0,0b10,0b0111,op7_4, (outs VecListOneD:$Vd),
          (ins addrmode6:$Rn), IIC_VLD1,
          "vld1", Dt, "$Vd, $Rn", "", []> {
  let Rm = 0b1111;
  let Inst{4} = Rn{4};
  let DecoderMethod = "DecodeVLDST1Instruction";
}
class VLD1Q<bits<4> op7_4, string Dt>
  : NLdSt<0,0b10,0b1010,op7_4, (outs VecListDPair:$Vd),
          (ins addrmode6:$Rn), IIC_VLD1x2,
          "vld1", Dt, "$Vd, $Rn", "", []> {
  let Rm = 0b1111;
  let Inst{5-4} = Rn{5-4};
  let DecoderMethod = "DecodeVLDST1Instruction";
}

def  VLD1d8   : VLD1D<{0,0,0,?}, "8">;
def  VLD1d16  : VLD1D<{0,1,0,?}, "16">;
def  VLD1d32  : VLD1D<{1,0,0,?}, "32">;
def  VLD1d64  : VLD1D<{1,1,0,?}, "64">;

def  VLD1q8   : VLD1Q<{0,0,?,?}, "8">;
def  VLD1q16  : VLD1Q<{0,1,?,?}, "16">;
def  VLD1q32  : VLD1Q<{1,0,?,?}, "32">;
def  VLD1q64  : VLD1Q<{1,1,?,?}, "64">;

// ...with address register writeback:
multiclass VLD1DWB<bits<4> op7_4, string Dt> {
  def _fixed : NLdSt<0,0b10, 0b0111,op7_4, (outs VecListOneD:$Vd, GPR:$wb),
                     (ins addrmode6:$Rn), IIC_VLD1u,
                     "vld1", Dt, "$Vd, $Rn!",
                     "$Rn.addr = $wb", []> {
    let Rm = 0b1101; // NLdSt will assign to the right encoding bits.
    let Inst{4} = Rn{4};
    let DecoderMethod = "DecodeVLDST1Instruction";
    let AsmMatchConverter = "cvtVLDwbFixed";
  }
  def _register : NLdSt<0,0b10,0b0111,op7_4, (outs VecListOneD:$Vd, GPR:$wb),
                        (ins addrmode6:$Rn, rGPR:$Rm), IIC_VLD1u,
                        "vld1", Dt, "$Vd, $Rn, $Rm",
                        "$Rn.addr = $wb", []> {
    let Inst{4} = Rn{4};
    let DecoderMethod = "DecodeVLDST1Instruction";
    let AsmMatchConverter = "cvtVLDwbRegister";
  }
}
multiclass VLD1QWB<bits<4> op7_4, string Dt> {
  def _fixed : NLdSt<0,0b10,0b1010,op7_4, (outs VecListDPair:$Vd, GPR:$wb),
                    (ins addrmode6:$Rn), IIC_VLD1x2u,
                     "vld1", Dt, "$Vd, $Rn!",
                     "$Rn.addr = $wb", []> {
    let Rm = 0b1101; // NLdSt will assign to the right encoding bits.
    let Inst{5-4} = Rn{5-4};
    let DecoderMethod = "DecodeVLDST1Instruction";
    let AsmMatchConverter = "cvtVLDwbFixed";
  }
  def _register : NLdSt<0,0b10,0b1010,op7_4, (outs VecListDPair:$Vd, GPR:$wb),
                        (ins addrmode6:$Rn, rGPR:$Rm), IIC_VLD1x2u,
                        "vld1", Dt, "$Vd, $Rn, $Rm",
                        "$Rn.addr = $wb", []> {
    let Inst{5-4} = Rn{5-4};
    let DecoderMethod = "DecodeVLDST1Instruction";
    let AsmMatchConverter = "cvtVLDwbRegister";
  }
}

defm VLD1d8wb  : VLD1DWB<{0,0,0,?}, "8">;
defm VLD1d16wb : VLD1DWB<{0,1,0,?}, "16">;
defm VLD1d32wb : VLD1DWB<{1,0,0,?}, "32">;
defm VLD1d64wb : VLD1DWB<{1,1,0,?}, "64">;
defm VLD1q8wb  : VLD1QWB<{0,0,?,?}, "8">;
defm VLD1q16wb : VLD1QWB<{0,1,?,?}, "16">;
defm VLD1q32wb : VLD1QWB<{1,0,?,?}, "32">;
defm VLD1q64wb : VLD1QWB<{1,1,?,?}, "64">;

// ...with 3 registers
class VLD1D3<bits<4> op7_4, string Dt>
  : NLdSt<0,0b10,0b0110,op7_4, (outs VecListThreeD:$Vd),
          (ins addrmode6:$Rn), IIC_VLD1x3, "vld1", Dt,
          "$Vd, $Rn", "", []> {
  let Rm = 0b1111;
  let Inst{4} = Rn{4};
  let DecoderMethod = "DecodeVLDST1Instruction";
}
multiclass VLD1D3WB<bits<4> op7_4, string Dt> {
  def _fixed : NLdSt<0,0b10,0b0110, op7_4, (outs VecListThreeD:$Vd, GPR:$wb),
                    (ins addrmode6:$Rn), IIC_VLD1x2u,
                     "vld1", Dt, "$Vd, $Rn!",
                     "$Rn.addr = $wb", []> {
    let Rm = 0b1101; // NLdSt will assign to the right encoding bits.
    let Inst{4} = Rn{4};
    let DecoderMethod = "DecodeVLDST1Instruction";
    let AsmMatchConverter = "cvtVLDwbFixed";
  }
  def _register : NLdSt<0,0b10,0b0110,op7_4, (outs VecListThreeD:$Vd, GPR:$wb),
                        (ins addrmode6:$Rn, rGPR:$Rm), IIC_VLD1x2u,
                        "vld1", Dt, "$Vd, $Rn, $Rm",
                        "$Rn.addr = $wb", []> {
    let Inst{4} = Rn{4};
    let DecoderMethod = "DecodeVLDST1Instruction";
    let AsmMatchConverter = "cvtVLDwbRegister";
  }
}

def VLD1d8T      : VLD1D3<{0,0,0,?}, "8">;
def VLD1d16T     : VLD1D3<{0,1,0,?}, "16">;
def VLD1d32T     : VLD1D3<{1,0,0,?}, "32">;
def VLD1d64T     : VLD1D3<{1,1,0,?}, "64">;

defm VLD1d8Twb  : VLD1D3WB<{0,0,0,?}, "8">;
defm VLD1d16Twb : VLD1D3WB<{0,1,0,?}, "16">;
defm VLD1d32Twb : VLD1D3WB<{1,0,0,?}, "32">;
defm VLD1d64Twb : VLD1D3WB<{1,1,0,?}, "64">;

def VLD1d64TPseudo : VLDQQPseudo<IIC_VLD1x3>;

// ...with 4 registers
class VLD1D4<bits<4> op7_4, string Dt>
  : NLdSt<0, 0b10, 0b0010, op7_4, (outs VecListFourD:$Vd),
          (ins addrmode6:$Rn), IIC_VLD1x4, "vld1", Dt,
          "$Vd, $Rn", "", []> {
  let Rm = 0b1111;
  let Inst{5-4} = Rn{5-4};
  let DecoderMethod = "DecodeVLDST1Instruction";
}
multiclass VLD1D4WB<bits<4> op7_4, string Dt> {
  def _fixed : NLdSt<0,0b10,0b0010, op7_4, (outs VecListFourD:$Vd, GPR:$wb),
                    (ins addrmode6:$Rn), IIC_VLD1x2u,
                     "vld1", Dt, "$Vd, $Rn!",
                     "$Rn.addr = $wb", []> {
    let Rm = 0b1101; // NLdSt will assign to the right encoding bits.
    let Inst{5-4} = Rn{5-4};
    let DecoderMethod = "DecodeVLDST1Instruction";
    let AsmMatchConverter = "cvtVLDwbFixed";
  }
  def _register : NLdSt<0,0b10,0b0010,op7_4, (outs VecListFourD:$Vd, GPR:$wb),
                        (ins addrmode6:$Rn, rGPR:$Rm), IIC_VLD1x2u,
                        "vld1", Dt, "$Vd, $Rn, $Rm",
                        "$Rn.addr = $wb", []> {
    let Inst{5-4} = Rn{5-4};
    let DecoderMethod = "DecodeVLDST1Instruction";
    let AsmMatchConverter = "cvtVLDwbRegister";
  }
}

def VLD1d8Q      : VLD1D4<{0,0,?,?}, "8">;
def VLD1d16Q     : VLD1D4<{0,1,?,?}, "16">;
def VLD1d32Q     : VLD1D4<{1,0,?,?}, "32">;
def VLD1d64Q     : VLD1D4<{1,1,?,?}, "64">;

defm VLD1d8Qwb   : VLD1D4WB<{0,0,?,?}, "8">;
defm VLD1d16Qwb  : VLD1D4WB<{0,1,?,?}, "16">;
defm VLD1d32Qwb  : VLD1D4WB<{1,0,?,?}, "32">;
defm VLD1d64Qwb  : VLD1D4WB<{1,1,?,?}, "64">;

def VLD1d64QPseudo : VLDQQPseudo<IIC_VLD1x4>;

//   VLD2     : Vector Load (multiple 2-element structures)
class VLD2<bits<4> op11_8, bits<4> op7_4, string Dt, RegisterOperand VdTy,
           InstrItinClass itin>
  : NLdSt<0, 0b10, op11_8, op7_4, (outs VdTy:$Vd),
          (ins addrmode6:$Rn), itin,
          "vld2", Dt, "$Vd, $Rn", "", []> {
  let Rm = 0b1111;
  let Inst{5-4} = Rn{5-4};
  let DecoderMethod = "DecodeVLDST2Instruction";
}

def  VLD2d8   : VLD2<0b1000, {0,0,?,?}, "8", VecListDPair, IIC_VLD2>;
def  VLD2d16  : VLD2<0b1000, {0,1,?,?}, "16", VecListDPair, IIC_VLD2>;
def  VLD2d32  : VLD2<0b1000, {1,0,?,?}, "32", VecListDPair, IIC_VLD2>;

def  VLD2q8   : VLD2<0b0011, {0,0,?,?}, "8", VecListFourD, IIC_VLD2x2>;
def  VLD2q16  : VLD2<0b0011, {0,1,?,?}, "16", VecListFourD, IIC_VLD2x2>;
def  VLD2q32  : VLD2<0b0011, {1,0,?,?}, "32", VecListFourD, IIC_VLD2x2>;

def  VLD2q8Pseudo  : VLDQQPseudo<IIC_VLD2x2>;
def  VLD2q16Pseudo : VLDQQPseudo<IIC_VLD2x2>;
def  VLD2q32Pseudo : VLDQQPseudo<IIC_VLD2x2>;

// ...with address register writeback:
multiclass VLD2WB<bits<4> op11_8, bits<4> op7_4, string Dt,
                  RegisterOperand VdTy, InstrItinClass itin> {
  def _fixed : NLdSt<0, 0b10, op11_8, op7_4, (outs VdTy:$Vd, GPR:$wb),
                     (ins addrmode6:$Rn), itin,
                     "vld2", Dt, "$Vd, $Rn!",
                     "$Rn.addr = $wb", []> {
    let Rm = 0b1101; // NLdSt will assign to the right encoding bits.
    let Inst{5-4} = Rn{5-4};
    let DecoderMethod = "DecodeVLDST2Instruction";
    let AsmMatchConverter = "cvtVLDwbFixed";
  }
  def _register : NLdSt<0, 0b10, op11_8, op7_4, (outs VdTy:$Vd, GPR:$wb),
                        (ins addrmode6:$Rn, rGPR:$Rm), itin,
                        "vld2", Dt, "$Vd, $Rn, $Rm",
                        "$Rn.addr = $wb", []> {
    let Inst{5-4} = Rn{5-4};
    let DecoderMethod = "DecodeVLDST2Instruction";
    let AsmMatchConverter = "cvtVLDwbRegister";
  }
}

defm VLD2d8wb  : VLD2WB<0b1000, {0,0,?,?}, "8", VecListDPair, IIC_VLD2u>;
defm VLD2d16wb : VLD2WB<0b1000, {0,1,?,?}, "16", VecListDPair, IIC_VLD2u>;
defm VLD2d32wb : VLD2WB<0b1000, {1,0,?,?}, "32", VecListDPair, IIC_VLD2u>;

defm VLD2q8wb  : VLD2WB<0b0011, {0,0,?,?}, "8", VecListFourD, IIC_VLD2x2u>;
defm VLD2q16wb : VLD2WB<0b0011, {0,1,?,?}, "16", VecListFourD, IIC_VLD2x2u>;
defm VLD2q32wb : VLD2WB<0b0011, {1,0,?,?}, "32", VecListFourD, IIC_VLD2x2u>;

def VLD2q8PseudoWB_fixed     : VLDQQWBfixedPseudo<IIC_VLD2x2u>;
def VLD2q16PseudoWB_fixed    : VLDQQWBfixedPseudo<IIC_VLD2x2u>;
def VLD2q32PseudoWB_fixed    : VLDQQWBfixedPseudo<IIC_VLD2x2u>;
def VLD2q8PseudoWB_register  : VLDQQWBregisterPseudo<IIC_VLD2x2u>;
def VLD2q16PseudoWB_register : VLDQQWBregisterPseudo<IIC_VLD2x2u>;
def VLD2q32PseudoWB_register : VLDQQWBregisterPseudo<IIC_VLD2x2u>;

// ...with double-spaced registers
def  VLD2b8    : VLD2<0b1001, {0,0,?,?}, "8", VecListDPairSpaced, IIC_VLD2>;
def  VLD2b16   : VLD2<0b1001, {0,1,?,?}, "16", VecListDPairSpaced, IIC_VLD2>;
def  VLD2b32   : VLD2<0b1001, {1,0,?,?}, "32", VecListDPairSpaced, IIC_VLD2>;
defm VLD2b8wb  : VLD2WB<0b1001, {0,0,?,?}, "8", VecListDPairSpaced, IIC_VLD2u>;
defm VLD2b16wb : VLD2WB<0b1001, {0,1,?,?}, "16", VecListDPairSpaced, IIC_VLD2u>;
defm VLD2b32wb : VLD2WB<0b1001, {1,0,?,?}, "32", VecListDPairSpaced, IIC_VLD2u>;

//   VLD3     : Vector Load (multiple 3-element structures)
class VLD3D<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdSt<0, 0b10, op11_8, op7_4, (outs DPR:$Vd, DPR:$dst2, DPR:$dst3),
          (ins addrmode6:$Rn), IIC_VLD3,
          "vld3", Dt, "\\{$Vd, $dst2, $dst3\\}, $Rn", "", []> {
  let Rm = 0b1111;
  let Inst{4} = Rn{4};
  let DecoderMethod = "DecodeVLDST3Instruction";
}

def  VLD3d8   : VLD3D<0b0100, {0,0,0,?}, "8">;
def  VLD3d16  : VLD3D<0b0100, {0,1,0,?}, "16">;
def  VLD3d32  : VLD3D<0b0100, {1,0,0,?}, "32">;

def  VLD3d8Pseudo  : VLDQQPseudo<IIC_VLD3>;
def  VLD3d16Pseudo : VLDQQPseudo<IIC_VLD3>;
def  VLD3d32Pseudo : VLDQQPseudo<IIC_VLD3>;

// ...with address register writeback:
class VLD3DWB<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdSt<0, 0b10, op11_8, op7_4,
          (outs DPR:$Vd, DPR:$dst2, DPR:$dst3, GPR:$wb),
          (ins addrmode6:$Rn, am6offset:$Rm), IIC_VLD3u,
          "vld3", Dt, "\\{$Vd, $dst2, $dst3\\}, $Rn$Rm",
          "$Rn.addr = $wb", []> {
  let Inst{4} = Rn{4};
  let DecoderMethod = "DecodeVLDST3Instruction";
}

def VLD3d8_UPD  : VLD3DWB<0b0100, {0,0,0,?}, "8">;
def VLD3d16_UPD : VLD3DWB<0b0100, {0,1,0,?}, "16">;
def VLD3d32_UPD : VLD3DWB<0b0100, {1,0,0,?}, "32">;

def VLD3d8Pseudo_UPD  : VLDQQWBPseudo<IIC_VLD3u>;
def VLD3d16Pseudo_UPD : VLDQQWBPseudo<IIC_VLD3u>;
def VLD3d32Pseudo_UPD : VLDQQWBPseudo<IIC_VLD3u>;

// ...with double-spaced registers:
def VLD3q8      : VLD3D<0b0101, {0,0,0,?}, "8">;
def VLD3q16     : VLD3D<0b0101, {0,1,0,?}, "16">;
def VLD3q32     : VLD3D<0b0101, {1,0,0,?}, "32">;
def VLD3q8_UPD  : VLD3DWB<0b0101, {0,0,0,?}, "8">;
def VLD3q16_UPD : VLD3DWB<0b0101, {0,1,0,?}, "16">;
def VLD3q32_UPD : VLD3DWB<0b0101, {1,0,0,?}, "32">;

def VLD3q8Pseudo_UPD  : VLDQQQQWBPseudo<IIC_VLD3u>;
def VLD3q16Pseudo_UPD : VLDQQQQWBPseudo<IIC_VLD3u>;
def VLD3q32Pseudo_UPD : VLDQQQQWBPseudo<IIC_VLD3u>;

// ...alternate versions to be allocated odd register numbers:
def VLD3q8oddPseudo   : VLDQQQQPseudo<IIC_VLD3>;
def VLD3q16oddPseudo  : VLDQQQQPseudo<IIC_VLD3>;
def VLD3q32oddPseudo  : VLDQQQQPseudo<IIC_VLD3>;

def VLD3q8oddPseudo_UPD  : VLDQQQQWBPseudo<IIC_VLD3u>;
def VLD3q16oddPseudo_UPD : VLDQQQQWBPseudo<IIC_VLD3u>;
def VLD3q32oddPseudo_UPD : VLDQQQQWBPseudo<IIC_VLD3u>;

//   VLD4     : Vector Load (multiple 4-element structures)
class VLD4D<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdSt<0, 0b10, op11_8, op7_4,
          (outs DPR:$Vd, DPR:$dst2, DPR:$dst3, DPR:$dst4),
          (ins addrmode6:$Rn), IIC_VLD4,
          "vld4", Dt, "\\{$Vd, $dst2, $dst3, $dst4\\}, $Rn", "", []> {
  let Rm = 0b1111;
  let Inst{5-4} = Rn{5-4};
  let DecoderMethod = "DecodeVLDST4Instruction";
}

def  VLD4d8   : VLD4D<0b0000, {0,0,?,?}, "8">;
def  VLD4d16  : VLD4D<0b0000, {0,1,?,?}, "16">;
def  VLD4d32  : VLD4D<0b0000, {1,0,?,?}, "32">;

def  VLD4d8Pseudo  : VLDQQPseudo<IIC_VLD4>;
def  VLD4d16Pseudo : VLDQQPseudo<IIC_VLD4>;
def  VLD4d32Pseudo : VLDQQPseudo<IIC_VLD4>;

// ...with address register writeback:
class VLD4DWB<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdSt<0, 0b10, op11_8, op7_4,
          (outs DPR:$Vd, DPR:$dst2, DPR:$dst3, DPR:$dst4, GPR:$wb),
          (ins addrmode6:$Rn, am6offset:$Rm), IIC_VLD4u,
          "vld4", Dt, "\\{$Vd, $dst2, $dst3, $dst4\\}, $Rn$Rm",
          "$Rn.addr = $wb", []> {
  let Inst{5-4} = Rn{5-4};
  let DecoderMethod = "DecodeVLDST4Instruction";
}

def VLD4d8_UPD  : VLD4DWB<0b0000, {0,0,?,?}, "8">;
def VLD4d16_UPD : VLD4DWB<0b0000, {0,1,?,?}, "16">;
def VLD4d32_UPD : VLD4DWB<0b0000, {1,0,?,?}, "32">;

def VLD4d8Pseudo_UPD  : VLDQQWBPseudo<IIC_VLD4u>;
def VLD4d16Pseudo_UPD : VLDQQWBPseudo<IIC_VLD4u>;
def VLD4d32Pseudo_UPD : VLDQQWBPseudo<IIC_VLD4u>;

// ...with double-spaced registers:
def VLD4q8      : VLD4D<0b0001, {0,0,?,?}, "8">;
def VLD4q16     : VLD4D<0b0001, {0,1,?,?}, "16">;
def VLD4q32     : VLD4D<0b0001, {1,0,?,?}, "32">;
def VLD4q8_UPD  : VLD4DWB<0b0001, {0,0,?,?}, "8">;
def VLD4q16_UPD : VLD4DWB<0b0001, {0,1,?,?}, "16">;
def VLD4q32_UPD : VLD4DWB<0b0001, {1,0,?,?}, "32">;

def VLD4q8Pseudo_UPD  : VLDQQQQWBPseudo<IIC_VLD4u>;
def VLD4q16Pseudo_UPD : VLDQQQQWBPseudo<IIC_VLD4u>;
def VLD4q32Pseudo_UPD : VLDQQQQWBPseudo<IIC_VLD4u>;

// ...alternate versions to be allocated odd register numbers:
def VLD4q8oddPseudo   : VLDQQQQPseudo<IIC_VLD4>;
def VLD4q16oddPseudo  : VLDQQQQPseudo<IIC_VLD4>;
def VLD4q32oddPseudo  : VLDQQQQPseudo<IIC_VLD4>;

def VLD4q8oddPseudo_UPD  : VLDQQQQWBPseudo<IIC_VLD4u>;
def VLD4q16oddPseudo_UPD : VLDQQQQWBPseudo<IIC_VLD4u>;
def VLD4q32oddPseudo_UPD : VLDQQQQWBPseudo<IIC_VLD4u>;

} // mayLoad = 1, neverHasSideEffects = 1, hasExtraDefRegAllocReq = 1

// Classes for VLD*LN pseudo-instructions with multi-register operands.
// These are expanded to real instructions after register allocation.
class VLDQLNPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs QPR:$dst),
                (ins addrmode6:$addr, QPR:$src, nohash_imm:$lane),
                itin, "$src = $dst">;
class VLDQLNWBPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs QPR:$dst, GPR:$wb),
                (ins addrmode6:$addr, am6offset:$offset, QPR:$src,
                 nohash_imm:$lane), itin, "$addr.addr = $wb, $src = $dst">;
class VLDQQLNPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs QQPR:$dst),
                (ins addrmode6:$addr, QQPR:$src, nohash_imm:$lane),
                itin, "$src = $dst">;
class VLDQQLNWBPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs QQPR:$dst, GPR:$wb),
                (ins addrmode6:$addr, am6offset:$offset, QQPR:$src,
                 nohash_imm:$lane), itin, "$addr.addr = $wb, $src = $dst">;
class VLDQQQQLNPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs QQQQPR:$dst),
                (ins addrmode6:$addr, QQQQPR:$src, nohash_imm:$lane),
                itin, "$src = $dst">;
class VLDQQQQLNWBPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs QQQQPR:$dst, GPR:$wb),
                (ins addrmode6:$addr, am6offset:$offset, QQQQPR:$src,
                 nohash_imm:$lane), itin, "$addr.addr = $wb, $src = $dst">;

//   VLD1LN   : Vector Load (single element to one lane)
class VLD1LN<bits<4> op11_8, bits<4> op7_4, string Dt, ValueType Ty,
             PatFrag LoadOp>
  : NLdStLn<1, 0b10, op11_8, op7_4, (outs DPR:$Vd),
          (ins addrmode6:$Rn, DPR:$src, nohash_imm:$lane),
          IIC_VLD1ln, "vld1", Dt, "\\{$Vd[$lane]\\}, $Rn",
          "$src = $Vd",
          [(set DPR:$Vd, (vector_insert (Ty DPR:$src),
                                         (i32 (LoadOp addrmode6:$Rn)),
                                         imm:$lane))]> {
  let Rm = 0b1111;
  let DecoderMethod = "DecodeVLD1LN";
}
class VLD1LN32<bits<4> op11_8, bits<4> op7_4, string Dt, ValueType Ty,
             PatFrag LoadOp>
  : NLdStLn<1, 0b10, op11_8, op7_4, (outs DPR:$Vd),
          (ins addrmode6oneL32:$Rn, DPR:$src, nohash_imm:$lane),
          IIC_VLD1ln, "vld1", Dt, "\\{$Vd[$lane]\\}, $Rn",
          "$src = $Vd",
          [(set DPR:$Vd, (vector_insert (Ty DPR:$src),
                                         (i32 (LoadOp addrmode6oneL32:$Rn)),
                                         imm:$lane))]> {
  let Rm = 0b1111;
  let DecoderMethod = "DecodeVLD1LN";
}
class VLD1QLNPseudo<ValueType Ty, PatFrag LoadOp> : VLDQLNPseudo<IIC_VLD1ln> {
  let Pattern = [(set QPR:$dst, (vector_insert (Ty QPR:$src),
                                               (i32 (LoadOp addrmode6:$addr)),
                                               imm:$lane))];
}

def VLD1LNd8  : VLD1LN<0b0000, {?,?,?,0}, "8", v8i8, extloadi8> {
  let Inst{7-5} = lane{2-0};
}
def VLD1LNd16 : VLD1LN<0b0100, {?,?,0,?}, "16", v4i16, extloadi16> {
  let Inst{7-6} = lane{1-0};
  let Inst{5-4} = Rn{5-4};
}
def VLD1LNd32 : VLD1LN32<0b1000, {?,0,?,?}, "32", v2i32, load> {
  let Inst{7} = lane{0};
  let Inst{5-4} = Rn{5-4};
}

def VLD1LNq8Pseudo  : VLD1QLNPseudo<v16i8, extloadi8>;
def VLD1LNq16Pseudo : VLD1QLNPseudo<v8i16, extloadi16>;
def VLD1LNq32Pseudo : VLD1QLNPseudo<v4i32, load>;

def : Pat<(vector_insert (v2f32 DPR:$src),
                         (f32 (load addrmode6:$addr)), imm:$lane),
          (VLD1LNd32 addrmode6:$addr, DPR:$src, imm:$lane)>;
def : Pat<(vector_insert (v4f32 QPR:$src),
                         (f32 (load addrmode6:$addr)), imm:$lane),
          (VLD1LNq32Pseudo addrmode6:$addr, QPR:$src, imm:$lane)>;

let mayLoad = 1, neverHasSideEffects = 1, hasExtraDefRegAllocReq = 1 in {

// ...with address register writeback:
class VLD1LNWB<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdStLn<1, 0b10, op11_8, op7_4, (outs DPR:$Vd, GPR:$wb),
          (ins addrmode6:$Rn, am6offset:$Rm,
           DPR:$src, nohash_imm:$lane), IIC_VLD1lnu, "vld1", Dt,
          "\\{$Vd[$lane]\\}, $Rn$Rm",
          "$src = $Vd, $Rn.addr = $wb", []> {
  let DecoderMethod = "DecodeVLD1LN";
}

def VLD1LNd8_UPD  : VLD1LNWB<0b0000, {?,?,?,0}, "8"> {
  let Inst{7-5} = lane{2-0};
}
def VLD1LNd16_UPD : VLD1LNWB<0b0100, {?,?,0,?}, "16"> {
  let Inst{7-6} = lane{1-0};
  let Inst{4}   = Rn{4};
}
def VLD1LNd32_UPD : VLD1LNWB<0b1000, {?,0,?,?}, "32"> {
  let Inst{7} = lane{0};
  let Inst{5} = Rn{4};
  let Inst{4} = Rn{4};
}

def VLD1LNq8Pseudo_UPD  : VLDQLNWBPseudo<IIC_VLD1lnu>;
def VLD1LNq16Pseudo_UPD : VLDQLNWBPseudo<IIC_VLD1lnu>;
def VLD1LNq32Pseudo_UPD : VLDQLNWBPseudo<IIC_VLD1lnu>;

//   VLD2LN   : Vector Load (single 2-element structure to one lane)
class VLD2LN<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdStLn<1, 0b10, op11_8, op7_4, (outs DPR:$Vd, DPR:$dst2),
          (ins addrmode6:$Rn, DPR:$src1, DPR:$src2, nohash_imm:$lane),
          IIC_VLD2ln, "vld2", Dt, "\\{$Vd[$lane], $dst2[$lane]\\}, $Rn",
          "$src1 = $Vd, $src2 = $dst2", []> {
  let Rm = 0b1111;
  let Inst{4}   = Rn{4};
  let DecoderMethod = "DecodeVLD2LN";
}

def VLD2LNd8  : VLD2LN<0b0001, {?,?,?,?}, "8"> {
  let Inst{7-5} = lane{2-0};
}
def VLD2LNd16 : VLD2LN<0b0101, {?,?,0,?}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VLD2LNd32 : VLD2LN<0b1001, {?,0,0,?}, "32"> {
  let Inst{7} = lane{0};
}

def VLD2LNd8Pseudo  : VLDQLNPseudo<IIC_VLD2ln>;
def VLD2LNd16Pseudo : VLDQLNPseudo<IIC_VLD2ln>;
def VLD2LNd32Pseudo : VLDQLNPseudo<IIC_VLD2ln>;

// ...with double-spaced registers:
def VLD2LNq16 : VLD2LN<0b0101, {?,?,1,?}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VLD2LNq32 : VLD2LN<0b1001, {?,1,0,?}, "32"> {
  let Inst{7} = lane{0};
}

def VLD2LNq16Pseudo : VLDQQLNPseudo<IIC_VLD2ln>;
def VLD2LNq32Pseudo : VLDQQLNPseudo<IIC_VLD2ln>;

// ...with address register writeback:
class VLD2LNWB<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdStLn<1, 0b10, op11_8, op7_4, (outs DPR:$Vd, DPR:$dst2, GPR:$wb),
          (ins addrmode6:$Rn, am6offset:$Rm,
           DPR:$src1, DPR:$src2, nohash_imm:$lane), IIC_VLD2lnu, "vld2", Dt,
          "\\{$Vd[$lane], $dst2[$lane]\\}, $Rn$Rm",
          "$src1 = $Vd, $src2 = $dst2, $Rn.addr = $wb", []> {
  let Inst{4}   = Rn{4};
  let DecoderMethod = "DecodeVLD2LN";
}

def VLD2LNd8_UPD  : VLD2LNWB<0b0001, {?,?,?,?}, "8"> {
  let Inst{7-5} = lane{2-0};
}
def VLD2LNd16_UPD : VLD2LNWB<0b0101, {?,?,0,?}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VLD2LNd32_UPD : VLD2LNWB<0b1001, {?,0,0,?}, "32"> {
  let Inst{7} = lane{0};
}

def VLD2LNd8Pseudo_UPD  : VLDQLNWBPseudo<IIC_VLD2lnu>;
def VLD2LNd16Pseudo_UPD : VLDQLNWBPseudo<IIC_VLD2lnu>;
def VLD2LNd32Pseudo_UPD : VLDQLNWBPseudo<IIC_VLD2lnu>;

def VLD2LNq16_UPD : VLD2LNWB<0b0101, {?,?,1,?}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VLD2LNq32_UPD : VLD2LNWB<0b1001, {?,1,0,?}, "32"> {
  let Inst{7} = lane{0};
}

def VLD2LNq16Pseudo_UPD : VLDQQLNWBPseudo<IIC_VLD2lnu>;
def VLD2LNq32Pseudo_UPD : VLDQQLNWBPseudo<IIC_VLD2lnu>;

//   VLD3LN   : Vector Load (single 3-element structure to one lane)
class VLD3LN<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdStLn<1, 0b10, op11_8, op7_4, (outs DPR:$Vd, DPR:$dst2, DPR:$dst3),
          (ins addrmode6:$Rn, DPR:$src1, DPR:$src2, DPR:$src3,
          nohash_imm:$lane), IIC_VLD3ln, "vld3", Dt,
          "\\{$Vd[$lane], $dst2[$lane], $dst3[$lane]\\}, $Rn",
          "$src1 = $Vd, $src2 = $dst2, $src3 = $dst3", []> {
  let Rm = 0b1111;
  let DecoderMethod = "DecodeVLD3LN";
}

def VLD3LNd8  : VLD3LN<0b0010, {?,?,?,0}, "8"> {
  let Inst{7-5} = lane{2-0};
}
def VLD3LNd16 : VLD3LN<0b0110, {?,?,0,0}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VLD3LNd32 : VLD3LN<0b1010, {?,0,0,0}, "32"> {
  let Inst{7}   = lane{0};
}

def VLD3LNd8Pseudo  : VLDQQLNPseudo<IIC_VLD3ln>;
def VLD3LNd16Pseudo : VLDQQLNPseudo<IIC_VLD3ln>;
def VLD3LNd32Pseudo : VLDQQLNPseudo<IIC_VLD3ln>;

// ...with double-spaced registers:
def VLD3LNq16 : VLD3LN<0b0110, {?,?,1,0}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VLD3LNq32 : VLD3LN<0b1010, {?,1,0,0}, "32"> {
  let Inst{7}   = lane{0};
}

def VLD3LNq16Pseudo : VLDQQQQLNPseudo<IIC_VLD3ln>;
def VLD3LNq32Pseudo : VLDQQQQLNPseudo<IIC_VLD3ln>;

// ...with address register writeback:
class VLD3LNWB<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdStLn<1, 0b10, op11_8, op7_4,
          (outs DPR:$Vd, DPR:$dst2, DPR:$dst3, GPR:$wb),
          (ins addrmode6:$Rn, am6offset:$Rm,
           DPR:$src1, DPR:$src2, DPR:$src3, nohash_imm:$lane),
          IIC_VLD3lnu, "vld3", Dt,
          "\\{$Vd[$lane], $dst2[$lane], $dst3[$lane]\\}, $Rn$Rm",
          "$src1 = $Vd, $src2 = $dst2, $src3 = $dst3, $Rn.addr = $wb",
          []> {
  let DecoderMethod = "DecodeVLD3LN";
}

def VLD3LNd8_UPD  : VLD3LNWB<0b0010, {?,?,?,0}, "8"> {
  let Inst{7-5} = lane{2-0};
}
def VLD3LNd16_UPD : VLD3LNWB<0b0110, {?,?,0,0}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VLD3LNd32_UPD : VLD3LNWB<0b1010, {?,0,0,0}, "32"> {
  let Inst{7} = lane{0};
}

def VLD3LNd8Pseudo_UPD  : VLDQQLNWBPseudo<IIC_VLD3lnu>;
def VLD3LNd16Pseudo_UPD : VLDQQLNWBPseudo<IIC_VLD3lnu>;
def VLD3LNd32Pseudo_UPD : VLDQQLNWBPseudo<IIC_VLD3lnu>;

def VLD3LNq16_UPD : VLD3LNWB<0b0110, {?,?,1,0}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VLD3LNq32_UPD : VLD3LNWB<0b1010, {?,1,0,0}, "32"> {
  let Inst{7} = lane{0};
}

def VLD3LNq16Pseudo_UPD : VLDQQQQLNWBPseudo<IIC_VLD3lnu>;
def VLD3LNq32Pseudo_UPD : VLDQQQQLNWBPseudo<IIC_VLD3lnu>;

//   VLD4LN   : Vector Load (single 4-element structure to one lane)
class VLD4LN<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdStLn<1, 0b10, op11_8, op7_4,
          (outs DPR:$Vd, DPR:$dst2, DPR:$dst3, DPR:$dst4),
          (ins addrmode6:$Rn, DPR:$src1, DPR:$src2, DPR:$src3, DPR:$src4,
          nohash_imm:$lane), IIC_VLD4ln, "vld4", Dt,
          "\\{$Vd[$lane], $dst2[$lane], $dst3[$lane], $dst4[$lane]\\}, $Rn",
          "$src1 = $Vd, $src2 = $dst2, $src3 = $dst3, $src4 = $dst4", []> {
  let Rm = 0b1111;
  let Inst{4} = Rn{4};
  let DecoderMethod = "DecodeVLD4LN";
}

def VLD4LNd8  : VLD4LN<0b0011, {?,?,?,?}, "8"> {
  let Inst{7-5} = lane{2-0};
}
def VLD4LNd16 : VLD4LN<0b0111, {?,?,0,?}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VLD4LNd32 : VLD4LN<0b1011, {?,0,?,?}, "32"> {
  let Inst{7} = lane{0};
  let Inst{5} = Rn{5};
}

def VLD4LNd8Pseudo  : VLDQQLNPseudo<IIC_VLD4ln>;
def VLD4LNd16Pseudo : VLDQQLNPseudo<IIC_VLD4ln>;
def VLD4LNd32Pseudo : VLDQQLNPseudo<IIC_VLD4ln>;

// ...with double-spaced registers:
def VLD4LNq16 : VLD4LN<0b0111, {?,?,1,?}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VLD4LNq32 : VLD4LN<0b1011, {?,1,?,?}, "32"> {
  let Inst{7} = lane{0};
  let Inst{5} = Rn{5};
}

def VLD4LNq16Pseudo : VLDQQQQLNPseudo<IIC_VLD4ln>;
def VLD4LNq32Pseudo : VLDQQQQLNPseudo<IIC_VLD4ln>;

// ...with address register writeback:
class VLD4LNWB<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdStLn<1, 0b10, op11_8, op7_4,
          (outs DPR:$Vd, DPR:$dst2, DPR:$dst3, DPR:$dst4, GPR:$wb),
          (ins addrmode6:$Rn, am6offset:$Rm,
           DPR:$src1, DPR:$src2, DPR:$src3, DPR:$src4, nohash_imm:$lane),
          IIC_VLD4lnu, "vld4", Dt,
"\\{$Vd[$lane], $dst2[$lane], $dst3[$lane], $dst4[$lane]\\}, $Rn$Rm",
"$src1 = $Vd, $src2 = $dst2, $src3 = $dst3, $src4 = $dst4, $Rn.addr = $wb",
          []> {
  let Inst{4}   = Rn{4};
  let DecoderMethod = "DecodeVLD4LN"  ;
}

def VLD4LNd8_UPD  : VLD4LNWB<0b0011, {?,?,?,?}, "8"> {
  let Inst{7-5} = lane{2-0};
}
def VLD4LNd16_UPD : VLD4LNWB<0b0111, {?,?,0,?}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VLD4LNd32_UPD : VLD4LNWB<0b1011, {?,0,?,?}, "32"> {
  let Inst{7} = lane{0};
  let Inst{5} = Rn{5};
}

def VLD4LNd8Pseudo_UPD  : VLDQQLNWBPseudo<IIC_VLD4lnu>;
def VLD4LNd16Pseudo_UPD : VLDQQLNWBPseudo<IIC_VLD4lnu>;
def VLD4LNd32Pseudo_UPD : VLDQQLNWBPseudo<IIC_VLD4lnu>;

def VLD4LNq16_UPD : VLD4LNWB<0b0111, {?,?,1,?}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VLD4LNq32_UPD : VLD4LNWB<0b1011, {?,1,?,?}, "32"> {
  let Inst{7} = lane{0};
  let Inst{5} = Rn{5};
}

def VLD4LNq16Pseudo_UPD : VLDQQQQLNWBPseudo<IIC_VLD4lnu>;
def VLD4LNq32Pseudo_UPD : VLDQQQQLNWBPseudo<IIC_VLD4lnu>;

} // mayLoad = 1, neverHasSideEffects = 1, hasExtraDefRegAllocReq = 1

//   VLD1DUP  : Vector Load (single element to all lanes)
class VLD1DUP<bits<4> op7_4, string Dt, ValueType Ty, PatFrag LoadOp>
  : NLdSt<1, 0b10, 0b1100, op7_4, (outs VecListOneDAllLanes:$Vd),
          (ins addrmode6dup:$Rn),
          IIC_VLD1dup, "vld1", Dt, "$Vd, $Rn", "",
          [(set VecListOneDAllLanes:$Vd,
                (Ty (NEONvdup (i32 (LoadOp addrmode6dup:$Rn)))))]> {
  let Rm = 0b1111;
  let Inst{4} = Rn{4};
  let DecoderMethod = "DecodeVLD1DupInstruction";
}
def VLD1DUPd8  : VLD1DUP<{0,0,0,?}, "8", v8i8, extloadi8>;
def VLD1DUPd16 : VLD1DUP<{0,1,0,?}, "16", v4i16, extloadi16>;
def VLD1DUPd32 : VLD1DUP<{1,0,0,?}, "32", v2i32, load>;

def : Pat<(v2f32 (NEONvdup (f32 (load addrmode6dup:$addr)))),
          (VLD1DUPd32 addrmode6:$addr)>;

class VLD1QDUP<bits<4> op7_4, string Dt, ValueType Ty, PatFrag LoadOp>
  : NLdSt<1, 0b10, 0b1100, op7_4, (outs VecListDPairAllLanes:$Vd),
          (ins addrmode6dup:$Rn), IIC_VLD1dup,
          "vld1", Dt, "$Vd, $Rn", "",
          [(set VecListDPairAllLanes:$Vd,
                (Ty (NEONvdup (i32 (LoadOp addrmode6dup:$Rn)))))]> {
  let Rm = 0b1111;
  let Inst{4} = Rn{4};
  let DecoderMethod = "DecodeVLD1DupInstruction";
}

def VLD1DUPq8  : VLD1QDUP<{0,0,1,0}, "8", v16i8, extloadi8>;
def VLD1DUPq16 : VLD1QDUP<{0,1,1,?}, "16", v8i16, extloadi16>;
def VLD1DUPq32 : VLD1QDUP<{1,0,1,?}, "32", v4i32, load>;

def : Pat<(v4f32 (NEONvdup (f32 (load addrmode6dup:$addr)))),
          (VLD1DUPq32 addrmode6:$addr)>;

let mayLoad = 1, neverHasSideEffects = 1, hasExtraDefRegAllocReq = 1 in {
// ...with address register writeback:
multiclass VLD1DUPWB<bits<4> op7_4, string Dt> {
  def _fixed : NLdSt<1, 0b10, 0b1100, op7_4,
                     (outs VecListOneDAllLanes:$Vd, GPR:$wb),
                     (ins addrmode6dup:$Rn), IIC_VLD1dupu,
                     "vld1", Dt, "$Vd, $Rn!",
                     "$Rn.addr = $wb", []> {
    let Rm = 0b1101; // NLdSt will assign to the right encoding bits.
    let Inst{4} = Rn{4};
    let DecoderMethod = "DecodeVLD1DupInstruction";
    let AsmMatchConverter = "cvtVLDwbFixed";
  }
  def _register : NLdSt<1, 0b10, 0b1100, op7_4,
                        (outs VecListOneDAllLanes:$Vd, GPR:$wb),
                        (ins addrmode6dup:$Rn, rGPR:$Rm), IIC_VLD1dupu,
                        "vld1", Dt, "$Vd, $Rn, $Rm",
                        "$Rn.addr = $wb", []> {
    let Inst{4} = Rn{4};
    let DecoderMethod = "DecodeVLD1DupInstruction";
    let AsmMatchConverter = "cvtVLDwbRegister";
  }
}
multiclass VLD1QDUPWB<bits<4> op7_4, string Dt> {
  def _fixed : NLdSt<1, 0b10, 0b1100, op7_4,
                     (outs VecListDPairAllLanes:$Vd, GPR:$wb),
                     (ins addrmode6dup:$Rn), IIC_VLD1dupu,
                     "vld1", Dt, "$Vd, $Rn!",
                     "$Rn.addr = $wb", []> {
    let Rm = 0b1101; // NLdSt will assign to the right encoding bits.
    let Inst{4} = Rn{4};
    let DecoderMethod = "DecodeVLD1DupInstruction";
    let AsmMatchConverter = "cvtVLDwbFixed";
  }
  def _register : NLdSt<1, 0b10, 0b1100, op7_4,
                        (outs VecListDPairAllLanes:$Vd, GPR:$wb),
                        (ins addrmode6dup:$Rn, rGPR:$Rm), IIC_VLD1dupu,
                        "vld1", Dt, "$Vd, $Rn, $Rm",
                        "$Rn.addr = $wb", []> {
    let Inst{4} = Rn{4};
    let DecoderMethod = "DecodeVLD1DupInstruction";
    let AsmMatchConverter = "cvtVLDwbRegister";
  }
}

defm VLD1DUPd8wb  : VLD1DUPWB<{0,0,0,0}, "8">;
defm VLD1DUPd16wb : VLD1DUPWB<{0,1,0,?}, "16">;
defm VLD1DUPd32wb : VLD1DUPWB<{1,0,0,?}, "32">;

defm VLD1DUPq8wb  : VLD1QDUPWB<{0,0,1,0}, "8">;
defm VLD1DUPq16wb : VLD1QDUPWB<{0,1,1,?}, "16">;
defm VLD1DUPq32wb : VLD1QDUPWB<{1,0,1,?}, "32">;

//   VLD2DUP  : Vector Load (single 2-element structure to all lanes)
class VLD2DUP<bits<4> op7_4, string Dt, RegisterOperand VdTy>
  : NLdSt<1, 0b10, 0b1101, op7_4, (outs VdTy:$Vd),
          (ins addrmode6dup:$Rn), IIC_VLD2dup,
          "vld2", Dt, "$Vd, $Rn", "", []> {
  let Rm = 0b1111;
  let Inst{4} = Rn{4};
  let DecoderMethod = "DecodeVLD2DupInstruction";
}

def VLD2DUPd8  : VLD2DUP<{0,0,0,?}, "8",  VecListDPairAllLanes>;
def VLD2DUPd16 : VLD2DUP<{0,1,0,?}, "16", VecListDPairAllLanes>;
def VLD2DUPd32 : VLD2DUP<{1,0,0,?}, "32", VecListDPairAllLanes>;

// ...with double-spaced registers
def VLD2DUPd8x2  : VLD2DUP<{0,0,1,?}, "8",  VecListDPairSpacedAllLanes>;
def VLD2DUPd16x2 : VLD2DUP<{0,1,1,?}, "16", VecListDPairSpacedAllLanes>;
def VLD2DUPd32x2 : VLD2DUP<{1,0,1,?}, "32", VecListDPairSpacedAllLanes>;

// ...with address register writeback:
multiclass VLD2DUPWB<bits<4> op7_4, string Dt, RegisterOperand VdTy> {
  def _fixed : NLdSt<1, 0b10, 0b1101, op7_4,
                     (outs VdTy:$Vd, GPR:$wb),
                     (ins addrmode6dup:$Rn), IIC_VLD2dupu,
                     "vld2", Dt, "$Vd, $Rn!",
                     "$Rn.addr = $wb", []> {
    let Rm = 0b1101; // NLdSt will assign to the right encoding bits.
    let Inst{4} = Rn{4};
    let DecoderMethod = "DecodeVLD2DupInstruction";
    let AsmMatchConverter = "cvtVLDwbFixed";
  }
  def _register : NLdSt<1, 0b10, 0b1101, op7_4,
                        (outs VdTy:$Vd, GPR:$wb),
                        (ins addrmode6dup:$Rn, rGPR:$Rm), IIC_VLD2dupu,
                        "vld2", Dt, "$Vd, $Rn, $Rm",
                        "$Rn.addr = $wb", []> {
    let Inst{4} = Rn{4};
    let DecoderMethod = "DecodeVLD2DupInstruction";
    let AsmMatchConverter = "cvtVLDwbRegister";
  }
}

defm VLD2DUPd8wb    : VLD2DUPWB<{0,0,0,0}, "8",  VecListDPairAllLanes>;
defm VLD2DUPd16wb   : VLD2DUPWB<{0,1,0,?}, "16", VecListDPairAllLanes>;
defm VLD2DUPd32wb   : VLD2DUPWB<{1,0,0,?}, "32", VecListDPairAllLanes>;

defm VLD2DUPd8x2wb  : VLD2DUPWB<{0,0,1,0}, "8",  VecListDPairSpacedAllLanes>;
defm VLD2DUPd16x2wb : VLD2DUPWB<{0,1,1,?}, "16", VecListDPairSpacedAllLanes>;
defm VLD2DUPd32x2wb : VLD2DUPWB<{1,0,1,?}, "32", VecListDPairSpacedAllLanes>;

//   VLD3DUP  : Vector Load (single 3-element structure to all lanes)
class VLD3DUP<bits<4> op7_4, string Dt>
  : NLdSt<1, 0b10, 0b1110, op7_4, (outs DPR:$Vd, DPR:$dst2, DPR:$dst3),
          (ins addrmode6dup:$Rn), IIC_VLD3dup,
          "vld3", Dt, "\\{$Vd[], $dst2[], $dst3[]\\}, $Rn", "", []> {
  let Rm = 0b1111;
  let Inst{4} = 0;
  let DecoderMethod = "DecodeVLD3DupInstruction";
}

def VLD3DUPd8  : VLD3DUP<{0,0,0,?}, "8">;
def VLD3DUPd16 : VLD3DUP<{0,1,0,?}, "16">;
def VLD3DUPd32 : VLD3DUP<{1,0,0,?}, "32">;

def VLD3DUPd8Pseudo  : VLDQQPseudo<IIC_VLD3dup>;
def VLD3DUPd16Pseudo : VLDQQPseudo<IIC_VLD3dup>;
def VLD3DUPd32Pseudo : VLDQQPseudo<IIC_VLD3dup>;

// ...with double-spaced registers (not used for codegen):
def VLD3DUPq8  : VLD3DUP<{0,0,1,?}, "8">;
def VLD3DUPq16 : VLD3DUP<{0,1,1,?}, "16">;
def VLD3DUPq32 : VLD3DUP<{1,0,1,?}, "32">;

// ...with address register writeback:
class VLD3DUPWB<bits<4> op7_4, string Dt>
  : NLdSt<1, 0b10, 0b1110, op7_4, (outs DPR:$Vd, DPR:$dst2, DPR:$dst3, GPR:$wb),
          (ins addrmode6dup:$Rn, am6offset:$Rm), IIC_VLD3dupu,
          "vld3", Dt, "\\{$Vd[], $dst2[], $dst3[]\\}, $Rn$Rm",
          "$Rn.addr = $wb", []> {
  let Inst{4} = 0;
  let DecoderMethod = "DecodeVLD3DupInstruction";
}

def VLD3DUPd8_UPD  : VLD3DUPWB<{0,0,0,0}, "8">;
def VLD3DUPd16_UPD : VLD3DUPWB<{0,1,0,?}, "16">;
def VLD3DUPd32_UPD : VLD3DUPWB<{1,0,0,?}, "32">;

def VLD3DUPq8_UPD  : VLD3DUPWB<{0,0,1,0}, "8">;
def VLD3DUPq16_UPD : VLD3DUPWB<{0,1,1,?}, "16">;
def VLD3DUPq32_UPD : VLD3DUPWB<{1,0,1,?}, "32">;

def VLD3DUPd8Pseudo_UPD  : VLDQQWBPseudo<IIC_VLD3dupu>;
def VLD3DUPd16Pseudo_UPD : VLDQQWBPseudo<IIC_VLD3dupu>;
def VLD3DUPd32Pseudo_UPD : VLDQQWBPseudo<IIC_VLD3dupu>;

//   VLD4DUP  : Vector Load (single 4-element structure to all lanes)
class VLD4DUP<bits<4> op7_4, string Dt>
  : NLdSt<1, 0b10, 0b1111, op7_4,
          (outs DPR:$Vd, DPR:$dst2, DPR:$dst3, DPR:$dst4),
          (ins addrmode6dup:$Rn), IIC_VLD4dup,
          "vld4", Dt, "\\{$Vd[], $dst2[], $dst3[], $dst4[]\\}, $Rn", "", []> {
  let Rm = 0b1111;
  let Inst{4} = Rn{4};
  let DecoderMethod = "DecodeVLD4DupInstruction";
}

def VLD4DUPd8  : VLD4DUP<{0,0,0,?}, "8">;
def VLD4DUPd16 : VLD4DUP<{0,1,0,?}, "16">;
def VLD4DUPd32 : VLD4DUP<{1,?,0,?}, "32"> { let Inst{6} = Rn{5}; }

def VLD4DUPd8Pseudo  : VLDQQPseudo<IIC_VLD4dup>;
def VLD4DUPd16Pseudo : VLDQQPseudo<IIC_VLD4dup>;
def VLD4DUPd32Pseudo : VLDQQPseudo<IIC_VLD4dup>;

// ...with double-spaced registers (not used for codegen):
def VLD4DUPq8  : VLD4DUP<{0,0,1,?}, "8">;
def VLD4DUPq16 : VLD4DUP<{0,1,1,?}, "16">;
def VLD4DUPq32 : VLD4DUP<{1,?,1,?}, "32"> { let Inst{6} = Rn{5}; }

// ...with address register writeback:
class VLD4DUPWB<bits<4> op7_4, string Dt>
  : NLdSt<1, 0b10, 0b1111, op7_4,
          (outs DPR:$Vd, DPR:$dst2, DPR:$dst3, DPR:$dst4, GPR:$wb),
          (ins addrmode6dup:$Rn, am6offset:$Rm), IIC_VLD4dupu,
          "vld4", Dt, "\\{$Vd[], $dst2[], $dst3[], $dst4[]\\}, $Rn$Rm",
          "$Rn.addr = $wb", []> {
  let Inst{4} = Rn{4};
  let DecoderMethod = "DecodeVLD4DupInstruction";
}

def VLD4DUPd8_UPD  : VLD4DUPWB<{0,0,0,0}, "8">;
def VLD4DUPd16_UPD : VLD4DUPWB<{0,1,0,?}, "16">;
def VLD4DUPd32_UPD : VLD4DUPWB<{1,?,0,?}, "32"> { let Inst{6} = Rn{5}; }

def VLD4DUPq8_UPD  : VLD4DUPWB<{0,0,1,0}, "8">;
def VLD4DUPq16_UPD : VLD4DUPWB<{0,1,1,?}, "16">;
def VLD4DUPq32_UPD : VLD4DUPWB<{1,?,1,?}, "32"> { let Inst{6} = Rn{5}; }

def VLD4DUPd8Pseudo_UPD  : VLDQQWBPseudo<IIC_VLD4dupu>;
def VLD4DUPd16Pseudo_UPD : VLDQQWBPseudo<IIC_VLD4dupu>;
def VLD4DUPd32Pseudo_UPD : VLDQQWBPseudo<IIC_VLD4dupu>;

} // mayLoad = 1, neverHasSideEffects = 1, hasExtraDefRegAllocReq = 1

let mayStore = 1, neverHasSideEffects = 1, hasExtraSrcRegAllocReq = 1 in {

// Classes for VST* pseudo-instructions with multi-register operands.
// These are expanded to real instructions after register allocation.
class VSTQPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs), (ins addrmode6:$addr, QPR:$src), itin, "">;
class VSTQWBPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs GPR:$wb),
                (ins addrmode6:$addr, am6offset:$offset, QPR:$src), itin,
                "$addr.addr = $wb">;
class VSTQWBfixedPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs GPR:$wb),
                (ins addrmode6:$addr, QPR:$src), itin,
                "$addr.addr = $wb">;
class VSTQWBregisterPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs GPR:$wb),
                (ins addrmode6:$addr, rGPR:$offset, QPR:$src), itin,
                "$addr.addr = $wb">;
class VSTQQPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs), (ins addrmode6:$addr, QQPR:$src), itin, "">;
class VSTQQWBPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs GPR:$wb),
                (ins addrmode6:$addr, am6offset:$offset, QQPR:$src), itin,
                "$addr.addr = $wb">;
class VSTQQWBfixedPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs GPR:$wb),
                (ins addrmode6:$addr, QQPR:$src), itin,
                "$addr.addr = $wb">;
class VSTQQWBregisterPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs GPR:$wb),
                (ins addrmode6:$addr, rGPR:$offset, QQPR:$src), itin,
                "$addr.addr = $wb">;

class VSTQQQQPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs), (ins addrmode6:$addr, QQQQPR:$src), itin, "">;
class VSTQQQQWBPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs GPR:$wb),
                (ins addrmode6:$addr, am6offset:$offset, QQQQPR:$src), itin,
                "$addr.addr = $wb">;

//   VST1     : Vector Store (multiple single elements)
class VST1D<bits<4> op7_4, string Dt>
  : NLdSt<0,0b00,0b0111,op7_4, (outs), (ins addrmode6:$Rn, VecListOneD:$Vd),
          IIC_VST1, "vst1", Dt, "$Vd, $Rn", "", []> {
  let Rm = 0b1111;
  let Inst{4} = Rn{4};
  let DecoderMethod = "DecodeVLDST1Instruction";
}
class VST1Q<bits<4> op7_4, string Dt>
  : NLdSt<0,0b00,0b1010,op7_4, (outs), (ins addrmode6:$Rn, VecListDPair:$Vd),
          IIC_VST1x2, "vst1", Dt, "$Vd, $Rn", "", []> {
  let Rm = 0b1111;
  let Inst{5-4} = Rn{5-4};
  let DecoderMethod = "DecodeVLDST1Instruction";
}

def  VST1d8   : VST1D<{0,0,0,?}, "8">;
def  VST1d16  : VST1D<{0,1,0,?}, "16">;
def  VST1d32  : VST1D<{1,0,0,?}, "32">;
def  VST1d64  : VST1D<{1,1,0,?}, "64">;

def  VST1q8   : VST1Q<{0,0,?,?}, "8">;
def  VST1q16  : VST1Q<{0,1,?,?}, "16">;
def  VST1q32  : VST1Q<{1,0,?,?}, "32">;
def  VST1q64  : VST1Q<{1,1,?,?}, "64">;

// ...with address register writeback:
multiclass VST1DWB<bits<4> op7_4, string Dt> {
  def _fixed : NLdSt<0,0b00, 0b0111,op7_4, (outs GPR:$wb),
                     (ins addrmode6:$Rn, VecListOneD:$Vd), IIC_VLD1u,
                     "vst1", Dt, "$Vd, $Rn!",
                     "$Rn.addr = $wb", []> {
    let Rm = 0b1101; // NLdSt will assign to the right encoding bits.
    let Inst{4} = Rn{4};
    let DecoderMethod = "DecodeVLDST1Instruction";
    let AsmMatchConverter = "cvtVSTwbFixed";
  }
  def _register : NLdSt<0,0b00,0b0111,op7_4, (outs GPR:$wb),
                        (ins addrmode6:$Rn, rGPR:$Rm, VecListOneD:$Vd),
                        IIC_VLD1u,
                        "vst1", Dt, "$Vd, $Rn, $Rm",
                        "$Rn.addr = $wb", []> {
    let Inst{4} = Rn{4};
    let DecoderMethod = "DecodeVLDST1Instruction";
    let AsmMatchConverter = "cvtVSTwbRegister";
  }
}
multiclass VST1QWB<bits<4> op7_4, string Dt> {
  def _fixed : NLdSt<0,0b00,0b1010,op7_4, (outs GPR:$wb),
                    (ins addrmode6:$Rn, VecListDPair:$Vd), IIC_VLD1x2u,
                     "vst1", Dt, "$Vd, $Rn!",
                     "$Rn.addr = $wb", []> {
    let Rm = 0b1101; // NLdSt will assign to the right encoding bits.
    let Inst{5-4} = Rn{5-4};
    let DecoderMethod = "DecodeVLDST1Instruction";
    let AsmMatchConverter = "cvtVSTwbFixed";
  }
  def _register : NLdSt<0,0b00,0b1010,op7_4, (outs GPR:$wb),
                        (ins addrmode6:$Rn, rGPR:$Rm, VecListDPair:$Vd),
                        IIC_VLD1x2u,
                        "vst1", Dt, "$Vd, $Rn, $Rm",
                        "$Rn.addr = $wb", []> {
    let Inst{5-4} = Rn{5-4};
    let DecoderMethod = "DecodeVLDST1Instruction";
    let AsmMatchConverter = "cvtVSTwbRegister";
  }
}

defm VST1d8wb  : VST1DWB<{0,0,0,?}, "8">;
defm VST1d16wb : VST1DWB<{0,1,0,?}, "16">;
defm VST1d32wb : VST1DWB<{1,0,0,?}, "32">;
defm VST1d64wb : VST1DWB<{1,1,0,?}, "64">;

defm VST1q8wb  : VST1QWB<{0,0,?,?}, "8">;
defm VST1q16wb : VST1QWB<{0,1,?,?}, "16">;
defm VST1q32wb : VST1QWB<{1,0,?,?}, "32">;
defm VST1q64wb : VST1QWB<{1,1,?,?}, "64">;

// ...with 3 registers
class VST1D3<bits<4> op7_4, string Dt>
  : NLdSt<0, 0b00, 0b0110, op7_4, (outs),
          (ins addrmode6:$Rn, VecListThreeD:$Vd),
          IIC_VST1x3, "vst1", Dt, "$Vd, $Rn", "", []> {
  let Rm = 0b1111;
  let Inst{4} = Rn{4};
  let DecoderMethod = "DecodeVLDST1Instruction";
}
multiclass VST1D3WB<bits<4> op7_4, string Dt> {
  def _fixed : NLdSt<0,0b00,0b0110,op7_4, (outs GPR:$wb),
                    (ins addrmode6:$Rn, VecListThreeD:$Vd), IIC_VLD1x3u,
                     "vst1", Dt, "$Vd, $Rn!",
                     "$Rn.addr = $wb", []> {
    let Rm = 0b1101; // NLdSt will assign to the right encoding bits.
    let Inst{5-4} = Rn{5-4};
    let DecoderMethod = "DecodeVLDST1Instruction";
    let AsmMatchConverter = "cvtVSTwbFixed";
  }
  def _register : NLdSt<0,0b00,0b0110,op7_4, (outs GPR:$wb),
                        (ins addrmode6:$Rn, rGPR:$Rm, VecListThreeD:$Vd),
                        IIC_VLD1x3u,
                        "vst1", Dt, "$Vd, $Rn, $Rm",
                        "$Rn.addr = $wb", []> {
    let Inst{5-4} = Rn{5-4};
    let DecoderMethod = "DecodeVLDST1Instruction";
    let AsmMatchConverter = "cvtVSTwbRegister";
  }
}

def VST1d8T     : VST1D3<{0,0,0,?}, "8">;
def VST1d16T    : VST1D3<{0,1,0,?}, "16">;
def VST1d32T    : VST1D3<{1,0,0,?}, "32">;
def VST1d64T    : VST1D3<{1,1,0,?}, "64">;

defm VST1d8Twb  : VST1D3WB<{0,0,0,?}, "8">;
defm VST1d16Twb : VST1D3WB<{0,1,0,?}, "16">;
defm VST1d32Twb : VST1D3WB<{1,0,0,?}, "32">;
defm VST1d64Twb : VST1D3WB<{1,1,0,?}, "64">;

def VST1d64TPseudo            : VSTQQPseudo<IIC_VST1x3>;
def VST1d64TPseudoWB_fixed    : VSTQQWBPseudo<IIC_VST1x3u>;
def VST1d64TPseudoWB_register : VSTQQWBPseudo<IIC_VST1x3u>;

// ...with 4 registers
class VST1D4<bits<4> op7_4, string Dt>
  : NLdSt<0, 0b00, 0b0010, op7_4, (outs),
          (ins addrmode6:$Rn, VecListFourD:$Vd),
          IIC_VST1x4, "vst1", Dt, "$Vd, $Rn", "",
          []> {
  let Rm = 0b1111;
  let Inst{5-4} = Rn{5-4};
  let DecoderMethod = "DecodeVLDST1Instruction";
}
multiclass VST1D4WB<bits<4> op7_4, string Dt> {
  def _fixed : NLdSt<0,0b00,0b0010,op7_4, (outs GPR:$wb),
                    (ins addrmode6:$Rn, VecListFourD:$Vd), IIC_VLD1x4u,
                     "vst1", Dt, "$Vd, $Rn!",
                     "$Rn.addr = $wb", []> {
    let Rm = 0b1101; // NLdSt will assign to the right encoding bits.
    let Inst{5-4} = Rn{5-4};
    let DecoderMethod = "DecodeVLDST1Instruction";
    let AsmMatchConverter = "cvtVSTwbFixed";
  }
  def _register : NLdSt<0,0b00,0b0010,op7_4, (outs GPR:$wb),
                        (ins addrmode6:$Rn, rGPR:$Rm, VecListFourD:$Vd),
                        IIC_VLD1x4u,
                        "vst1", Dt, "$Vd, $Rn, $Rm",
                        "$Rn.addr = $wb", []> {
    let Inst{5-4} = Rn{5-4};
    let DecoderMethod = "DecodeVLDST1Instruction";
    let AsmMatchConverter = "cvtVSTwbRegister";
  }
}

def VST1d8Q     : VST1D4<{0,0,?,?}, "8">;
def VST1d16Q    : VST1D4<{0,1,?,?}, "16">;
def VST1d32Q    : VST1D4<{1,0,?,?}, "32">;
def VST1d64Q    : VST1D4<{1,1,?,?}, "64">;

defm VST1d8Qwb  : VST1D4WB<{0,0,?,?}, "8">;
defm VST1d16Qwb : VST1D4WB<{0,1,?,?}, "16">;
defm VST1d32Qwb : VST1D4WB<{1,0,?,?}, "32">;
defm VST1d64Qwb : VST1D4WB<{1,1,?,?}, "64">;

def VST1d64QPseudo            : VSTQQPseudo<IIC_VST1x4>;
def VST1d64QPseudoWB_fixed    : VSTQQWBPseudo<IIC_VST1x4u>;
def VST1d64QPseudoWB_register : VSTQQWBPseudo<IIC_VST1x4u>;

//   VST2     : Vector Store (multiple 2-element structures)
class VST2<bits<4> op11_8, bits<4> op7_4, string Dt, RegisterOperand VdTy,
            InstrItinClass itin>
  : NLdSt<0, 0b00, op11_8, op7_4, (outs), (ins addrmode6:$Rn, VdTy:$Vd),
          itin, "vst2", Dt, "$Vd, $Rn", "", []> {
  let Rm = 0b1111;
  let Inst{5-4} = Rn{5-4};
  let DecoderMethod = "DecodeVLDST2Instruction";
}

def  VST2d8   : VST2<0b1000, {0,0,?,?}, "8",  VecListDPair, IIC_VST2>;
def  VST2d16  : VST2<0b1000, {0,1,?,?}, "16", VecListDPair, IIC_VST2>;
def  VST2d32  : VST2<0b1000, {1,0,?,?}, "32", VecListDPair, IIC_VST2>;

def  VST2q8   : VST2<0b0011, {0,0,?,?}, "8",  VecListFourD, IIC_VST2x2>;
def  VST2q16  : VST2<0b0011, {0,1,?,?}, "16", VecListFourD, IIC_VST2x2>;
def  VST2q32  : VST2<0b0011, {1,0,?,?}, "32", VecListFourD, IIC_VST2x2>;

def  VST2q8Pseudo  : VSTQQPseudo<IIC_VST2x2>;
def  VST2q16Pseudo : VSTQQPseudo<IIC_VST2x2>;
def  VST2q32Pseudo : VSTQQPseudo<IIC_VST2x2>;

// ...with address register writeback:
multiclass VST2DWB<bits<4> op11_8, bits<4> op7_4, string Dt,
                   RegisterOperand VdTy> {
  def _fixed : NLdSt<0, 0b00, op11_8, op7_4, (outs GPR:$wb),
                     (ins addrmode6:$Rn, VdTy:$Vd), IIC_VLD1u,
                     "vst2", Dt, "$Vd, $Rn!",
                     "$Rn.addr = $wb", []> {
    let Rm = 0b1101; // NLdSt will assign to the right encoding bits.
    let Inst{5-4} = Rn{5-4};
    let DecoderMethod = "DecodeVLDST2Instruction";
    let AsmMatchConverter = "cvtVSTwbFixed";
  }
  def _register : NLdSt<0, 0b00, op11_8, op7_4, (outs GPR:$wb),
                        (ins addrmode6:$Rn, rGPR:$Rm, VdTy:$Vd), IIC_VLD1u,
                        "vst2", Dt, "$Vd, $Rn, $Rm",
                        "$Rn.addr = $wb", []> {
    let Inst{5-4} = Rn{5-4};
    let DecoderMethod = "DecodeVLDST2Instruction";
    let AsmMatchConverter = "cvtVSTwbRegister";
  }
}
multiclass VST2QWB<bits<4> op7_4, string Dt> {
  def _fixed : NLdSt<0, 0b00, 0b0011, op7_4, (outs GPR:$wb),
                     (ins addrmode6:$Rn, VecListFourD:$Vd), IIC_VLD1u,
                     "vst2", Dt, "$Vd, $Rn!",
                     "$Rn.addr = $wb", []> {
    let Rm = 0b1101; // NLdSt will assign to the right encoding bits.
    let Inst{5-4} = Rn{5-4};
    let DecoderMethod = "DecodeVLDST2Instruction";
    let AsmMatchConverter = "cvtVSTwbFixed";
  }
  def _register : NLdSt<0, 0b00, 0b0011, op7_4, (outs GPR:$wb),
                        (ins addrmode6:$Rn, rGPR:$Rm, VecListFourD:$Vd),
                        IIC_VLD1u,
                        "vst2", Dt, "$Vd, $Rn, $Rm",
                        "$Rn.addr = $wb", []> {
    let Inst{5-4} = Rn{5-4};
    let DecoderMethod = "DecodeVLDST2Instruction";
    let AsmMatchConverter = "cvtVSTwbRegister";
  }
}

defm VST2d8wb    : VST2DWB<0b1000, {0,0,?,?}, "8",  VecListDPair>;
defm VST2d16wb   : VST2DWB<0b1000, {0,1,?,?}, "16", VecListDPair>;
defm VST2d32wb   : VST2DWB<0b1000, {1,0,?,?}, "32", VecListDPair>;

defm VST2q8wb    : VST2QWB<{0,0,?,?}, "8">;
defm VST2q16wb   : VST2QWB<{0,1,?,?}, "16">;
defm VST2q32wb   : VST2QWB<{1,0,?,?}, "32">;

def VST2q8PseudoWB_fixed     : VSTQQWBfixedPseudo<IIC_VST2x2u>;
def VST2q16PseudoWB_fixed    : VSTQQWBfixedPseudo<IIC_VST2x2u>;
def VST2q32PseudoWB_fixed    : VSTQQWBfixedPseudo<IIC_VST2x2u>;
def VST2q8PseudoWB_register  : VSTQQWBregisterPseudo<IIC_VST2x2u>;
def VST2q16PseudoWB_register : VSTQQWBregisterPseudo<IIC_VST2x2u>;
def VST2q32PseudoWB_register : VSTQQWBregisterPseudo<IIC_VST2x2u>;

// ...with double-spaced registers
def VST2b8      : VST2<0b1001, {0,0,?,?}, "8",  VecListDPairSpaced, IIC_VST2>;
def VST2b16     : VST2<0b1001, {0,1,?,?}, "16", VecListDPairSpaced, IIC_VST2>;
def VST2b32     : VST2<0b1001, {1,0,?,?}, "32", VecListDPairSpaced, IIC_VST2>;
defm VST2b8wb   : VST2DWB<0b1001, {0,0,?,?}, "8",  VecListDPairSpaced>;
defm VST2b16wb  : VST2DWB<0b1001, {0,1,?,?}, "16", VecListDPairSpaced>;
defm VST2b32wb  : VST2DWB<0b1001, {1,0,?,?}, "32", VecListDPairSpaced>;

//   VST3     : Vector Store (multiple 3-element structures)
class VST3D<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdSt<0, 0b00, op11_8, op7_4, (outs),
          (ins addrmode6:$Rn, DPR:$Vd, DPR:$src2, DPR:$src3), IIC_VST3,
          "vst3", Dt, "\\{$Vd, $src2, $src3\\}, $Rn", "", []> {
  let Rm = 0b1111;
  let Inst{4} = Rn{4};
  let DecoderMethod = "DecodeVLDST3Instruction";
}

def  VST3d8   : VST3D<0b0100, {0,0,0,?}, "8">;
def  VST3d16  : VST3D<0b0100, {0,1,0,?}, "16">;
def  VST3d32  : VST3D<0b0100, {1,0,0,?}, "32">;

def  VST3d8Pseudo  : VSTQQPseudo<IIC_VST3>;
def  VST3d16Pseudo : VSTQQPseudo<IIC_VST3>;
def  VST3d32Pseudo : VSTQQPseudo<IIC_VST3>;

// ...with address register writeback:
class VST3DWB<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdSt<0, 0b00, op11_8, op7_4, (outs GPR:$wb),
          (ins addrmode6:$Rn, am6offset:$Rm,
           DPR:$Vd, DPR:$src2, DPR:$src3), IIC_VST3u,
          "vst3", Dt, "\\{$Vd, $src2, $src3\\}, $Rn$Rm",
          "$Rn.addr = $wb", []> {
  let Inst{4} = Rn{4};
  let DecoderMethod = "DecodeVLDST3Instruction";
}

def VST3d8_UPD  : VST3DWB<0b0100, {0,0,0,?}, "8">;
def VST3d16_UPD : VST3DWB<0b0100, {0,1,0,?}, "16">;
def VST3d32_UPD : VST3DWB<0b0100, {1,0,0,?}, "32">;

def VST3d8Pseudo_UPD  : VSTQQWBPseudo<IIC_VST3u>;
def VST3d16Pseudo_UPD : VSTQQWBPseudo<IIC_VST3u>;
def VST3d32Pseudo_UPD : VSTQQWBPseudo<IIC_VST3u>;

// ...with double-spaced registers:
def VST3q8      : VST3D<0b0101, {0,0,0,?}, "8">;
def VST3q16     : VST3D<0b0101, {0,1,0,?}, "16">;
def VST3q32     : VST3D<0b0101, {1,0,0,?}, "32">;
def VST3q8_UPD  : VST3DWB<0b0101, {0,0,0,?}, "8">;
def VST3q16_UPD : VST3DWB<0b0101, {0,1,0,?}, "16">;
def VST3q32_UPD : VST3DWB<0b0101, {1,0,0,?}, "32">;

def VST3q8Pseudo_UPD  : VSTQQQQWBPseudo<IIC_VST3u>;
def VST3q16Pseudo_UPD : VSTQQQQWBPseudo<IIC_VST3u>;
def VST3q32Pseudo_UPD : VSTQQQQWBPseudo<IIC_VST3u>;

// ...alternate versions to be allocated odd register numbers:
def VST3q8oddPseudo   : VSTQQQQPseudo<IIC_VST3>;
def VST3q16oddPseudo  : VSTQQQQPseudo<IIC_VST3>;
def VST3q32oddPseudo  : VSTQQQQPseudo<IIC_VST3>;

def VST3q8oddPseudo_UPD  : VSTQQQQWBPseudo<IIC_VST3u>;
def VST3q16oddPseudo_UPD : VSTQQQQWBPseudo<IIC_VST3u>;
def VST3q32oddPseudo_UPD : VSTQQQQWBPseudo<IIC_VST3u>;

//   VST4     : Vector Store (multiple 4-element structures)
class VST4D<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdSt<0, 0b00, op11_8, op7_4, (outs),
          (ins addrmode6:$Rn, DPR:$Vd, DPR:$src2, DPR:$src3, DPR:$src4),
          IIC_VST4, "vst4", Dt, "\\{$Vd, $src2, $src3, $src4\\}, $Rn",
          "", []> {
  let Rm = 0b1111;
  let Inst{5-4} = Rn{5-4};
  let DecoderMethod = "DecodeVLDST4Instruction";
}

def  VST4d8   : VST4D<0b0000, {0,0,?,?}, "8">;
def  VST4d16  : VST4D<0b0000, {0,1,?,?}, "16">;
def  VST4d32  : VST4D<0b0000, {1,0,?,?}, "32">;

def  VST4d8Pseudo  : VSTQQPseudo<IIC_VST4>;
def  VST4d16Pseudo : VSTQQPseudo<IIC_VST4>;
def  VST4d32Pseudo : VSTQQPseudo<IIC_VST4>;

// ...with address register writeback:
class VST4DWB<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdSt<0, 0b00, op11_8, op7_4, (outs GPR:$wb),
          (ins addrmode6:$Rn, am6offset:$Rm,
           DPR:$Vd, DPR:$src2, DPR:$src3, DPR:$src4), IIC_VST4u,
           "vst4", Dt, "\\{$Vd, $src2, $src3, $src4\\}, $Rn$Rm",
          "$Rn.addr = $wb", []> {
  let Inst{5-4} = Rn{5-4};
  let DecoderMethod = "DecodeVLDST4Instruction";
}

def VST4d8_UPD  : VST4DWB<0b0000, {0,0,?,?}, "8">;
def VST4d16_UPD : VST4DWB<0b0000, {0,1,?,?}, "16">;
def VST4d32_UPD : VST4DWB<0b0000, {1,0,?,?}, "32">;

def VST4d8Pseudo_UPD  : VSTQQWBPseudo<IIC_VST4u>;
def VST4d16Pseudo_UPD : VSTQQWBPseudo<IIC_VST4u>;
def VST4d32Pseudo_UPD : VSTQQWBPseudo<IIC_VST4u>;

// ...with double-spaced registers:
def VST4q8      : VST4D<0b0001, {0,0,?,?}, "8">;
def VST4q16     : VST4D<0b0001, {0,1,?,?}, "16">;
def VST4q32     : VST4D<0b0001, {1,0,?,?}, "32">;
def VST4q8_UPD  : VST4DWB<0b0001, {0,0,?,?}, "8">;
def VST4q16_UPD : VST4DWB<0b0001, {0,1,?,?}, "16">;
def VST4q32_UPD : VST4DWB<0b0001, {1,0,?,?}, "32">;

def VST4q8Pseudo_UPD  : VSTQQQQWBPseudo<IIC_VST4u>;
def VST4q16Pseudo_UPD : VSTQQQQWBPseudo<IIC_VST4u>;
def VST4q32Pseudo_UPD : VSTQQQQWBPseudo<IIC_VST4u>;

// ...alternate versions to be allocated odd register numbers:
def VST4q8oddPseudo   : VSTQQQQPseudo<IIC_VST4>;
def VST4q16oddPseudo  : VSTQQQQPseudo<IIC_VST4>;
def VST4q32oddPseudo  : VSTQQQQPseudo<IIC_VST4>;

def VST4q8oddPseudo_UPD  : VSTQQQQWBPseudo<IIC_VST4u>;
def VST4q16oddPseudo_UPD : VSTQQQQWBPseudo<IIC_VST4u>;
def VST4q32oddPseudo_UPD : VSTQQQQWBPseudo<IIC_VST4u>;

} // mayStore = 1, neverHasSideEffects = 1, hasExtraSrcRegAllocReq = 1

// Classes for VST*LN pseudo-instructions with multi-register operands.
// These are expanded to real instructions after register allocation.
class VSTQLNPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs), (ins addrmode6:$addr, QPR:$src, nohash_imm:$lane),
                itin, "">;
class VSTQLNWBPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs GPR:$wb),
                (ins addrmode6:$addr, am6offset:$offset, QPR:$src,
                 nohash_imm:$lane), itin, "$addr.addr = $wb">;
class VSTQQLNPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs), (ins addrmode6:$addr, QQPR:$src, nohash_imm:$lane),
                itin, "">;
class VSTQQLNWBPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs GPR:$wb),
                (ins addrmode6:$addr, am6offset:$offset, QQPR:$src,
                 nohash_imm:$lane), itin, "$addr.addr = $wb">;
class VSTQQQQLNPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs), (ins addrmode6:$addr, QQQQPR:$src, nohash_imm:$lane),
                itin, "">;
class VSTQQQQLNWBPseudo<InstrItinClass itin>
  : PseudoNLdSt<(outs GPR:$wb),
                (ins addrmode6:$addr, am6offset:$offset, QQQQPR:$src,
                 nohash_imm:$lane), itin, "$addr.addr = $wb">;

//   VST1LN   : Vector Store (single element from one lane)
class VST1LN<bits<4> op11_8, bits<4> op7_4, string Dt, ValueType Ty,
             PatFrag StoreOp, SDNode ExtractOp, Operand AddrMode>
  : NLdStLn<1, 0b00, op11_8, op7_4, (outs),
          (ins AddrMode:$Rn, DPR:$Vd, nohash_imm:$lane),
          IIC_VST1ln, "vst1", Dt, "\\{$Vd[$lane]\\}, $Rn", "",
          [(StoreOp (ExtractOp (Ty DPR:$Vd), imm:$lane), AddrMode:$Rn)]> {
  let Rm = 0b1111;
  let DecoderMethod = "DecodeVST1LN";
}
class VST1QLNPseudo<ValueType Ty, PatFrag StoreOp, SDNode ExtractOp>
  : VSTQLNPseudo<IIC_VST1ln> {
  let Pattern = [(StoreOp (ExtractOp (Ty QPR:$src), imm:$lane),
                          addrmode6:$addr)];
}

def VST1LNd8  : VST1LN<0b0000, {?,?,?,0}, "8", v8i8, truncstorei8,
                       NEONvgetlaneu, addrmode6> {
  let Inst{7-5} = lane{2-0};
}
def VST1LNd16 : VST1LN<0b0100, {?,?,0,?}, "16", v4i16, truncstorei16,
                       NEONvgetlaneu, addrmode6> {
  let Inst{7-6} = lane{1-0};
  let Inst{4}   = Rn{4};
}

def VST1LNd32 : VST1LN<0b1000, {?,0,?,?}, "32", v2i32, store, extractelt,
                       addrmode6oneL32> {
  let Inst{7}   = lane{0};
  let Inst{5-4} = Rn{5-4};
}

def VST1LNq8Pseudo  : VST1QLNPseudo<v16i8, truncstorei8, NEONvgetlaneu>;
def VST1LNq16Pseudo : VST1QLNPseudo<v8i16, truncstorei16, NEONvgetlaneu>;
def VST1LNq32Pseudo : VST1QLNPseudo<v4i32, store, extractelt>;

def : Pat<(store (extractelt (v2f32 DPR:$src), imm:$lane), addrmode6:$addr),
          (VST1LNd32 addrmode6:$addr, DPR:$src, imm:$lane)>;
def : Pat<(store (extractelt (v4f32 QPR:$src), imm:$lane), addrmode6:$addr),
          (VST1LNq32Pseudo addrmode6:$addr, QPR:$src, imm:$lane)>;

// ...with address register writeback:
class VST1LNWB<bits<4> op11_8, bits<4> op7_4, string Dt, ValueType Ty,
               PatFrag StoreOp, SDNode ExtractOp, Operand AdrMode>
  : NLdStLn<1, 0b00, op11_8, op7_4, (outs GPR:$wb),
          (ins AdrMode:$Rn, am6offset:$Rm,
           DPR:$Vd, nohash_imm:$lane), IIC_VST1lnu, "vst1", Dt,
          "\\{$Vd[$lane]\\}, $Rn$Rm",
          "$Rn.addr = $wb",
          [(set GPR:$wb, (StoreOp (ExtractOp (Ty DPR:$Vd), imm:$lane),
                                  AdrMode:$Rn, am6offset:$Rm))]> {
  let DecoderMethod = "DecodeVST1LN";
}
class VST1QLNWBPseudo<ValueType Ty, PatFrag StoreOp, SDNode ExtractOp>
  : VSTQLNWBPseudo<IIC_VST1lnu> {
  let Pattern = [(set GPR:$wb, (StoreOp (ExtractOp (Ty QPR:$src), imm:$lane),
                                        addrmode6:$addr, am6offset:$offset))];
}

def VST1LNd8_UPD  : VST1LNWB<0b0000, {?,?,?,0}, "8", v8i8, post_truncsti8,
                             NEONvgetlaneu, addrmode6> {
  let Inst{7-5} = lane{2-0};
}
def VST1LNd16_UPD : VST1LNWB<0b0100, {?,?,0,?}, "16", v4i16, post_truncsti16,
                             NEONvgetlaneu, addrmode6> {
  let Inst{7-6} = lane{1-0};
  let Inst{4}   = Rn{4};
}
def VST1LNd32_UPD : VST1LNWB<0b1000, {?,0,?,?}, "32", v2i32, post_store,
                             extractelt, addrmode6oneL32> {
  let Inst{7}   = lane{0};
  let Inst{5-4} = Rn{5-4};
}

def VST1LNq8Pseudo_UPD  : VST1QLNWBPseudo<v16i8, post_truncsti8, NEONvgetlaneu>;
def VST1LNq16Pseudo_UPD : VST1QLNWBPseudo<v8i16, post_truncsti16,NEONvgetlaneu>;
def VST1LNq32Pseudo_UPD : VST1QLNWBPseudo<v4i32, post_store, extractelt>;

let mayStore = 1, neverHasSideEffects = 1, hasExtraSrcRegAllocReq = 1 in {

//   VST2LN   : Vector Store (single 2-element structure from one lane)
class VST2LN<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdStLn<1, 0b00, op11_8, op7_4, (outs),
          (ins addrmode6:$Rn, DPR:$Vd, DPR:$src2, nohash_imm:$lane),
          IIC_VST2ln, "vst2", Dt, "\\{$Vd[$lane], $src2[$lane]\\}, $Rn",
          "", []> {
  let Rm = 0b1111;
  let Inst{4}   = Rn{4};
  let DecoderMethod = "DecodeVST2LN";
}

def VST2LNd8  : VST2LN<0b0001, {?,?,?,?}, "8"> {
  let Inst{7-5} = lane{2-0};
}
def VST2LNd16 : VST2LN<0b0101, {?,?,0,?}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VST2LNd32 : VST2LN<0b1001, {?,0,0,?}, "32"> {
  let Inst{7}   = lane{0};
}

def VST2LNd8Pseudo  : VSTQLNPseudo<IIC_VST2ln>;
def VST2LNd16Pseudo : VSTQLNPseudo<IIC_VST2ln>;
def VST2LNd32Pseudo : VSTQLNPseudo<IIC_VST2ln>;

// ...with double-spaced registers:
def VST2LNq16 : VST2LN<0b0101, {?,?,1,?}, "16"> {
  let Inst{7-6} = lane{1-0};
  let Inst{4}   = Rn{4};
}
def VST2LNq32 : VST2LN<0b1001, {?,1,0,?}, "32"> {
  let Inst{7}   = lane{0};
  let Inst{4}   = Rn{4};
}

def VST2LNq16Pseudo : VSTQQLNPseudo<IIC_VST2ln>;
def VST2LNq32Pseudo : VSTQQLNPseudo<IIC_VST2ln>;

// ...with address register writeback:
class VST2LNWB<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdStLn<1, 0b00, op11_8, op7_4, (outs GPR:$wb),
          (ins addrmode6:$Rn, am6offset:$Rm,
           DPR:$Vd, DPR:$src2, nohash_imm:$lane), IIC_VST2lnu, "vst2", Dt,
          "\\{$Vd[$lane], $src2[$lane]\\}, $Rn$Rm",
          "$Rn.addr = $wb", []> {
  let Inst{4}   = Rn{4};
  let DecoderMethod = "DecodeVST2LN";
}

def VST2LNd8_UPD  : VST2LNWB<0b0001, {?,?,?,?}, "8"> {
  let Inst{7-5} = lane{2-0};
}
def VST2LNd16_UPD : VST2LNWB<0b0101, {?,?,0,?}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VST2LNd32_UPD : VST2LNWB<0b1001, {?,0,0,?}, "32"> {
  let Inst{7}   = lane{0};
}

def VST2LNd8Pseudo_UPD  : VSTQLNWBPseudo<IIC_VST2lnu>;
def VST2LNd16Pseudo_UPD : VSTQLNWBPseudo<IIC_VST2lnu>;
def VST2LNd32Pseudo_UPD : VSTQLNWBPseudo<IIC_VST2lnu>;

def VST2LNq16_UPD : VST2LNWB<0b0101, {?,?,1,?}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VST2LNq32_UPD : VST2LNWB<0b1001, {?,1,0,?}, "32"> {
  let Inst{7}   = lane{0};
}

def VST2LNq16Pseudo_UPD : VSTQQLNWBPseudo<IIC_VST2lnu>;
def VST2LNq32Pseudo_UPD : VSTQQLNWBPseudo<IIC_VST2lnu>;

//   VST3LN   : Vector Store (single 3-element structure from one lane)
class VST3LN<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdStLn<1, 0b00, op11_8, op7_4, (outs),
          (ins addrmode6:$Rn, DPR:$Vd, DPR:$src2, DPR:$src3,
           nohash_imm:$lane), IIC_VST3ln, "vst3", Dt,
          "\\{$Vd[$lane], $src2[$lane], $src3[$lane]\\}, $Rn", "", []> {
  let Rm = 0b1111;
  let DecoderMethod = "DecodeVST3LN";
}

def VST3LNd8  : VST3LN<0b0010, {?,?,?,0}, "8"> {
  let Inst{7-5} = lane{2-0};
}
def VST3LNd16 : VST3LN<0b0110, {?,?,0,0}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VST3LNd32 : VST3LN<0b1010, {?,0,0,0}, "32"> {
  let Inst{7}   = lane{0};
}

def VST3LNd8Pseudo  : VSTQQLNPseudo<IIC_VST3ln>;
def VST3LNd16Pseudo : VSTQQLNPseudo<IIC_VST3ln>;
def VST3LNd32Pseudo : VSTQQLNPseudo<IIC_VST3ln>;

// ...with double-spaced registers:
def VST3LNq16 : VST3LN<0b0110, {?,?,1,0}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VST3LNq32 : VST3LN<0b1010, {?,1,0,0}, "32"> {
  let Inst{7}   = lane{0};
}

def VST3LNq16Pseudo : VSTQQQQLNPseudo<IIC_VST3ln>;
def VST3LNq32Pseudo : VSTQQQQLNPseudo<IIC_VST3ln>;

// ...with address register writeback:
class VST3LNWB<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdStLn<1, 0b00, op11_8, op7_4, (outs GPR:$wb),
          (ins addrmode6:$Rn, am6offset:$Rm,
           DPR:$Vd, DPR:$src2, DPR:$src3, nohash_imm:$lane),
          IIC_VST3lnu, "vst3", Dt,
          "\\{$Vd[$lane], $src2[$lane], $src3[$lane]\\}, $Rn$Rm",
          "$Rn.addr = $wb", []> {
  let DecoderMethod = "DecodeVST3LN";
}

def VST3LNd8_UPD  : VST3LNWB<0b0010, {?,?,?,0}, "8"> {
  let Inst{7-5} = lane{2-0};
}
def VST3LNd16_UPD : VST3LNWB<0b0110, {?,?,0,0}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VST3LNd32_UPD : VST3LNWB<0b1010, {?,0,0,0}, "32"> {
  let Inst{7}   = lane{0};
}

def VST3LNd8Pseudo_UPD  : VSTQQLNWBPseudo<IIC_VST3lnu>;
def VST3LNd16Pseudo_UPD : VSTQQLNWBPseudo<IIC_VST3lnu>;
def VST3LNd32Pseudo_UPD : VSTQQLNWBPseudo<IIC_VST3lnu>;

def VST3LNq16_UPD : VST3LNWB<0b0110, {?,?,1,0}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VST3LNq32_UPD : VST3LNWB<0b1010, {?,1,0,0}, "32"> {
  let Inst{7}   = lane{0};
}

def VST3LNq16Pseudo_UPD : VSTQQQQLNWBPseudo<IIC_VST3lnu>;
def VST3LNq32Pseudo_UPD : VSTQQQQLNWBPseudo<IIC_VST3lnu>;

//   VST4LN   : Vector Store (single 4-element structure from one lane)
class VST4LN<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdStLn<1, 0b00, op11_8, op7_4, (outs),
          (ins addrmode6:$Rn, DPR:$Vd, DPR:$src2, DPR:$src3, DPR:$src4,
           nohash_imm:$lane), IIC_VST4ln, "vst4", Dt,
          "\\{$Vd[$lane], $src2[$lane], $src3[$lane], $src4[$lane]\\}, $Rn",
          "", []> {
  let Rm = 0b1111;
  let Inst{4} = Rn{4};
  let DecoderMethod = "DecodeVST4LN";
}

def VST4LNd8  : VST4LN<0b0011, {?,?,?,?}, "8"> {
  let Inst{7-5} = lane{2-0};
}
def VST4LNd16 : VST4LN<0b0111, {?,?,0,?}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VST4LNd32 : VST4LN<0b1011, {?,0,?,?}, "32"> {
  let Inst{7}   = lane{0};
  let Inst{5} = Rn{5};
}

def VST4LNd8Pseudo  : VSTQQLNPseudo<IIC_VST4ln>;
def VST4LNd16Pseudo : VSTQQLNPseudo<IIC_VST4ln>;
def VST4LNd32Pseudo : VSTQQLNPseudo<IIC_VST4ln>;

// ...with double-spaced registers:
def VST4LNq16 : VST4LN<0b0111, {?,?,1,?}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VST4LNq32 : VST4LN<0b1011, {?,1,?,?}, "32"> {
  let Inst{7}   = lane{0};
  let Inst{5} = Rn{5};
}

def VST4LNq16Pseudo : VSTQQQQLNPseudo<IIC_VST4ln>;
def VST4LNq32Pseudo : VSTQQQQLNPseudo<IIC_VST4ln>;

// ...with address register writeback:
class VST4LNWB<bits<4> op11_8, bits<4> op7_4, string Dt>
  : NLdStLn<1, 0b00, op11_8, op7_4, (outs GPR:$wb),
          (ins addrmode6:$Rn, am6offset:$Rm,
           DPR:$Vd, DPR:$src2, DPR:$src3, DPR:$src4, nohash_imm:$lane),
          IIC_VST4lnu, "vst4", Dt,
  "\\{$Vd[$lane], $src2[$lane], $src3[$lane], $src4[$lane]\\}, $Rn$Rm",
          "$Rn.addr = $wb", []> {
  let Inst{4} = Rn{4};
  let DecoderMethod = "DecodeVST4LN";
}

def VST4LNd8_UPD  : VST4LNWB<0b0011, {?,?,?,?}, "8"> {
  let Inst{7-5} = lane{2-0};
}
def VST4LNd16_UPD : VST4LNWB<0b0111, {?,?,0,?}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VST4LNd32_UPD : VST4LNWB<0b1011, {?,0,?,?}, "32"> {
  let Inst{7}   = lane{0};
  let Inst{5} = Rn{5};
}

def VST4LNd8Pseudo_UPD  : VSTQQLNWBPseudo<IIC_VST4lnu>;
def VST4LNd16Pseudo_UPD : VSTQQLNWBPseudo<IIC_VST4lnu>;
def VST4LNd32Pseudo_UPD : VSTQQLNWBPseudo<IIC_VST4lnu>;

def VST4LNq16_UPD : VST4LNWB<0b0111, {?,?,1,?}, "16"> {
  let Inst{7-6} = lane{1-0};
}
def VST4LNq32_UPD : VST4LNWB<0b1011, {?,1,?,?}, "32"> {
  let Inst{7}   = lane{0};
  let Inst{5} = Rn{5};
}

def VST4LNq16Pseudo_UPD : VSTQQQQLNWBPseudo<IIC_VST4lnu>;
def VST4LNq32Pseudo_UPD : VSTQQQQLNWBPseudo<IIC_VST4lnu>;

} // mayStore = 1, neverHasSideEffects = 1, hasExtraSrcRegAllocReq = 1

// Use vld1/vst1 for unaligned f64 load / store
def : Pat<(f64 (hword_alignedload addrmode6:$addr)),
          (VLD1d16 addrmode6:$addr)>, Requires<[IsLE]>;
def : Pat<(hword_alignedstore (f64 DPR:$value), addrmode6:$addr),
          (VST1d16 addrmode6:$addr, DPR:$value)>, Requires<[IsLE]>;
def : Pat<(f64 (byte_alignedload addrmode6:$addr)),
          (VLD1d8 addrmode6:$addr)>, Requires<[IsLE]>;
def : Pat<(byte_alignedstore (f64 DPR:$value), addrmode6:$addr),
          (VST1d8 addrmode6:$addr, DPR:$value)>, Requires<[IsLE]>;
def : Pat<(f64 (non_word_alignedload addrmode6:$addr)),
          (VLD1d64 addrmode6:$addr)>, Requires<[IsBE]>;
def : Pat<(non_word_alignedstore (f64 DPR:$value), addrmode6:$addr),
          (VST1d64 addrmode6:$addr, DPR:$value)>, Requires<[IsBE]>;

// Use vld1/vst1 for Q and QQ. Also use them for unaligned v2f64
// load / store if it's legal.
def : Pat<(v2f64 (dword_alignedload addrmode6:$addr)),
          (VLD1q64 addrmode6:$addr)>;
def : Pat<(dword_alignedstore (v2f64 QPR:$value), addrmode6:$addr),
          (VST1q64 addrmode6:$addr, QPR:$value)>;
def : Pat<(v2f64 (word_alignedload addrmode6:$addr)),
          (VLD1q32 addrmode6:$addr)>;
def : Pat<(word_alignedstore (v2f64 QPR:$value), addrmode6:$addr),
          (VST1q32 addrmode6:$addr, QPR:$value)>;
def : Pat<(v2f64 (hword_alignedload addrmode6:$addr)),
          (VLD1q16 addrmode6:$addr)>, Requires<[IsLE]>;
def : Pat<(hword_alignedstore (v2f64 QPR:$value), addrmode6:$addr),
          (VST1q16 addrmode6:$addr, QPR:$value)>, Requires<[IsLE]>;
def : Pat<(v2f64 (byte_alignedload addrmode6:$addr)),
          (VLD1q8 addrmode6:$addr)>, Requires<[IsLE]>;
def : Pat<(byte_alignedstore (v2f64 QPR:$value), addrmode6:$addr),
          (VST1q8 addrmode6:$addr, QPR:$value)>, Requires<[IsLE]>;

//===----------------------------------------------------------------------===//
// NEON pattern fragments
//===----------------------------------------------------------------------===//

// Extract D sub-registers of Q registers.
def DSubReg_i8_reg  : SDNodeXForm<imm, [{
  assert(ARM::dsub_7 == ARM::dsub_0+7 && "Unexpected subreg numbering");
  return CurDAG->getTargetConstant(ARM::dsub_0 + N->getZExtValue()/8, MVT::i32);
}]>;
def DSubReg_i16_reg : SDNodeXForm<imm, [{
  assert(ARM::dsub_7 == ARM::dsub_0+7 && "Unexpected subreg numbering");
  return CurDAG->getTargetConstant(ARM::dsub_0 + N->getZExtValue()/4, MVT::i32);
}]>;
def DSubReg_i32_reg : SDNodeXForm<imm, [{
  assert(ARM::dsub_7 == ARM::dsub_0+7 && "Unexpected subreg numbering");
  return CurDAG->getTargetConstant(ARM::dsub_0 + N->getZExtValue()/2, MVT::i32);
}]>;
def DSubReg_f64_reg : SDNodeXForm<imm, [{
  assert(ARM::dsub_7 == ARM::dsub_0+7 && "Unexpected subreg numbering");
  return CurDAG->getTargetConstant(ARM::dsub_0 + N->getZExtValue(), MVT::i32);
}]>;

// Extract S sub-registers of Q/D registers.
def SSubReg_f32_reg : SDNodeXForm<imm, [{
  assert(ARM::ssub_3 == ARM::ssub_0+3 && "Unexpected subreg numbering");
  return CurDAG->getTargetConstant(ARM::ssub_0 + N->getZExtValue(), MVT::i32);
}]>;

// Translate lane numbers from Q registers to D subregs.
def SubReg_i8_lane  : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(N->getZExtValue() & 7, MVT::i32);
}]>;
def SubReg_i16_lane : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(N->getZExtValue() & 3, MVT::i32);
}]>;
def SubReg_i32_lane : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(N->getZExtValue() & 1, MVT::i32);
}]>;

//===----------------------------------------------------------------------===//
// Instruction Classes
//===----------------------------------------------------------------------===//

// Basic 2-register operations: double- and quad-register.
class N2VD<bits<2> op24_23, bits<2> op21_20, bits<2> op19_18,
           bits<2> op17_16, bits<5> op11_7, bit op4, string OpcodeStr,
           string Dt, ValueType ResTy, ValueType OpTy, SDNode OpNode>
  : N2V<op24_23, op21_20, op19_18, op17_16, op11_7, 0, op4, (outs DPR:$Vd),
        (ins DPR:$Vm), IIC_VUNAD, OpcodeStr, Dt,"$Vd, $Vm", "",
        [(set DPR:$Vd, (ResTy (OpNode (OpTy DPR:$Vm))))]>;
class N2VQ<bits<2> op24_23, bits<2> op21_20, bits<2> op19_18,
           bits<2> op17_16, bits<5> op11_7, bit op4, string OpcodeStr,
           string Dt, ValueType ResTy, ValueType OpTy, SDNode OpNode>
  : N2V<op24_23, op21_20, op19_18, op17_16, op11_7, 1, op4, (outs QPR:$Vd),
        (ins QPR:$Vm), IIC_VUNAQ, OpcodeStr, Dt,"$Vd, $Vm", "",
        [(set QPR:$Vd, (ResTy (OpNode (OpTy QPR:$Vm))))]>;

// Basic 2-register intrinsics, both double- and quad-register.
class N2VDInt<bits<2> op24_23, bits<2> op21_20, bits<2> op19_18,
              bits<2> op17_16, bits<5> op11_7, bit op4,
              InstrItinClass itin, string OpcodeStr, string Dt,
              ValueType ResTy, ValueType OpTy, SDPatternOperator IntOp>
  : N2V<op24_23, op21_20, op19_18, op17_16, op11_7, 0, op4, (outs DPR:$Vd),
        (ins DPR:$Vm), itin, OpcodeStr, Dt, "$Vd, $Vm", "",
        [(set DPR:$Vd, (ResTy (IntOp (OpTy DPR:$Vm))))]>;
class N2VQInt<bits<2> op24_23, bits<2> op21_20, bits<2> op19_18,
              bits<2> op17_16, bits<5> op11_7, bit op4,
              InstrItinClass itin, string OpcodeStr, string Dt,
              ValueType ResTy, ValueType OpTy, SDPatternOperator IntOp>
  : N2V<op24_23, op21_20, op19_18, op17_16, op11_7, 1, op4, (outs QPR:$Vd),
        (ins QPR:$Vm), itin, OpcodeStr, Dt, "$Vd, $Vm", "",
        [(set QPR:$Vd, (ResTy (IntOp (OpTy QPR:$Vm))))]>;

// Narrow 2-register operations.
class N2VN<bits<2> op24_23, bits<2> op21_20, bits<2> op19_18,
           bits<2> op17_16, bits<5> op11_7, bit op6, bit op4,
           InstrItinClass itin, string OpcodeStr, string Dt,
           ValueType TyD, ValueType TyQ, SDNode OpNode>
  : N2V<op24_23, op21_20, op19_18, op17_16, op11_7, op6, op4, (outs DPR:$Vd),
        (ins QPR:$Vm), itin, OpcodeStr, Dt, "$Vd, $Vm", "",
        [(set DPR:$Vd, (TyD (OpNode (TyQ QPR:$Vm))))]>;

// Narrow 2-register intrinsics.
class N2VNInt<bits<2> op24_23, bits<2> op21_20, bits<2> op19_18,
              bits<2> op17_16, bits<5> op11_7, bit op6, bit op4,
              InstrItinClass itin, string OpcodeStr, string Dt,
              ValueType TyD, ValueType TyQ, SDPatternOperator IntOp>
  : N2V<op24_23, op21_20, op19_18, op17_16, op11_7, op6, op4, (outs DPR:$Vd),
        (ins QPR:$Vm), itin, OpcodeStr, Dt, "$Vd, $Vm", "",
        [(set DPR:$Vd, (TyD (IntOp (TyQ QPR:$Vm))))]>;

// Long 2-register operations (currently only used for VMOVL).
class N2VL<bits<2> op24_23, bits<2> op21_20, bits<2> op19_18,
           bits<2> op17_16, bits<5> op11_7, bit op6, bit op4,
           InstrItinClass itin, string OpcodeStr, string Dt,
           ValueType TyQ, ValueType TyD, SDNode OpNode>
  : N2V<op24_23, op21_20, op19_18, op17_16, op11_7, op6, op4, (outs QPR:$Vd),
        (ins DPR:$Vm), itin, OpcodeStr, Dt, "$Vd, $Vm", "",
        [(set QPR:$Vd, (TyQ (OpNode (TyD DPR:$Vm))))]>;

// Long 2-register intrinsics.
class N2VLInt<bits<2> op24_23, bits<2> op21_20, bits<2> op19_18,
              bits<2> op17_16, bits<5> op11_7, bit op6, bit op4,
              InstrItinClass itin, string OpcodeStr, string Dt,
              ValueType TyQ, ValueType TyD, SDPatternOperator IntOp>
  : N2V<op24_23, op21_20, op19_18, op17_16, op11_7, op6, op4, (outs QPR:$Vd),
        (ins DPR:$Vm), itin, OpcodeStr, Dt, "$Vd, $Vm", "",
        [(set QPR:$Vd, (TyQ (IntOp (TyD DPR:$Vm))))]>;

// 2-register shuffles (VTRN/VZIP/VUZP), both double- and quad-register.
class N2VDShuffle<bits<2> op19_18, bits<5> op11_7, string OpcodeStr, string Dt>
  : N2V<0b11, 0b11, op19_18, 0b10, op11_7, 0, 0, (outs DPR:$Vd, DPR:$Vm),
        (ins DPR:$src1, DPR:$src2), IIC_VPERMD,
        OpcodeStr, Dt, "$Vd, $Vm",
        "$src1 = $Vd, $src2 = $Vm", []>;
class N2VQShuffle<bits<2> op19_18, bits<5> op11_7,
                  InstrItinClass itin, string OpcodeStr, string Dt>
  : N2V<0b11, 0b11, op19_18, 0b10, op11_7, 1, 0, (outs QPR:$Vd, QPR:$Vm),
        (ins QPR:$src1, QPR:$src2), itin, OpcodeStr, Dt, "$Vd, $Vm",
        "$src1 = $Vd, $src2 = $Vm", []>;

// Basic 3-register operations: double- and quad-register.
class N3VD<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
           InstrItinClass itin, string OpcodeStr, string Dt,
           ValueType ResTy, ValueType OpTy, SDNode OpNode, bit Commutable>
  : N3V<op24, op23, op21_20, op11_8, 0, op4,
        (outs DPR:$Vd), (ins DPR:$Vn, DPR:$Vm), N3RegFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm", "",
        [(set DPR:$Vd, (ResTy (OpNode (OpTy DPR:$Vn), (OpTy DPR:$Vm))))]> {
  // All of these have a two-operand InstAlias.
  let TwoOperandAliasConstraint = "$Vn = $Vd";
  let isCommutable = Commutable;
}
// Same as N3VD but no data type.
class N3VDX<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
           InstrItinClass itin, string OpcodeStr,
           ValueType ResTy, ValueType OpTy,
           SDNode OpNode, bit Commutable>
  : N3VX<op24, op23, op21_20, op11_8, 0, op4,
         (outs DPR:$Vd), (ins DPR:$Vn, DPR:$Vm), N3RegFrm, itin,
         OpcodeStr, "$Vd, $Vn, $Vm", "",
         [(set DPR:$Vd, (ResTy (OpNode (OpTy DPR:$Vn), (OpTy DPR:$Vm))))]>{
  // All of these have a two-operand InstAlias.
  let TwoOperandAliasConstraint = "$Vn = $Vd";
  let isCommutable = Commutable;
}

class N3VDSL<bits<2> op21_20, bits<4> op11_8,
             InstrItinClass itin, string OpcodeStr, string Dt,
             ValueType Ty, SDNode ShOp>
  : N3VLane32<0, 1, op21_20, op11_8, 1, 0,
        (outs DPR:$Vd), (ins DPR:$Vn, DPR_VFP2:$Vm, VectorIndex32:$lane),
        NVMulSLFrm, itin, OpcodeStr, Dt, "$Vd, $Vn, $Vm$lane", "",
        [(set (Ty DPR:$Vd),
              (Ty (ShOp (Ty DPR:$Vn),
                        (Ty (NEONvduplane (Ty DPR_VFP2:$Vm),imm:$lane)))))]> {
  // All of these have a two-operand InstAlias.
  let TwoOperandAliasConstraint = "$Vn = $Vd";
  let isCommutable = 0;
}
class N3VDSL16<bits<2> op21_20, bits<4> op11_8,
               string OpcodeStr, string Dt, ValueType Ty, SDNode ShOp>
  : N3VLane16<0, 1, op21_20, op11_8, 1, 0,
        (outs DPR:$Vd), (ins DPR:$Vn, DPR_8:$Vm, VectorIndex16:$lane),
        NVMulSLFrm, IIC_VMULi16D, OpcodeStr, Dt,"$Vd, $Vn, $Vm$lane","",
        [(set (Ty DPR:$Vd),
              (Ty (ShOp (Ty DPR:$Vn),
                        (Ty (NEONvduplane (Ty DPR_8:$Vm), imm:$lane)))))]> {
  // All of these have a two-operand InstAlias.
  let TwoOperandAliasConstraint = "$Vn = $Vd";
  let isCommutable = 0;
}

class N3VQ<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
           InstrItinClass itin, string OpcodeStr, string Dt,
           ValueType ResTy, ValueType OpTy, SDNode OpNode, bit Commutable>
  : N3V<op24, op23, op21_20, op11_8, 1, op4,
        (outs QPR:$Vd), (ins QPR:$Vn, QPR:$Vm), N3RegFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm", "",
        [(set QPR:$Vd, (ResTy (OpNode (OpTy QPR:$Vn), (OpTy QPR:$Vm))))]> {
  // All of these have a two-operand InstAlias.
  let TwoOperandAliasConstraint = "$Vn = $Vd";
  let isCommutable = Commutable;
}
class N3VQX<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
           InstrItinClass itin, string OpcodeStr,
           ValueType ResTy, ValueType OpTy, SDNode OpNode, bit Commutable>
  : N3VX<op24, op23, op21_20, op11_8, 1, op4,
         (outs QPR:$Vd), (ins QPR:$Vn, QPR:$Vm), N3RegFrm, itin,
         OpcodeStr, "$Vd, $Vn, $Vm", "",
         [(set QPR:$Vd, (ResTy (OpNode (OpTy QPR:$Vn), (OpTy QPR:$Vm))))]>{
  // All of these have a two-operand InstAlias.
  let TwoOperandAliasConstraint = "$Vn = $Vd";
  let isCommutable = Commutable;
}
class N3VQSL<bits<2> op21_20, bits<4> op11_8,
             InstrItinClass itin, string OpcodeStr, string Dt,
             ValueType ResTy, ValueType OpTy, SDNode ShOp>
  : N3VLane32<1, 1, op21_20, op11_8, 1, 0,
        (outs QPR:$Vd), (ins QPR:$Vn, DPR_VFP2:$Vm, VectorIndex32:$lane),
        NVMulSLFrm, itin, OpcodeStr, Dt, "$Vd, $Vn, $Vm$lane", "",
        [(set (ResTy QPR:$Vd),
              (ResTy (ShOp (ResTy QPR:$Vn),
                           (ResTy (NEONvduplane (OpTy DPR_VFP2:$Vm),
                                                imm:$lane)))))]> {
  // All of these have a two-operand InstAlias.
  let TwoOperandAliasConstraint = "$Vn = $Vd";
  let isCommutable = 0;
}
class N3VQSL16<bits<2> op21_20, bits<4> op11_8, string OpcodeStr, string Dt,
               ValueType ResTy, ValueType OpTy, SDNode ShOp>
  : N3VLane16<1, 1, op21_20, op11_8, 1, 0,
        (outs QPR:$Vd), (ins QPR:$Vn, DPR_8:$Vm, VectorIndex16:$lane),
        NVMulSLFrm, IIC_VMULi16Q, OpcodeStr, Dt,"$Vd, $Vn, $Vm$lane", "",
        [(set (ResTy QPR:$Vd),
              (ResTy (ShOp (ResTy QPR:$Vn),
                           (ResTy (NEONvduplane (OpTy DPR_8:$Vm),
                                                imm:$lane)))))]> {
  // All of these have a two-operand InstAlias.
  let TwoOperandAliasConstraint = "$Vn = $Vd";
  let isCommutable = 0;
}

// Basic 3-register intrinsics, both double- and quad-register.
class N3VDInt<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
              Format f, InstrItinClass itin, string OpcodeStr, string Dt,
              ValueType ResTy, ValueType OpTy, SDPatternOperator IntOp, bit Commutable>
  : N3V<op24, op23, op21_20, op11_8, 0, op4,
        (outs DPR:$Vd), (ins DPR:$Vn, DPR:$Vm), f, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm", "",
        [(set DPR:$Vd, (ResTy (IntOp (OpTy DPR:$Vn), (OpTy DPR:$Vm))))]> {
  // All of these have a two-operand InstAlias.
  let TwoOperandAliasConstraint = "$Vn = $Vd";
  let isCommutable = Commutable;
}
class N3VDIntSL<bits<2> op21_20, bits<4> op11_8, InstrItinClass itin,
                string OpcodeStr, string Dt, ValueType Ty, SDPatternOperator IntOp>
  : N3VLane32<0, 1, op21_20, op11_8, 1, 0,
        (outs DPR:$Vd), (ins DPR:$Vn, DPR_VFP2:$Vm, VectorIndex32:$lane),
        NVMulSLFrm, itin, OpcodeStr, Dt, "$Vd, $Vn, $Vm$lane", "",
        [(set (Ty DPR:$Vd),
              (Ty (IntOp (Ty DPR:$Vn),
                         (Ty (NEONvduplane (Ty DPR_VFP2:$Vm),
                                           imm:$lane)))))]> {
  let isCommutable = 0;
}
class N3VDIntSL16<bits<2> op21_20, bits<4> op11_8, InstrItinClass itin,
                  string OpcodeStr, string Dt, ValueType Ty, SDPatternOperator IntOp>
  : N3VLane16<0, 1, op21_20, op11_8, 1, 0,
        (outs DPR:$Vd), (ins DPR:$Vn, DPR_8:$Vm, VectorIndex16:$lane),
        NVMulSLFrm, itin, OpcodeStr, Dt, "$Vd, $Vn, $Vm$lane", "",
        [(set (Ty DPR:$Vd),
              (Ty (IntOp (Ty DPR:$Vn),
                         (Ty (NEONvduplane (Ty DPR_8:$Vm), imm:$lane)))))]> {
  let isCommutable = 0;
}
class N3VDIntSh<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
              Format f, InstrItinClass itin, string OpcodeStr, string Dt,
              ValueType ResTy, ValueType OpTy, SDPatternOperator IntOp>
  : N3V<op24, op23, op21_20, op11_8, 0, op4,
        (outs DPR:$Vd), (ins DPR:$Vm, DPR:$Vn), f, itin,
        OpcodeStr, Dt, "$Vd, $Vm, $Vn", "",
        [(set DPR:$Vd, (ResTy (IntOp (OpTy DPR:$Vm), (OpTy DPR:$Vn))))]> {
  let TwoOperandAliasConstraint = "$Vm = $Vd";
  let isCommutable = 0;
}

class N3VQInt<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
              Format f, InstrItinClass itin, string OpcodeStr, string Dt,
              ValueType ResTy, ValueType OpTy, SDPatternOperator IntOp, bit Commutable>
  : N3V<op24, op23, op21_20, op11_8, 1, op4,
        (outs QPR:$Vd), (ins QPR:$Vn, QPR:$Vm), f, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm", "",
        [(set QPR:$Vd, (ResTy (IntOp (OpTy QPR:$Vn), (OpTy QPR:$Vm))))]> {
  // All of these have a two-operand InstAlias.
  let TwoOperandAliasConstraint = "$Vn = $Vd";
  let isCommutable = Commutable;
}
class N3VQIntSL<bits<2> op21_20, bits<4> op11_8, InstrItinClass itin,
                string OpcodeStr, string Dt,
                ValueType ResTy, ValueType OpTy, SDPatternOperator IntOp>
  : N3VLane32<1, 1, op21_20, op11_8, 1, 0,
        (outs QPR:$Vd), (ins QPR:$Vn, DPR_VFP2:$Vm, VectorIndex32:$lane),
        NVMulSLFrm, itin, OpcodeStr, Dt, "$Vd, $Vn, $Vm$lane", "",
        [(set (ResTy QPR:$Vd),
              (ResTy (IntOp (ResTy QPR:$Vn),
                            (ResTy (NEONvduplane (OpTy DPR_VFP2:$Vm),
                                                 imm:$lane)))))]> {
  let isCommutable = 0;
}
class N3VQIntSL16<bits<2> op21_20, bits<4> op11_8, InstrItinClass itin,
                  string OpcodeStr, string Dt,
                  ValueType ResTy, ValueType OpTy, SDPatternOperator IntOp>
  : N3VLane16<1, 1, op21_20, op11_8, 1, 0,
        (outs QPR:$Vd), (ins QPR:$Vn, DPR_8:$Vm, VectorIndex16:$lane),
        NVMulSLFrm, itin, OpcodeStr, Dt, "$Vd, $Vn, $Vm$lane", "",
        [(set (ResTy QPR:$Vd),
              (ResTy (IntOp (ResTy QPR:$Vn),
                            (ResTy (NEONvduplane (OpTy DPR_8:$Vm),
                                                 imm:$lane)))))]> {
  let isCommutable = 0;
}
class N3VQIntSh<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
              Format f, InstrItinClass itin, string OpcodeStr, string Dt,
              ValueType ResTy, ValueType OpTy, SDPatternOperator IntOp>
  : N3V<op24, op23, op21_20, op11_8, 1, op4,
        (outs QPR:$Vd), (ins QPR:$Vm, QPR:$Vn), f, itin,
        OpcodeStr, Dt, "$Vd, $Vm, $Vn", "",
        [(set QPR:$Vd, (ResTy (IntOp (OpTy QPR:$Vm), (OpTy QPR:$Vn))))]> {
  let TwoOperandAliasConstraint = "$Vm = $Vd";
  let isCommutable = 0;
}

// Multiply-Add/Sub operations: double- and quad-register.
class N3VDMulOp<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
                InstrItinClass itin, string OpcodeStr, string Dt,
                ValueType Ty, SDPatternOperator MulOp, SDPatternOperator OpNode>
  : N3V<op24, op23, op21_20, op11_8, 0, op4,
        (outs DPR:$Vd), (ins DPR:$src1, DPR:$Vn, DPR:$Vm), N3RegFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm", "$src1 = $Vd",
        [(set DPR:$Vd, (Ty (OpNode DPR:$src1,
                             (Ty (MulOp DPR:$Vn, DPR:$Vm)))))]>;

class N3VDMulOpSL<bits<2> op21_20, bits<4> op11_8, InstrItinClass itin,
                  string OpcodeStr, string Dt,
                  ValueType Ty, SDPatternOperator MulOp, SDPatternOperator ShOp>
  : N3VLane32<0, 1, op21_20, op11_8, 1, 0,
        (outs DPR:$Vd),
        (ins DPR:$src1, DPR:$Vn, DPR_VFP2:$Vm, VectorIndex32:$lane),
        NVMulSLFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm$lane", "$src1 = $Vd",
        [(set (Ty DPR:$Vd),
              (Ty (ShOp (Ty DPR:$src1),
                        (Ty (MulOp DPR:$Vn,
                                   (Ty (NEONvduplane (Ty DPR_VFP2:$Vm),
                                                     imm:$lane)))))))]>;
class N3VDMulOpSL16<bits<2> op21_20, bits<4> op11_8, InstrItinClass itin,
                    string OpcodeStr, string Dt,
                    ValueType Ty, SDNode MulOp, SDNode ShOp>
  : N3VLane16<0, 1, op21_20, op11_8, 1, 0,
        (outs DPR:$Vd),
        (ins DPR:$src1, DPR:$Vn, DPR_8:$Vm, VectorIndex16:$lane),
        NVMulSLFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm$lane", "$src1 = $Vd",
        [(set (Ty DPR:$Vd),
              (Ty (ShOp (Ty DPR:$src1),
                        (Ty (MulOp DPR:$Vn,
                                   (Ty (NEONvduplane (Ty DPR_8:$Vm),
                                                     imm:$lane)))))))]>;

class N3VQMulOp<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
                InstrItinClass itin, string OpcodeStr, string Dt, ValueType Ty,
                SDPatternOperator MulOp, SDPatternOperator OpNode>
  : N3V<op24, op23, op21_20, op11_8, 1, op4,
        (outs QPR:$Vd), (ins QPR:$src1, QPR:$Vn, QPR:$Vm), N3RegFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm", "$src1 = $Vd",
        [(set QPR:$Vd, (Ty (OpNode QPR:$src1,
                             (Ty (MulOp QPR:$Vn, QPR:$Vm)))))]>;
class N3VQMulOpSL<bits<2> op21_20, bits<4> op11_8, InstrItinClass itin,
                  string OpcodeStr, string Dt, ValueType ResTy, ValueType OpTy,
                  SDPatternOperator MulOp, SDPatternOperator ShOp>
  : N3VLane32<1, 1, op21_20, op11_8, 1, 0,
        (outs QPR:$Vd),
        (ins QPR:$src1, QPR:$Vn, DPR_VFP2:$Vm, VectorIndex32:$lane),
        NVMulSLFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm$lane", "$src1 = $Vd",
        [(set (ResTy QPR:$Vd),
              (ResTy (ShOp (ResTy QPR:$src1),
                           (ResTy (MulOp QPR:$Vn,
                                   (ResTy (NEONvduplane (OpTy DPR_VFP2:$Vm),
                                                        imm:$lane)))))))]>;
class N3VQMulOpSL16<bits<2> op21_20, bits<4> op11_8, InstrItinClass itin,
                    string OpcodeStr, string Dt,
                    ValueType ResTy, ValueType OpTy,
                    SDNode MulOp, SDNode ShOp>
  : N3VLane16<1, 1, op21_20, op11_8, 1, 0,
        (outs QPR:$Vd),
        (ins QPR:$src1, QPR:$Vn, DPR_8:$Vm, VectorIndex16:$lane),
        NVMulSLFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm$lane", "$src1 = $Vd",
        [(set (ResTy QPR:$Vd),
              (ResTy (ShOp (ResTy QPR:$src1),
                           (ResTy (MulOp QPR:$Vn,
                                   (ResTy (NEONvduplane (OpTy DPR_8:$Vm),
                                                        imm:$lane)))))))]>;

// Neon Intrinsic-Op instructions (VABA): double- and quad-register.
class N3VDIntOp<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
                InstrItinClass itin, string OpcodeStr, string Dt,
                ValueType Ty, SDPatternOperator IntOp, SDNode OpNode>
  : N3V<op24, op23, op21_20, op11_8, 0, op4,
        (outs DPR:$Vd), (ins DPR:$src1, DPR:$Vn, DPR:$Vm), N3RegFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm", "$src1 = $Vd",
        [(set DPR:$Vd, (Ty (OpNode DPR:$src1,
                             (Ty (IntOp (Ty DPR:$Vn), (Ty DPR:$Vm))))))]>;
class N3VQIntOp<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
                InstrItinClass itin, string OpcodeStr, string Dt,
                ValueType Ty, SDPatternOperator IntOp, SDNode OpNode>
  : N3V<op24, op23, op21_20, op11_8, 1, op4,
        (outs QPR:$Vd), (ins QPR:$src1, QPR:$Vn, QPR:$Vm), N3RegFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm", "$src1 = $Vd",
        [(set QPR:$Vd, (Ty (OpNode QPR:$src1,
                             (Ty (IntOp (Ty QPR:$Vn), (Ty QPR:$Vm))))))]>;

// Neon 3-argument intrinsics, both double- and quad-register.
// The destination register is also used as the first source operand register.
class N3VDInt3<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
               InstrItinClass itin, string OpcodeStr, string Dt,
               ValueType ResTy, ValueType OpTy, SDPatternOperator IntOp>
  : N3V<op24, op23, op21_20, op11_8, 0, op4,
        (outs DPR:$Vd), (ins DPR:$src1, DPR:$Vn, DPR:$Vm), N3RegFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm", "$src1 = $Vd",
        [(set DPR:$Vd, (ResTy (IntOp (OpTy DPR:$src1),
                                      (OpTy DPR:$Vn), (OpTy DPR:$Vm))))]>;
class N3VQInt3<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
               InstrItinClass itin, string OpcodeStr, string Dt,
               ValueType ResTy, ValueType OpTy, SDPatternOperator IntOp>
  : N3V<op24, op23, op21_20, op11_8, 1, op4,
        (outs QPR:$Vd), (ins QPR:$src1, QPR:$Vn, QPR:$Vm), N3RegFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm", "$src1 = $Vd",
        [(set QPR:$Vd, (ResTy (IntOp (OpTy QPR:$src1),
                                      (OpTy QPR:$Vn), (OpTy QPR:$Vm))))]>;

// Long Multiply-Add/Sub operations.
class N3VLMulOp<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
                InstrItinClass itin, string OpcodeStr, string Dt,
                ValueType TyQ, ValueType TyD, SDNode MulOp, SDNode OpNode>
  : N3V<op24, op23, op21_20, op11_8, 0, op4,
        (outs QPR:$Vd), (ins QPR:$src1, DPR:$Vn, DPR:$Vm), N3RegFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm", "$src1 = $Vd",
        [(set QPR:$Vd, (OpNode (TyQ QPR:$src1),
                                (TyQ (MulOp (TyD DPR:$Vn),
                                            (TyD DPR:$Vm)))))]>;
class N3VLMulOpSL<bit op24, bits<2> op21_20, bits<4> op11_8,
                  InstrItinClass itin, string OpcodeStr, string Dt,
                  ValueType TyQ, ValueType TyD, SDNode MulOp, SDNode OpNode>
  : N3VLane32<op24, 1, op21_20, op11_8, 1, 0, (outs QPR:$Vd),
        (ins QPR:$src1, DPR:$Vn, DPR_VFP2:$Vm, VectorIndex32:$lane),
        NVMulSLFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm$lane", "$src1 = $Vd",
        [(set QPR:$Vd,
          (OpNode (TyQ QPR:$src1),
                  (TyQ (MulOp (TyD DPR:$Vn),
                              (TyD (NEONvduplane (TyD DPR_VFP2:$Vm),
                                                 imm:$lane))))))]>;
class N3VLMulOpSL16<bit op24, bits<2> op21_20, bits<4> op11_8,
                    InstrItinClass itin, string OpcodeStr, string Dt,
                    ValueType TyQ, ValueType TyD, SDNode MulOp, SDNode OpNode>
  : N3VLane16<op24, 1, op21_20, op11_8, 1, 0, (outs QPR:$Vd),
        (ins QPR:$src1, DPR:$Vn, DPR_8:$Vm, VectorIndex16:$lane),
        NVMulSLFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm$lane", "$src1 = $Vd",
        [(set QPR:$Vd,
          (OpNode (TyQ QPR:$src1),
                  (TyQ (MulOp (TyD DPR:$Vn),
                              (TyD (NEONvduplane (TyD DPR_8:$Vm),
                                                 imm:$lane))))))]>;

// Long Intrinsic-Op vector operations with explicit extend (VABAL).
class N3VLIntExtOp<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
                   InstrItinClass itin, string OpcodeStr, string Dt,
                   ValueType TyQ, ValueType TyD, SDPatternOperator IntOp, SDNode ExtOp,
                   SDNode OpNode>
  : N3V<op24, op23, op21_20, op11_8, 0, op4,
        (outs QPR:$Vd), (ins QPR:$src1, DPR:$Vn, DPR:$Vm), N3RegFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm", "$src1 = $Vd",
        [(set QPR:$Vd, (OpNode (TyQ QPR:$src1),
                                (TyQ (ExtOp (TyD (IntOp (TyD DPR:$Vn),
                                                        (TyD DPR:$Vm)))))))]>;

// Neon Long 3-argument intrinsic.  The destination register is
// a quad-register and is also used as the first source operand register.
class N3VLInt3<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
               InstrItinClass itin, string OpcodeStr, string Dt,
               ValueType TyQ, ValueType TyD, SDPatternOperator IntOp>
  : N3V<op24, op23, op21_20, op11_8, 0, op4,
        (outs QPR:$Vd), (ins QPR:$src1, DPR:$Vn, DPR:$Vm), N3RegFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm", "$src1 = $Vd",
        [(set QPR:$Vd,
          (TyQ (IntOp (TyQ QPR:$src1), (TyD DPR:$Vn), (TyD DPR:$Vm))))]>;
class N3VLInt3SL<bit op24, bits<2> op21_20, bits<4> op11_8, InstrItinClass itin,
                 string OpcodeStr, string Dt,
                 ValueType ResTy, ValueType OpTy, SDPatternOperator IntOp>
  : N3VLane32<op24, 1, op21_20, op11_8, 1, 0,
        (outs QPR:$Vd),
        (ins QPR:$src1, DPR:$Vn, DPR_VFP2:$Vm, VectorIndex32:$lane),
        NVMulSLFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm$lane", "$src1 = $Vd",
        [(set (ResTy QPR:$Vd),
              (ResTy (IntOp (ResTy QPR:$src1),
                            (OpTy DPR:$Vn),
                            (OpTy (NEONvduplane (OpTy DPR_VFP2:$Vm),
                                                imm:$lane)))))]>;
class N3VLInt3SL16<bit op24, bits<2> op21_20, bits<4> op11_8,
                   InstrItinClass itin, string OpcodeStr, string Dt,
                   ValueType ResTy, ValueType OpTy, SDPatternOperator IntOp>
  : N3VLane16<op24, 1, op21_20, op11_8, 1, 0,
        (outs QPR:$Vd),
        (ins QPR:$src1, DPR:$Vn, DPR_8:$Vm, VectorIndex16:$lane),
        NVMulSLFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm$lane", "$src1 = $Vd",
        [(set (ResTy QPR:$Vd),
              (ResTy (IntOp (ResTy QPR:$src1),
                            (OpTy DPR:$Vn),
                            (OpTy (NEONvduplane (OpTy DPR_8:$Vm),
                                                imm:$lane)))))]>;

// Narrowing 3-register intrinsics.
class N3VNInt<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
              string OpcodeStr, string Dt, ValueType TyD, ValueType TyQ,
              SDPatternOperator IntOp, bit Commutable>
  : N3V<op24, op23, op21_20, op11_8, 0, op4,
        (outs DPR:$Vd), (ins QPR:$Vn, QPR:$Vm), N3RegFrm, IIC_VBINi4D,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm", "",
        [(set DPR:$Vd, (TyD (IntOp (TyQ QPR:$Vn), (TyQ QPR:$Vm))))]> {
  let isCommutable = Commutable;
}

// Long 3-register operations.
class N3VL<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
           InstrItinClass itin, string OpcodeStr, string Dt,
           ValueType TyQ, ValueType TyD, SDNode OpNode, bit Commutable>
  : N3V<op24, op23, op21_20, op11_8, 0, op4,
        (outs QPR:$Vd), (ins DPR:$Vn, DPR:$Vm), N3RegFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm", "",
        [(set QPR:$Vd, (TyQ (OpNode (TyD DPR:$Vn), (TyD DPR:$Vm))))]> {
  let isCommutable = Commutable;
}
class N3VLSL<bit op24, bits<2> op21_20, bits<4> op11_8,
             InstrItinClass itin, string OpcodeStr, string Dt,
             ValueType TyQ, ValueType TyD, SDNode OpNode>
  : N3VLane32<op24, 1, op21_20, op11_8, 1, 0,
        (outs QPR:$Vd), (ins DPR:$Vn, DPR_VFP2:$Vm, VectorIndex32:$lane),
        NVMulSLFrm, itin, OpcodeStr, Dt, "$Vd, $Vn, $Vm$lane", "",
        [(set QPR:$Vd,
          (TyQ (OpNode (TyD DPR:$Vn),
                       (TyD (NEONvduplane (TyD DPR_VFP2:$Vm),imm:$lane)))))]>;
class N3VLSL16<bit op24, bits<2> op21_20, bits<4> op11_8,
               InstrItinClass itin, string OpcodeStr, string Dt,
               ValueType TyQ, ValueType TyD, SDNode OpNode>
  : N3VLane16<op24, 1, op21_20, op11_8, 1, 0,
        (outs QPR:$Vd), (ins DPR:$Vn, DPR_8:$Vm, VectorIndex16:$lane),
        NVMulSLFrm, itin, OpcodeStr, Dt, "$Vd, $Vn, $Vm$lane", "",
        [(set QPR:$Vd,
          (TyQ (OpNode (TyD DPR:$Vn),
                       (TyD (NEONvduplane (TyD DPR_8:$Vm), imm:$lane)))))]>;

// Long 3-register operations with explicitly extended operands.
class N3VLExt<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
              InstrItinClass itin, string OpcodeStr, string Dt,
              ValueType TyQ, ValueType TyD, SDNode OpNode, SDNode ExtOp,
              bit Commutable>
  : N3V<op24, op23, op21_20, op11_8, 0, op4,
        (outs QPR:$Vd), (ins DPR:$Vn, DPR:$Vm), N3RegFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm", "",
        [(set QPR:$Vd, (OpNode (TyQ (ExtOp (TyD DPR:$Vn))),
                                (TyQ (ExtOp (TyD DPR:$Vm)))))]> {
  let isCommutable = Commutable;
}

// Long 3-register intrinsics with explicit extend (VABDL).
class N3VLIntExt<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
                 InstrItinClass itin, string OpcodeStr, string Dt,
                 ValueType TyQ, ValueType TyD, SDPatternOperator IntOp, SDNode ExtOp,
                 bit Commutable>
  : N3V<op24, op23, op21_20, op11_8, 0, op4,
        (outs QPR:$Vd), (ins DPR:$Vn, DPR:$Vm), N3RegFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm", "",
        [(set QPR:$Vd, (TyQ (ExtOp (TyD (IntOp (TyD DPR:$Vn),
                                                (TyD DPR:$Vm))))))]> {
  let isCommutable = Commutable;
}

// Long 3-register intrinsics.
class N3VLInt<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
              InstrItinClass itin, string OpcodeStr, string Dt,
              ValueType TyQ, ValueType TyD, SDPatternOperator IntOp, bit Commutable>
  : N3V<op24, op23, op21_20, op11_8, 0, op4,
        (outs QPR:$Vd), (ins DPR:$Vn, DPR:$Vm), N3RegFrm, itin,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm", "",
        [(set QPR:$Vd, (TyQ (IntOp (TyD DPR:$Vn), (TyD DPR:$Vm))))]> {
  let isCommutable = Commutable;
}
class N3VLIntSL<bit op24, bits<2> op21_20, bits<4> op11_8, InstrItinClass itin,
                string OpcodeStr, string Dt,
                ValueType ResTy, ValueType OpTy, SDPatternOperator IntOp>
  : N3VLane32<op24, 1, op21_20, op11_8, 1, 0,
        (outs QPR:$Vd), (ins DPR:$Vn, DPR_VFP2:$Vm, VectorIndex32:$lane),
        NVMulSLFrm, itin, OpcodeStr, Dt, "$Vd, $Vn, $Vm$lane", "",
        [(set (ResTy QPR:$Vd),
              (ResTy (IntOp (OpTy DPR:$Vn),
                            (OpTy (NEONvduplane (OpTy DPR_VFP2:$Vm),
                                                imm:$lane)))))]>;
class N3VLIntSL16<bit op24, bits<2> op21_20, bits<4> op11_8,
                  InstrItinClass itin, string OpcodeStr, string Dt,
                  ValueType ResTy, ValueType OpTy, SDPatternOperator IntOp>
  : N3VLane16<op24, 1, op21_20, op11_8, 1, 0,
        (outs QPR:$Vd), (ins DPR:$Vn, DPR_8:$Vm, VectorIndex16:$lane),
        NVMulSLFrm, itin, OpcodeStr, Dt, "$Vd, $Vn, $Vm$lane", "",
        [(set (ResTy QPR:$Vd),
              (ResTy (IntOp (OpTy DPR:$Vn),
                            (OpTy (NEONvduplane (OpTy DPR_8:$Vm),
                                                imm:$lane)))))]>;

// Wide 3-register operations.
class N3VW<bit op24, bit op23, bits<2> op21_20, bits<4> op11_8, bit op4,
           string OpcodeStr, string Dt, ValueType TyQ, ValueType TyD,
           SDNode OpNode, SDNode ExtOp, bit Commutable>
  : N3V<op24, op23, op21_20, op11_8, 0, op4,
        (outs QPR:$Vd), (ins QPR:$Vn, DPR:$Vm), N3RegFrm, IIC_VSUBiD,
        OpcodeStr, Dt, "$Vd, $Vn, $Vm", "",
        [(set QPR:$Vd, (OpNode (TyQ QPR:$Vn),
                                (TyQ (ExtOp (TyD DPR:$Vm)))))]> {
  // All of these have a two-operand InstAlias.
  let TwoOperandAliasConstraint = "$Vn = $Vd";
  let isCommutable = Commutable;
}

// Pairwise long 2-register intrinsics, both double- and quad-register.
class N2VDPLInt<bits<2> op24_23, bits<2> op21_20, bits<2> op19_18,
                bits<2> op17_16, bits<5> op11_7, bit op4,
                string OpcodeStr, string Dt,
                ValueType ResTy, ValueType OpTy, SDPatternOperator IntOp>
  : N2V<op24_23, op21_20, op19_18, op17_16, op11_7, 0, op4, (outs DPR:$Vd),
        (ins DPR:$Vm), IIC_VSHLiD, OpcodeStr, Dt, "$Vd, $Vm", "",
        [(set DPR:$Vd, (ResTy (IntOp (OpTy DPR:$Vm))))]>;
class N2VQPLInt<bits<2> op24_23, bits<2> op21_20, bits<2> op19_18,
                bits<2> op17_16, bits<5> op11_7, bit op4,
                string OpcodeStr, string Dt,
                ValueType ResTy, ValueType OpTy, SDPatternOperator IntOp>
  : N2V<op24_23, op21_20, op19_18, op17_16, op11_7, 1, op4, (outs QPR:$Vd),
        (ins QPR:$Vm), IIC_VSHLiD, OpcodeStr, Dt, "$Vd, $Vm", "",
        [(set QPR:$Vd, (ResTy (IntOp (OpTy QPR:$Vm))))]>;

// Pairwise long 2-register accumulate intrinsics,
// both double- and quad-register.
// The destination register is also used as the first source operand register.
class N2VDPLInt2<bits<2> op24_23, bits<2> op21_20, bits<2> op19_18,
                 bits<2> op17_16, bits<5> op11_7, bit op4,
                 string OpcodeStr, string Dt,
                 ValueType ResTy, ValueType OpTy, SDPatternOperator IntOp>
  : N2V<op24_23, op21_20, op19_18, op17_16, op11_7, 0, op4,
        (outs DPR:$Vd), (ins DPR:$src1, DPR:$Vm), IIC_VPALiD,
        OpcodeStr, Dt, "$Vd, $Vm", "$src1 = $Vd",
        [(set DPR:$Vd, (ResTy (IntOp (ResTy DPR:$src1), (OpTy DPR:$Vm))))]>;
class N2VQPLInt2<bits<2> op24_23, bits<2> op21_20, bits<2> op19_18,
                 bits<2> op17_16, bits<5> op11_7, bit op4,
                 string OpcodeStr, string Dt,
                 ValueType ResTy, ValueType OpTy, SDPatternOperator IntOp>
  : N2V<op24_23, op21_20, op19_18, op17_16, op11_7, 1, op4,
        (outs QPR:$Vd), (ins QPR:$src1, QPR:$Vm), IIC_VPALiQ,
        OpcodeStr, Dt, "$Vd, $Vm", "$src1 = $Vd",
        [(set QPR:$Vd, (ResTy (IntOp (ResTy QPR:$src1), (OpTy QPR:$Vm))))]>;

// Shift by immediate,
// both double- and quad-register.
let TwoOperandAliasConstraint = "$Vm = $Vd" in {
class N2VDSh<bit op24, bit op23, bits<4> op11_8, bit op7, bit op4,
             Format f, InstrItinClass itin, Operand ImmTy,
             string OpcodeStr, string Dt, ValueType Ty, SDNode OpNode>
  : N2VImm<op24, op23, op11_8, op7, 0, op4,
           (outs DPR:$Vd), (ins DPR:$Vm, ImmTy:$SIMM), f, itin,
           OpcodeStr, Dt, "$Vd, $Vm, $SIMM", "",
           [(set DPR:$Vd, (Ty (OpNode (Ty DPR:$Vm), (i32 imm:$SIMM))))]>;
class N2VQSh<bit op24, bit op23, bits<4> op11_8, bit op7, bit op4,
             Format f, InstrItinClass itin, Operand ImmTy,
             string OpcodeStr, string Dt, ValueType Ty, SDNode OpNode>
  : N2VImm<op24, op23, op11_8, op7, 1, op4,
           (outs QPR:$Vd), (ins QPR:$Vm, ImmTy:$SIMM), f, itin,
           OpcodeStr, Dt, "$Vd, $Vm, $SIMM", "",
           [(set QPR:$Vd, (Ty (OpNode (Ty QPR:$Vm), (i32 imm:$SIMM))))]>;
}

// Long shift by immediate.
class N2VLSh<bit op24, bit op23, bits<4> op11_8, bit op7, bit op6, bit op4,
             string OpcodeStr, string Dt,
             ValueType ResTy, ValueType OpTy, Operand ImmTy, SDNode OpNode>
  : N2VImm<op24, op23, op11_8, op7, op6, op4,
           (outs QPR:$Vd), (ins DPR:$Vm, ImmTy:$SIMM), N2RegVShLFrm,
           IIC_VSHLiD, OpcodeStr, Dt, "$Vd, $Vm, $SIMM", "",
           [(set QPR:$Vd, (ResTy (OpNode (OpTy DPR:$Vm),
                                          (i32 imm:$SIMM))))]>;

// Narrow shift by immediate.
class N2VNSh<bit op24, bit op23, bits<4> op11_8, bit op7, bit op6, bit op4,
             InstrItinClass itin, string OpcodeStr, string Dt,
             ValueType ResTy, ValueType OpTy, Operand ImmTy, SDNode OpNode>
  : N2VImm<op24, op23, op11_8, op7, op6, op4,
           (outs DPR:$Vd), (ins QPR:$Vm, ImmTy:$SIMM), N2RegVShRFrm, itin,
           OpcodeStr, Dt, "$Vd, $Vm, $SIMM", "",
           [(set DPR:$Vd, (ResTy (OpNode (OpTy QPR:$Vm),
                                          (i32 imm:$SIMM))))]>;

// Shift right by immediate and accumulate,
// both double- and quad-register.
let TwoOperandAliasConstraint = "$Vm = $Vd" in {
class N2VDShAdd<bit op24, bit op23, bits<4> op11_8, bit op7, bit op4,
                Operand ImmTy, string OpcodeStr, string Dt,
                ValueType Ty, SDNode ShOp>
  : N2VImm<op24, op23, op11_8, op7, 0, op4, (outs DPR:$Vd),
           (ins DPR:$src1, DPR:$Vm, ImmTy:$SIMM), N2RegVShRFrm, IIC_VPALiD,
           OpcodeStr, Dt, "$Vd, $Vm, $SIMM", "$src1 = $Vd",
           [(set DPR:$Vd, (Ty (add DPR:$src1,
                                (Ty (ShOp DPR:$Vm, (i32 imm:$SIMM))))))]>;
class N2VQShAdd<bit op24, bit op23, bits<4> op11_8, bit op7, bit op4,
                Operand ImmTy, string OpcodeStr, string Dt,
                ValueType Ty, SDNode ShOp>
  : N2VImm<op24, op23, op11_8, op7, 1, op4, (outs QPR:$Vd),
           (ins QPR:$src1, QPR:$Vm, ImmTy:$SIMM), N2RegVShRFrm, IIC_VPALiD,
           OpcodeStr, Dt, "$Vd, $Vm, $SIMM", "$src1 = $Vd",
           [(set QPR:$Vd, (Ty (add QPR:$src1,
                                (Ty (ShOp QPR:$Vm, (i32 imm:$SIMM))))))]>;
}

// Shift by immediate and insert,
// both double- and quad-register.
let TwoOperandAliasConstraint = "$Vm = $Vd" in {
class N2VDShIns<bit op24, bit op23, bits<4> op11_8, bit op7, bit op4,
                Operand ImmTy, Format f, string OpcodeStr, string Dt,
                ValueType Ty,SDNode ShOp>
  : N2VImm<op24, op23, op11_8, op7, 0, op4, (outs DPR:$Vd),
           (ins DPR:$src1, DPR:$Vm, ImmTy:$SIMM), f, IIC_VSHLiD,
           OpcodeStr, Dt, "$Vd, $Vm, $SIMM", "$src1 = $Vd",
           [(set DPR:$Vd, (Ty (ShOp DPR:$src1, DPR:$Vm, (i32 imm:$SIMM))))]>;
class N2VQShIns<bit op24, bit op23, bits<4> op11_8, bit op7, bit op4,
                Operand ImmTy, Format f, string OpcodeStr, string Dt,
                ValueType Ty,SDNode ShOp>
  : N2VImm<op24, op23, op11_8, op7, 1, op4, (outs QPR:$Vd),
           (ins QPR:$src1, QPR:$Vm, ImmTy:$SIMM), f, IIC_VSHLiQ,
           OpcodeStr, Dt, "$Vd, $Vm, $SIMM", "$src1 = $Vd",
           [(set QPR:$Vd, (Ty (ShOp QPR:$src1, QPR:$Vm, (i32 imm:$SIMM))))]>;
}

// Convert, with fractional bits immediate,
// both double- and quad-register.
class N2VCvtD<bit op24, bit op23, bits<4> op11_8, bit op7, bit op4,
              string OpcodeStr, string Dt, ValueType ResTy, ValueType OpTy,
              SDPatternOperator IntOp>
  : N2VImm<op24, op23, op11_8, op7, 0, op4,
           (outs DPR:$Vd), (ins DPR:$Vm, neon_vcvt_imm32:$SIMM), NVCVTFrm,
           IIC_VUNAD, OpcodeStr, Dt, "$Vd, $Vm, $SIMM", "",
           [(set DPR:$Vd, (ResTy (IntOp (OpTy DPR:$Vm), (i32 imm:$SIMM))))]>;
class N2VCvtQ<bit op24, bit op23, bits<4> op11_8, bit op7, bit op4,
              string OpcodeStr, string Dt, ValueType ResTy, ValueType OpTy,
              SDPatternOperator IntOp>
  : N2VImm<op24, op23, op11_8, op7, 1, op4,
           (outs QPR:$Vd), (ins QPR:$Vm, neon_vcvt_imm32:$SIMM), NVCVTFrm,
           IIC_VUNAQ, OpcodeStr, Dt, "$Vd, $Vm, $SIMM", "",
           [(set QPR:$Vd, (ResTy (IntOp (OpTy QPR:$Vm), (i32 imm:$SIMM))))]>;

//===----------------------------------------------------------------------===//
// Multiclasses
//===----------------------------------------------------------------------===//

// Abbreviations used in multiclass suffixes:
//   Q = quarter int (8 bit) elements
//   H = half int (16 bit) elements
//   S = single int (32 bit) elements
//   D = double int (64 bit) elements

// Neon 2-register vector operations and intrinsics.

// Neon 2-register comparisons.
//   source operand element sizes of 8, 16 and 32 bits:
multiclass N2V_QHS_cmp<bits<2> op24_23, bits<2> op21_20, bits<2> op17_16,
                       bits<5> op11_7, bit op4, string opc, string Dt,
                       string asm, SDNode OpNode> {
  // 64-bit vector types.
  def v8i8  : N2V<op24_23, op21_20, 0b00, op17_16, op11_7, 0, op4,
                  (outs DPR:$Vd), (ins DPR:$Vm), NoItinerary,
                  opc, !strconcat(Dt, "8"), asm, "",
                  [(set DPR:$Vd, (v8i8 (OpNode (v8i8 DPR:$Vm))))]>;
  def v4i16 : N2V<op24_23, op21_20, 0b01, op17_16, op11_7, 0, op4,
                  (outs DPR:$Vd), (ins DPR:$Vm), NoItinerary,
                  opc, !strconcat(Dt, "16"), asm, "",
                  [(set DPR:$Vd, (v4i16 (OpNode (v4i16 DPR:$Vm))))]>;
  def v2i32 : N2V<op24_23, op21_20, 0b10, op17_16, op11_7, 0, op4,
                  (outs DPR:$Vd), (ins DPR:$Vm), NoItinerary,
                  opc, !strconcat(Dt, "32"), asm, "",
                  [(set DPR:$Vd, (v2i32 (OpNode (v2i32 DPR:$Vm))))]>;
  def v2f32 : N2V<op24_23, op21_20, 0b10, op17_16, op11_7, 0, op4,
                  (outs DPR:$Vd), (ins DPR:$Vm), NoItinerary,
                  opc, "f32", asm, "",
                  [(set DPR:$Vd, (v2i32 (OpNode (v2f32 DPR:$Vm))))]> {
    let Inst{10} = 1; // overwrite F = 1
  }

  // 128-bit vector types.
  def v16i8 : N2V<op24_23, op21_20, 0b00, op17_16, op11_7, 1, op4,
                  (outs QPR:$Vd), (ins QPR:$Vm), NoItinerary,
                  opc, !strconcat(Dt, "8"), asm, "",
                  [(set QPR:$Vd, (v16i8 (OpNode (v16i8 QPR:$Vm))))]>;
  def v8i16 : N2V<op24_23, op21_20, 0b01, op17_16, op11_7, 1, op4,
                  (outs QPR:$Vd), (ins QPR:$Vm), NoItinerary,
                  opc, !strconcat(Dt, "16"), asm, "",
                  [(set QPR:$Vd, (v8i16 (OpNode (v8i16 QPR:$Vm))))]>;
  def v4i32 : N2V<op24_23, op21_20, 0b10, op17_16, op11_7, 1, op4,
                  (outs QPR:$Vd), (ins QPR:$Vm), NoItinerary,
                  opc, !strconcat(Dt, "32"), asm, "",
                  [(set QPR:$Vd, (v4i32 (OpNode (v4i32 QPR:$Vm))))]>;
  def v4f32 : N2V<op24_23, op21_20, 0b10, op17_16, op11_7, 1, op4,
                  (outs QPR:$Vd), (ins QPR:$Vm), NoItinerary,
                  opc, "f32", asm, "",
                  [(set QPR:$Vd, (v4i32 (OpNode (v4f32 QPR:$Vm))))]> {
    let Inst{10} = 1; // overwrite F = 1
  }
}


// Neon 2-register vector intrinsics,
//   element sizes of 8, 16 and 32 bits:
multiclass N2VInt_QHS<bits<2> op24_23, bits<2> op21_20, bits<2> op17_16,
                      bits<5> op11_7, bit op4,
                      InstrItinClass itinD, InstrItinClass itinQ,
                      string OpcodeStr, string Dt, SDPatternOperator IntOp> {
  // 64-bit vector types.
  def v8i8  : N2VDInt<op24_23, op21_20, 0b00, op17_16, op11_7, op4,
                      itinD, OpcodeStr, !strconcat(Dt, "8"), v8i8, v8i8, IntOp>;
  def v4i16 : N2VDInt<op24_23, op21_20, 0b01, op17_16, op11_7, op4,
                      itinD, OpcodeStr, !strconcat(Dt, "16"),v4i16,v4i16,IntOp>;
  def v2i32 : N2VDInt<op24_23, op21_20, 0b10, op17_16, op11_7, op4,
                      itinD, OpcodeStr, !strconcat(Dt, "32"),v2i32,v2i32,IntOp>;

  // 128-bit vector types.
  def v16i8 : N2VQInt<op24_23, op21_20, 0b00, op17_16, op11_7, op4,
                      itinQ, OpcodeStr, !strconcat(Dt, "8"), v16i8,v16i8,IntOp>;
  def v8i16 : N2VQInt<op24_23, op21_20, 0b01, op17_16, op11_7, op4,
                      itinQ, OpcodeStr, !strconcat(Dt, "16"),v8i16,v8i16,IntOp>;
  def v4i32 : N2VQInt<op24_23, op21_20, 0b10, op17_16, op11_7, op4,
                      itinQ, OpcodeStr, !strconcat(Dt, "32"),v4i32,v4i32,IntOp>;
}


// Neon Narrowing 2-register vector operations,
//   source operand element sizes of 16, 32 and 64 bits:
multiclass N2VN_HSD<bits<2> op24_23, bits<2> op21_20, bits<2> op17_16,
                    bits<5> op11_7, bit op6, bit op4,
                    InstrItinClass itin, string OpcodeStr, string Dt,
                    SDNode OpNode> {
  def v8i8  : N2VN<op24_23, op21_20, 0b00, op17_16, op11_7, op6, op4,
                   itin, OpcodeStr, !strconcat(Dt, "16"),
                   v8i8, v8i16, OpNode>;
  def v4i16 : N2VN<op24_23, op21_20, 0b01, op17_16, op11_7, op6, op4,
                   itin, OpcodeStr, !strconcat(Dt, "32"),
                   v4i16, v4i32, OpNode>;
  def v2i32 : N2VN<op24_23, op21_20, 0b10, op17_16, op11_7, op6, op4,
                   itin, OpcodeStr, !strconcat(Dt, "64"),
                   v2i32, v2i64, OpNode>;
}

// Neon Narrowing 2-register vector intrinsics,
//   source operand element sizes of 16, 32 and 64 bits:
multiclass N2VNInt_HSD<bits<2> op24_23, bits<2> op21_20, bits<2> op17_16,
                       bits<5> op11_7, bit op6, bit op4,
                       InstrItinClass itin, string OpcodeStr, string Dt,
                       SDPatternOperator IntOp> {
  def v8i8  : N2VNInt<op24_23, op21_20, 0b00, op17_16, op11_7, op6, op4,
                      itin, OpcodeStr, !strconcat(Dt, "16"),
                      v8i8, v8i16, IntOp>;
  def v4i16 : N2VNInt<op24_23, op21_20, 0b01, op17_16, op11_7, op6, op4,
                      itin, OpcodeStr, !strconcat(Dt, "32"),
                      v4i16, v4i32, IntOp>;
  def v2i32 : N2VNInt<op24_23, op21_20, 0b10, op17_16, op11_7, op6, op4,
                      itin, OpcodeStr, !strconcat(Dt, "64"),
                      v2i32, v2i64, IntOp>;
}


// Neon Lengthening 2-register vector intrinsic (currently specific to VMOVL).
//   source operand element sizes of 16, 32 and 64 bits:
multiclass N2VL_QHS<bits<2> op24_23, bits<5> op11_7, bit op6, bit op4,
                    string OpcodeStr, string Dt, SDNode OpNode> {
  def v8i16 : N2VL<op24_23, 0b00, 0b10, 0b00, op11_7, op6, op4, IIC_VQUNAiD,
                   OpcodeStr, !strconcat(Dt, "8"), v8i16, v8i8, OpNode>;
  def v4i32 : N2VL<op24_23, 0b01, 0b00, 0b00, op11_7, op6, op4, IIC_VQUNAiD,
                   OpcodeStr, !strconcat(Dt, "16"), v4i32, v4i16, OpNode>;
  def v2i64 : N2VL<op24_23, 0b10, 0b00, 0b00, op11_7, op6, op4, IIC_VQUNAiD,
                   OpcodeStr, !strconcat(Dt, "32"), v2i64, v2i32, OpNode>;
}


// Neon 3-register vector operations.

// First with only element sizes of 8, 16 and 32 bits:
multiclass N3V_QHS<bit op24, bit op23, bits<4> op11_8, bit op4,
                   InstrItinClass itinD16, InstrItinClass itinD32,
                   InstrItinClass itinQ16, InstrItinClass itinQ32,
                   string OpcodeStr, string Dt,
                   SDNode OpNode, bit Commutable = 0> {
  // 64-bit vector types.
  def v8i8  : N3VD<op24, op23, 0b00, op11_8, op4, itinD16,
                   OpcodeStr, !strconcat(Dt, "8"),
                   v8i8, v8i8, OpNode, Commutable>;
  def v4i16 : N3VD<op24, op23, 0b01, op11_8, op4, itinD16,
                   OpcodeStr, !strconcat(Dt, "16"),
                   v4i16, v4i16, OpNode, Commutable>;
  def v2i32 : N3VD<op24, op23, 0b10, op11_8, op4, itinD32,
                   OpcodeStr, !strconcat(Dt, "32"),
                   v2i32, v2i32, OpNode, Commutable>;

  // 128-bit vector types.
  def v16i8 : N3VQ<op24, op23, 0b00, op11_8, op4, itinQ16,
                   OpcodeStr, !strconcat(Dt, "8"),
                   v16i8, v16i8, OpNode, Commutable>;
  def v8i16 : N3VQ<op24, op23, 0b01, op11_8, op4, itinQ16,
                   OpcodeStr, !strconcat(Dt, "16"),
                   v8i16, v8i16, OpNode, Commutable>;
  def v4i32 : N3VQ<op24, op23, 0b10, op11_8, op4, itinQ32,
                   OpcodeStr, !strconcat(Dt, "32"),
                   v4i32, v4i32, OpNode, Commutable>;
}

multiclass N3VSL_HS<bits<4> op11_8, string OpcodeStr, SDNode ShOp> {
  def v4i16 : N3VDSL16<0b01, op11_8, OpcodeStr, "i16", v4i16, ShOp>;
  def v2i32 : N3VDSL<0b10, op11_8, IIC_VMULi32D, OpcodeStr, "i32", v2i32, ShOp>;
  def v8i16 : N3VQSL16<0b01, op11_8, OpcodeStr, "i16", v8i16, v4i16, ShOp>;
  def v4i32 : N3VQSL<0b10, op11_8, IIC_VMULi32Q, OpcodeStr, "i32",
                     v4i32, v2i32, ShOp>;
}

// ....then also with element size 64 bits:
multiclass N3V_QHSD<bit op24, bit op23, bits<4> op11_8, bit op4,
                    InstrItinClass itinD, InstrItinClass itinQ,
                    string OpcodeStr, string Dt,
                    SDNode OpNode, bit Commutable = 0>
  : N3V_QHS<op24, op23, op11_8, op4, itinD, itinD, itinQ, itinQ,
            OpcodeStr, Dt, OpNode, Commutable> {
  def v1i64 : N3VD<op24, op23, 0b11, op11_8, op4, itinD,
                   OpcodeStr, !strconcat(Dt, "64"),
                   v1i64, v1i64, OpNode, Commutable>;
  def v2i64 : N3VQ<op24, op23, 0b11, op11_8, op4, itinQ,
                   OpcodeStr, !strconcat(Dt, "64"),
                   v2i64, v2i64, OpNode, Commutable>;
}


// Neon 3-register vector intrinsics.

// First with only element sizes of 16 and 32 bits:
multiclass N3VInt_HS<bit op24, bit op23, bits<4> op11_8, bit op4, Format f,
                     InstrItinClass itinD16, InstrItinClass itinD32,
                     InstrItinClass itinQ16, InstrItinClass itinQ32,
                     string OpcodeStr, string Dt,
                     SDPatternOperator IntOp, bit Commutable = 0> {
  // 64-bit vector types.
  def v4i16 : N3VDInt<op24, op23, 0b01, op11_8, op4, f, itinD16,
                      OpcodeStr, !strconcat(Dt, "16"),
                      v4i16, v4i16, IntOp, Commutable>;
  def v2i32 : N3VDInt<op24, op23, 0b10, op11_8, op4, f, itinD32,
                      OpcodeStr, !strconcat(Dt, "32"),
                      v2i32, v2i32, IntOp, Commutable>;

  // 128-bit vector types.
  def v8i16 : N3VQInt<op24, op23, 0b01, op11_8, op4, f, itinQ16,
                      OpcodeStr, !strconcat(Dt, "16"),
                      v8i16, v8i16, IntOp, Commutable>;
  def v4i32 : N3VQInt<op24, op23, 0b10, op11_8, op4, f, itinQ32,
                      OpcodeStr, !strconcat(Dt, "32"),
                      v4i32, v4i32, IntOp, Commutable>;
}
multiclass N3VInt_HSSh<bit op24, bit op23, bits<4> op11_8, bit op4, Format f,
                     InstrItinClass itinD16, InstrItinClass itinD32,
                     InstrItinClass itinQ16, InstrItinClass itinQ32,
                     string OpcodeStr, string Dt,
                     SDPatternOperator IntOp> {
  // 64-bit vector types.
  def v4i16 : N3VDIntSh<op24, op23, 0b01, op11_8, op4, f, itinD16,
                      OpcodeStr, !strconcat(Dt, "16"),
                      v4i16, v4i16, IntOp>;
  def v2i32 : N3VDIntSh<op24, op23, 0b10, op11_8, op4, f, itinD32,
                      OpcodeStr, !strconcat(Dt, "32"),
                      v2i32, v2i32, IntOp>;

  // 128-bit vector types.
  def v8i16 : N3VQIntSh<op24, op23, 0b01, op11_8, op4, f, itinQ16,
                      OpcodeStr, !strconcat(Dt, "16"),
                      v8i16, v8i16, IntOp>;
  def v4i32 : N3VQIntSh<op24, op23, 0b10, op11_8, op4, f, itinQ32,
                      OpcodeStr, !strconcat(Dt, "32"),
                      v4i32, v4i32, IntOp>;
}

multiclass N3VIntSL_HS<bits<4> op11_8,
                       InstrItinClass itinD16, InstrItinClass itinD32,
                       InstrItinClass itinQ16, InstrItinClass itinQ32,
                       string OpcodeStr, string Dt, SDPatternOperator IntOp> {
  def v4i16 : N3VDIntSL16<0b01, op11_8, itinD16,
                          OpcodeStr, !strconcat(Dt, "16"), v4i16, IntOp>;
  def v2i32 : N3VDIntSL<0b10, op11_8, itinD32,
                        OpcodeStr, !strconcat(Dt, "32"), v2i32, IntOp>;
  def v8i16 : N3VQIntSL16<0b01, op11_8, itinQ16,
                          OpcodeStr, !strconcat(Dt, "16"), v8i16, v4i16, IntOp>;
  def v4i32 : N3VQIntSL<0b10, op11_8, itinQ32,
                        OpcodeStr, !strconcat(Dt, "32"), v4i32, v2i32, IntOp>;
}

// ....then also with element size of 8 bits:
multiclass N3VInt_QHS<bit op24, bit op23, bits<4> op11_8, bit op4, Format f,
                      InstrItinClass itinD16, InstrItinClass itinD32,
                      InstrItinClass itinQ16, InstrItinClass itinQ32,
                      string OpcodeStr, string Dt,
                      SDPatternOperator IntOp, bit Commutable = 0>
  : N3VInt_HS<op24, op23, op11_8, op4, f, itinD16, itinD32, itinQ16, itinQ32,
              OpcodeStr, Dt, IntOp, Commutable> {
  def v8i8  : N3VDInt<op24, op23, 0b00, op11_8, op4, f, itinD16,
                      OpcodeStr, !strconcat(Dt, "8"),
                      v8i8, v8i8, IntOp, Commutable>;
  def v16i8 : N3VQInt<op24, op23, 0b00, op11_8, op4, f, itinQ16,
                      OpcodeStr, !strconcat(Dt, "8"),
                      v16i8, v16i8, IntOp, Commutable>;
}
multiclass N3VInt_QHSSh<bit op24, bit op23, bits<4> op11_8, bit op4, Format f,
                      InstrItinClass itinD16, InstrItinClass itinD32,
                      InstrItinClass itinQ16, InstrItinClass itinQ32,
                      string OpcodeStr, string Dt,
                      SDPatternOperator IntOp>
  : N3VInt_HSSh<op24, op23, op11_8, op4, f, itinD16, itinD32, itinQ16, itinQ32,
              OpcodeStr, Dt, IntOp> {
  def v8i8  : N3VDIntSh<op24, op23, 0b00, op11_8, op4, f, itinD16,
                      OpcodeStr, !strconcat(Dt, "8"),
                      v8i8, v8i8, IntOp>;
  def v16i8 : N3VQIntSh<op24, op23, 0b00, op11_8, op4, f, itinQ16,
                      OpcodeStr, !strconcat(Dt, "8"),
                      v16i8, v16i8, IntOp>;
}


// ....then also with element size of 64 bits:
multiclass N3VInt_QHSD<bit op24, bit op23, bits<4> op11_8, bit op4, Format f,
                       InstrItinClass itinD16, InstrItinClass itinD32,
                       InstrItinClass itinQ16, InstrItinClass itinQ32,
                       string OpcodeStr, string Dt,
                       SDPatternOperator IntOp, bit Commutable = 0>
  : N3VInt_QHS<op24, op23, op11_8, op4, f, itinD16, itinD32, itinQ16, itinQ32,
               OpcodeStr, Dt, IntOp, Commutable> {
  def v1i64 : N3VDInt<op24, op23, 0b11, op11_8, op4, f, itinD32,
                      OpcodeStr, !strconcat(Dt, "64"),
                      v1i64, v1i64, IntOp, Commutable>;
  def v2i64 : N3VQInt<op24, op23, 0b11, op11_8, op4, f, itinQ32,
                      OpcodeStr, !strconcat(Dt, "64"),
                      v2i64, v2i64, IntOp, Commutable>;
}
multiclass N3VInt_QHSDSh<bit op24, bit op23, bits<4> op11_8, bit op4, Format f,
                       InstrItinClass itinD16, InstrItinClass itinD32,
                       InstrItinClass itinQ16, InstrItinClass itinQ32,
                       string OpcodeStr, string Dt,
                       SDPatternOperator IntOp>
  : N3VInt_QHSSh<op24, op23, op11_8, op4, f, itinD16, itinD32, itinQ16, itinQ32,
               OpcodeStr, Dt, IntOp> {
  def v1i64 : N3VDIntSh<op24, op23, 0b11, op11_8, op4, f, itinD32,
                      OpcodeStr, !strconcat(Dt, "64"),
                      v1i64, v1i64, IntOp>;
  def v2i64 : N3VQIntSh<op24, op23, 0b11, op11_8, op4, f, itinQ32,
                      OpcodeStr, !strconcat(Dt, "64"),
                      v2i64, v2i64, IntOp>;
}

// Neon Narrowing 3-register vector intrinsics,
//   source operand element sizes of 16, 32 and 64 bits:
multiclass N3VNInt_HSD<bit op24, bit op23, bits<4> op11_8, bit op4,
                       string OpcodeStr, string Dt,
                       SDPatternOperator IntOp, bit Commutable = 0> {
  def v8i8  : N3VNInt<op24, op23, 0b00, op11_8, op4,
                      OpcodeStr, !strconcat(Dt, "16"),
                      v8i8, v8i16, IntOp, Commutable>;
  def v4i16 : N3VNInt<op24, op23, 0b01, op11_8, op4,
                      OpcodeStr, !strconcat(Dt, "32"),
                      v4i16, v4i32, IntOp, Commutable>;
  def v2i32 : N3VNInt<op24, op23, 0b10, op11_8, op4,
                      OpcodeStr, !strconcat(Dt, "64"),
                      v2i32, v2i64, IntOp, Commutable>;
}


// Neon Long 3-register vector operations.

multiclass N3VL_QHS<bit op24, bit op23, bits<4> op11_8, bit op4,
                    InstrItinClass itin16, InstrItinClass itin32,
                    string OpcodeStr, string Dt,
                    SDNode OpNode, bit Commutable = 0> {
  def v8i16 : N3VL<op24, op23, 0b00, op11_8, op4, itin16,
                   OpcodeStr, !strconcat(Dt, "8"),
                   v8i16, v8i8, OpNode, Commutable>;
  def v4i32 : N3VL<op24, op23, 0b01, op11_8, op4, itin16,
                   OpcodeStr, !strconcat(Dt, "16"),
                   v4i32, v4i16, OpNode, Commutable>;
  def v2i64 : N3VL<op24, op23, 0b10, op11_8, op4, itin32,
                   OpcodeStr, !strconcat(Dt, "32"),
                   v2i64, v2i32, OpNode, Commutable>;
}

multiclass N3VLSL_HS<bit op24, bits<4> op11_8,
                     InstrItinClass itin, string OpcodeStr, string Dt,
                     SDNode OpNode> {
  def v4i16 : N3VLSL16<op24, 0b01, op11_8, itin, OpcodeStr,
                       !strconcat(Dt, "16"), v4i32, v4i16, OpNode>;
  def v2i32 : N3VLSL<op24, 0b10, op11_8, itin, OpcodeStr,
                     !strconcat(Dt, "32"), v2i64, v2i32, OpNode>;
}

multiclass N3VLExt_QHS<bit op24, bit op23, bits<4> op11_8, bit op4,
                       InstrItinClass itin16, InstrItinClass itin32,
                       string OpcodeStr, string Dt,
                       SDNode OpNode, SDNode ExtOp, bit Commutable = 0> {
  def v8i16 : N3VLExt<op24, op23, 0b00, op11_8, op4, itin16,
                      OpcodeStr, !strconcat(Dt, "8"),
                      v8i16, v8i8, OpNode, ExtOp, Commutable>;
  def v4i32 : N3VLExt<op24, op23, 0b01, op11_8, op4, itin16,
                      OpcodeStr, !strconcat(Dt, "16"),
                      v4i32, v4i16, OpNode, ExtOp, Commutable>;
  def v2i64 : N3VLExt<op24, op23, 0b10, op11_8, op4, itin32,
                      OpcodeStr, !strconcat(Dt, "32"),
                      v2i64, v2i32, OpNode, ExtOp, Commutable>;
}

// Neon Long 3-register vector intrinsics.

// First with only element sizes of 16 and 32 bits:
multiclass N3VLInt_HS<bit op24, bit op23, bits<4> op11_8, bit op4,
                      InstrItinClass itin16, InstrItinClass itin32,
                      string OpcodeStr, string Dt,
                      SDPatternOperator IntOp, bit Commutable = 0> {
  def v4i32 : N3VLInt<op24, op23, 0b01, op11_8, op4, itin16,
                      OpcodeStr, !strconcat(Dt, "16"),
                      v4i32, v4i16, IntOp, Commutable>;
  def v2i64 : N3VLInt<op24, op23, 0b10, op11_8, op4, itin32,
                      OpcodeStr, !strconcat(Dt, "32"),
                      v2i64, v2i32, IntOp, Commutable>;
}

multiclass N3VLIntSL_HS<bit op24, bits<4> op11_8,
                        InstrItinClass itin, string OpcodeStr, string Dt,
                        SDPatternOperator IntOp> {
  def v4i16 : N3VLIntSL16<op24, 0b01, op11_8, itin,
                          OpcodeStr, !strconcat(Dt, "16"), v4i32, v4i16, IntOp>;
  def v2i32 : N3VLIntSL<op24, 0b10, op11_8, itin,
                        OpcodeStr, !strconcat(Dt, "32"), v2i64, v2i32, IntOp>;
}

// ....then also with element size of 8 bits:
multiclass N3VLInt_QHS<bit op24, bit op23, bits<4> op11_8, bit op4,
                       InstrItinClass itin16, InstrItinClass itin32,
                       string OpcodeStr, string Dt,
                       SDPatternOperator IntOp, bit Commutable = 0>
  : N3VLInt_HS<op24, op23, op11_8, op4, itin16, itin32, OpcodeStr, Dt,
               IntOp, Commutable> {
  def v8i16 : N3VLInt<op24, op23, 0b00, op11_8, op4, itin16,
                      OpcodeStr, !strconcat(Dt, "8"),
                      v8i16, v8i8, IntOp, Commutable>;
}

// ....with explicit extend (VABDL).
multiclass N3VLIntExt_QHS<bit op24, bit op23, bits<4> op11_8, bit op4,
                       InstrItinClass itin, string OpcodeStr, string Dt,
                       SDPatternOperator IntOp, SDNode ExtOp, bit Commutable = 0> {
  def v8i16 : N3VLIntExt<op24, op23, 0b00, op11_8, op4, itin,
                         OpcodeStr, !strconcat(Dt, "8"),
                         v8i16, v8i8, IntOp, ExtOp, Commutable>;
  def v4i32 : N3VLIntExt<op24, op23, 0b01, op11_8, op4, itin,
                         OpcodeStr, !strconcat(Dt, "16"),
                         v4i32, v4i16, IntOp, ExtOp, Commutable>;
  def v2i64 : N3VLIntExt<op24, op23, 0b10, op11_8, op4, itin,
                         OpcodeStr, !strconcat(Dt, "32"),
                         v2i64, v2i32, IntOp, ExtOp, Commutable>;
}


// Neon Wide 3-register vector intrinsics,
//   source operand element sizes of 8, 16 and 32 bits:
multiclass N3VW_QHS<bit op24, bit op23, bits<4> op11_8, bit op4,
                    string OpcodeStr, string Dt,
                    SDNode OpNode, SDNode ExtOp, bit Commutable = 0> {
  def v8i16 : N3VW<op24, op23, 0b00, op11_8, op4,
                   OpcodeStr, !strconcat(Dt, "8"),
                   v8i16, v8i8, OpNode, ExtOp, Commutable>;
  def v4i32 : N3VW<op24, op23, 0b01, op11_8, op4,
                   OpcodeStr, !strconcat(Dt, "16"),
                   v4i32, v4i16, OpNode, ExtOp, Commutable>;
  def v2i64 : N3VW<op24, op23, 0b10, op11_8, op4,
                   OpcodeStr, !strconcat(Dt, "32"),
                   v2i64, v2i32, OpNode, ExtOp, Commutable>;
}


// Neon Multiply-Op vector operations,
//   element sizes of 8, 16 and 32 bits:
multiclass N3VMulOp_QHS<bit op24, bit op23, bits<4> op11_8, bit op4,
                        InstrItinClass itinD16, InstrItinClass itinD32,
                        InstrItinClass itinQ16, InstrItinClass itinQ32,
                        string OpcodeStr, string Dt, SDNode OpNode> {
  // 64-bit vector types.
  def v8i8  : N3VDMulOp<op24, op23, 0b00, op11_8, op4, itinD16,
                        OpcodeStr, !strconcat(Dt, "8"), v8i8, mul, OpNode>;
  def v4i16 : N3VDMulOp<op24, op23, 0b01, op11_8, op4, itinD16,
                        OpcodeStr, !strconcat(Dt, "16"), v4i16, mul, OpNode>;
  def v2i32 : N3VDMulOp<op24, op23, 0b10, op11_8, op4, itinD32,
                        OpcodeStr, !strconcat(Dt, "32"), v2i32, mul, OpNode>;

  // 128-bit vector types.
  def v16i8 : N3VQMulOp<op24, op23, 0b00, op11_8, op4, itinQ16,
                        OpcodeStr, !strconcat(Dt, "8"), v16i8, mul, OpNode>;
  def v8i16 : N3VQMulOp<op24, op23, 0b01, op11_8, op4, itinQ16,
                        OpcodeStr, !strconcat(Dt, "16"), v8i16, mul, OpNode>;
  def v4i32 : N3VQMulOp<op24, op23, 0b10, op11_8, op4, itinQ32,
                        OpcodeStr, !strconcat(Dt, "32"), v4i32, mul, OpNode>;
}

multiclass N3VMulOpSL_HS<bits<4> op11_8,
                         InstrItinClass itinD16, InstrItinClass itinD32,
                         InstrItinClass itinQ16, InstrItinClass itinQ32,
                         string OpcodeStr, string Dt, SDNode ShOp> {
  def v4i16 : N3VDMulOpSL16<0b01, op11_8, itinD16,
                            OpcodeStr, !strconcat(Dt, "16"), v4i16, mul, ShOp>;
  def v2i32 : N3VDMulOpSL<0b10, op11_8, itinD32,
                          OpcodeStr, !strconcat(Dt, "32"), v2i32, mul, ShOp>;
  def v8i16 : N3VQMulOpSL16<0b01, op11_8, itinQ16,
                            OpcodeStr, !strconcat(Dt, "16"), v8i16, v4i16,
                            mul, ShOp>;
  def v4i32 : N3VQMulOpSL<0b10, op11_8, itinQ32,
                          OpcodeStr, !strconcat(Dt, "32"), v4i32, v2i32,
                          mul, ShOp>;
}

// Neon Intrinsic-Op vector operations,
//   element sizes of 8, 16 and 32 bits:
multiclass N3VIntOp_QHS<bit op24, bit op23, bits<4> op11_8, bit op4,
                        InstrItinClass itinD, InstrItinClass itinQ,
                        string OpcodeStr, string Dt, SDPatternOperator IntOp,
                        SDNode OpNode> {
  // 64-bit vector types.
  def v8i8  : N3VDIntOp<op24, op23, 0b00, op11_8, op4, itinD,
                        OpcodeStr, !strconcat(Dt, "8"), v8i8, IntOp, OpNode>;
  def v4i16 : N3VDIntOp<op24, op23, 0b01, op11_8, op4, itinD,
                        OpcodeStr, !strconcat(Dt, "16"), v4i16, IntOp, OpNode>;
  def v2i32 : N3VDIntOp<op24, op23, 0b10, op11_8, op4, itinD,
                        OpcodeStr, !strconcat(Dt, "32"), v2i32, IntOp, OpNode>;

  // 128-bit vector types.
  def v16i8 : N3VQIntOp<op24, op23, 0b00, op11_8, op4, itinQ,
                        OpcodeStr, !strconcat(Dt, "8"), v16i8, IntOp, OpNode>;
  def v8i16 : N3VQIntOp<op24, op23, 0b01, op11_8, op4, itinQ,
                        OpcodeStr, !strconcat(Dt, "16"), v8i16, IntOp, OpNode>;
  def v4i32 : N3VQIntOp<op24, op23, 0b10, op11_8, op4, itinQ,
                        OpcodeStr, !strconcat(Dt, "32"), v4i32, IntOp, OpNode>;
}

// Neon 3-argument intrinsics,
//   element sizes of 8, 16 and 32 bits:
multiclass N3VInt3_QHS<bit op24, bit op23, bits<4> op11_8, bit op4,
                       InstrItinClass itinD, InstrItinClass itinQ,
                       string OpcodeStr, string Dt, SDPatternOperator IntOp> {
  // 64-bit vector types.
  def v8i8  : N3VDInt3<op24, op23, 0b00, op11_8, op4, itinD,
                       OpcodeStr, !strconcat(Dt, "8"), v8i8, v8i8, IntOp>;
  def v4i16 : N3VDInt3<op24, op23, 0b01, op11_8, op4, itinD,
                       OpcodeStr, !strconcat(Dt, "16"), v4i16, v4i16, IntOp>;
  def v2i32 : N3VDInt3<op24, op23, 0b10, op11_8, op4, itinD,
                       OpcodeStr, !strconcat(Dt, "32"), v2i32, v2i32, IntOp>;

  // 128-bit vector types.
  def v16i8 : N3VQInt3<op24, op23, 0b00, op11_8, op4, itinQ,
                       OpcodeStr, !strconcat(Dt, "8"), v16i8, v16i8, IntOp>;
  def v8i16 : N3VQInt3<op24, op23, 0b01, op11_8, op4, itinQ,
                       OpcodeStr, !strconcat(Dt, "16"), v8i16, v8i16, IntOp>;
  def v4i32 : N3VQInt3<op24, op23, 0b10, op11_8, op4, itinQ,
                       OpcodeStr, !strconcat(Dt, "32"), v4i32, v4i32, IntOp>;
}


// Neon Long Multiply-Op vector operations,
//   element sizes of 8, 16 and 32 bits:
multiclass N3VLMulOp_QHS<bit op24, bit op23, bits<4> op11_8, bit op4,
                         InstrItinClass itin16, InstrItinClass itin32,
                         string OpcodeStr, string Dt, SDNode MulOp,
                         SDNode OpNode> {
  def v8i16 : N3VLMulOp<op24, op23, 0b00, op11_8, op4, itin16, OpcodeStr,
                        !strconcat(Dt, "8"), v8i16, v8i8, MulOp, OpNode>;
  def v4i32 : N3VLMulOp<op24, op23, 0b01, op11_8, op4, itin16, OpcodeStr,
                        !strconcat(Dt, "16"), v4i32, v4i16, MulOp, OpNode>;
  def v2i64 : N3VLMulOp<op24, op23, 0b10, op11_8, op4, itin32, OpcodeStr,
                        !strconcat(Dt, "32"), v2i64, v2i32, MulOp, OpNode>;
}

multiclass N3VLMulOpSL_HS<bit op24, bits<4> op11_8, string OpcodeStr,
                          string Dt, SDNode MulOp, SDNode OpNode> {
  def v4i16 : N3VLMulOpSL16<op24, 0b01, op11_8, IIC_VMACi16D, OpcodeStr,
                            !strconcat(Dt,"16"), v4i32, v4i16, MulOp, OpNode>;
  def v2i32 : N3VLMulOpSL<op24, 0b10, op11_8, IIC_VMACi32D, OpcodeStr,
                          !strconcat(Dt, "32"), v2i64, v2i32, MulOp, OpNode>;
}


// Neon Long 3-argument intrinsics.

// First with only element sizes of 16 and 32 bits:
multiclass N3VLInt3_HS<bit op24, bit op23, bits<4> op11_8, bit op4,
                       InstrItinClass itin16, InstrItinClass itin32,
                       string OpcodeStr, string Dt, SDPatternOperator IntOp> {
  def v4i32 : N3VLInt3<op24, op23, 0b01, op11_8, op4, itin16,
                       OpcodeStr, !strconcat(Dt, "16"), v4i32, v4i16, IntOp>;
  def v2i64 : N3VLInt3<op24, op23, 0b10, op11_8, op4, itin32,
                       OpcodeStr, !strconcat(Dt, "32"), v2i64, v2i32, IntOp>;
}

multiclass N3VLInt3SL_HS<bit op24, bits<4> op11_8,
                         string OpcodeStr, string Dt, SDPatternOperator IntOp> {
  def v4i16 : N3VLInt3SL16<op24, 0b01, op11_8, IIC_VMACi16D,
                           OpcodeStr, !strconcat(Dt,"16"), v4i32, v4i16, IntOp>;
  def v2i32 : N3VLInt3SL<op24, 0b10, op11_8, IIC_VMACi32D,
                         OpcodeStr, !strconcat(Dt, "32"), v2i64, v2i32, IntOp>;
}

// ....then also with element size of 8 bits:
multiclass N3VLInt3_QHS<bit op24, bit op23, bits<4> op11_8, bit op4,
                        InstrItinClass itin16, InstrItinClass itin32,
                        string OpcodeStr, string Dt, SDPatternOperator IntOp>
  : N3VLInt3_HS<op24, op23, op11_8, op4, itin16, itin32, OpcodeStr, Dt, IntOp> {
  def v8i16 : N3VLInt3<op24, op23, 0b00, op11_8, op4, itin16,
                       OpcodeStr, !strconcat(Dt, "8"), v8i16, v8i8, IntOp>;
}

// ....with explicit extend (VABAL).
multiclass N3VLIntExtOp_QHS<bit op24, bit op23, bits<4> op11_8, bit op4,
                            InstrItinClass itin, string OpcodeStr, string Dt,
                            SDPatternOperator IntOp, SDNode ExtOp, SDNode OpNode> {
  def v8i16 : N3VLIntExtOp<op24, op23, 0b00, op11_8, op4, itin,
                           OpcodeStr, !strconcat(Dt, "8"), v8i16, v8i8,
                           IntOp, ExtOp, OpNode>;
  def v4i32 : N3VLIntExtOp<op24, op23, 0b01, op11_8, op4, itin,
                           OpcodeStr, !strconcat(Dt, "16"), v4i32, v4i16,
                           IntOp, ExtOp, OpNode>;
  def v2i64 : N3VLIntExtOp<op24, op23, 0b10, op11_8, op4, itin,
                           OpcodeStr, !strconcat(Dt, "32"), v2i64, v2i32,
                           IntOp, ExtOp, OpNode>;
}


// Neon Pairwise long 2-register intrinsics,
//   element sizes of 8, 16 and 32 bits:
multiclass N2VPLInt_QHS<bits<2> op24_23, bits<2> op21_20, bits<2> op17_16,
                        bits<5> op11_7, bit op4,
                        string OpcodeStr, string Dt, SDPatternOperator IntOp> {
  // 64-bit vector types.
  def v8i8  : N2VDPLInt<op24_23, op21_20, 0b00, op17_16, op11_7, op4,
                        OpcodeStr, !strconcat(Dt, "8"), v4i16, v8i8, IntOp>;
  def v4i16 : N2VDPLInt<op24_23, op21_20, 0b01, op17_16, op11_7, op4,
                        OpcodeStr, !strconcat(Dt, "16"), v2i32, v4i16, IntOp>;
  def v2i32 : N2VDPLInt<op24_23, op21_20, 0b10, op17_16, op11_7, op4,
                        OpcodeStr, !strconcat(Dt, "32"), v1i64, v2i32, IntOp>;

  // 128-bit vector types.
  def v16i8 : N2VQPLInt<op24_23, op21_20, 0b00, op17_16, op11_7, op4,
                        OpcodeStr, !strconcat(Dt, "8"), v8i16, v16i8, IntOp>;
  def v8i16 : N2VQPLInt<op24_23, op21_20, 0b01, op17_16, op11_7, op4,
                        OpcodeStr, !strconcat(Dt, "16"), v4i32, v8i16, IntOp>;
  def v4i32 : N2VQPLInt<op24_23, op21_20, 0b10, op17_16, op11_7, op4,
                        OpcodeStr, !strconcat(Dt, "32"), v2i64, v4i32, IntOp>;
}


// Neon Pairwise long 2-register accumulate intrinsics,
//   element sizes of 8, 16 and 32 bits:
multiclass N2VPLInt2_QHS<bits<2> op24_23, bits<2> op21_20, bits<2> op17_16,
                         bits<5> op11_7, bit op4,
                         string OpcodeStr, string Dt, SDPatternOperator IntOp> {
  // 64-bit vector types.
  def v8i8  : N2VDPLInt2<op24_23, op21_20, 0b00, op17_16, op11_7, op4,
                         OpcodeStr, !strconcat(Dt, "8"), v4i16, v8i8, IntOp>;
  def v4i16 : N2VDPLInt2<op24_23, op21_20, 0b01, op17_16, op11_7, op4,
                         OpcodeStr, !strconcat(Dt, "16"), v2i32, v4i16, IntOp>;
  def v2i32 : N2VDPLInt2<op24_23, op21_20, 0b10, op17_16, op11_7, op4,
                         OpcodeStr, !strconcat(Dt, "32"), v1i64, v2i32, IntOp>;

  // 128-bit vector types.
  def v16i8 : N2VQPLInt2<op24_23, op21_20, 0b00, op17_16, op11_7, op4,
                         OpcodeStr, !strconcat(Dt, "8"), v8i16, v16i8, IntOp>;
  def v8i16 : N2VQPLInt2<op24_23, op21_20, 0b01, op17_16, op11_7, op4,
                         OpcodeStr, !strconcat(Dt, "16"), v4i32, v8i16, IntOp>;
  def v4i32 : N2VQPLInt2<op24_23, op21_20, 0b10, op17_16, op11_7, op4,
                         OpcodeStr, !strconcat(Dt, "32"), v2i64, v4i32, IntOp>;
}


// Neon 2-register vector shift by immediate,
//   with f of either N2RegVShLFrm or N2RegVShRFrm
//   element sizes of 8, 16, 32 and 64 bits:
multiclass N2VShL_QHSD<bit op24, bit op23, bits<4> op11_8, bit op4,
                       InstrItinClass itin, string OpcodeStr, string Dt,
                       SDNode OpNode> {
  // 64-bit vector types.
  def v8i8  : N2VDSh<op24, op23, op11_8, 0, op4, N2RegVShLFrm, itin, i32imm,
                     OpcodeStr, !strconcat(Dt, "8"), v8i8, OpNode> {
    let Inst{21-19} = 0b001; // imm6 = 001xxx
  }
  def v4i16 : N2VDSh<op24, op23, op11_8, 0, op4, N2RegVShLFrm, itin, i32imm,
                     OpcodeStr, !strconcat(Dt, "16"), v4i16, OpNode> {
    let Inst{21-20} = 0b01;  // imm6 = 01xxxx
  }
  def v2i32 : N2VDSh<op24, op23, op11_8, 0, op4, N2RegVShLFrm, itin, i32imm,
                     OpcodeStr, !strconcat(Dt, "32"), v2i32, OpNode> {
    let Inst{21} = 0b1;      // imm6 = 1xxxxx
  }
  def v1i64 : N2VDSh<op24, op23, op11_8, 1, op4, N2RegVShLFrm, itin, i32imm,
                     OpcodeStr, !strconcat(Dt, "64"), v1i64, OpNode>;
                             // imm6 = xxxxxx

  // 128-bit vector types.
  def v16i8 : N2VQSh<op24, op23, op11_8, 0, op4, N2RegVShLFrm, itin, i32imm,
                     OpcodeStr, !strconcat(Dt, "8"), v16i8, OpNode> {
    let Inst{21-19} = 0b001; // imm6 = 001xxx
  }
  def v8i16 : N2VQSh<op24, op23, op11_8, 0, op4, N2RegVShLFrm, itin, i32imm,
                     OpcodeStr, !strconcat(Dt, "16"), v8i16, OpNode> {
    let Inst{21-20} = 0b01;  // imm6 = 01xxxx
  }
  def v4i32 : N2VQSh<op24, op23, op11_8, 0, op4, N2RegVShLFrm, itin, i32imm,
                     OpcodeStr, !strconcat(Dt, "32"), v4i32, OpNode> {
    let Inst{21} = 0b1;      // imm6 = 1xxxxx
  }
  def v2i64 : N2VQSh<op24, op23, op11_8, 1, op4, N2RegVShLFrm, itin, i32imm,
                     OpcodeStr, !strconcat(Dt, "64"), v2i64, OpNode>;
                             // imm6 = xxxxxx
}
multiclass N2VShR_QHSD<bit op24, bit op23, bits<4> op11_8, bit op4,
                       InstrItinClass itin, string OpcodeStr, string Dt,
                       string baseOpc, SDNode OpNode> {
  // 64-bit vector types.
  def v8i8  : N2VDSh<op24, op23, op11_8, 0, op4, N2RegVShRFrm, itin, shr_imm8,
                     OpcodeStr, !strconcat(Dt, "8"), v8i8, OpNode> {
    let Inst{21-19} = 0b001; // imm6 = 001xxx
  }
  def v4i16 : N2VDSh<op24, op23, op11_8, 0, op4, N2RegVShRFrm, itin, shr_imm16,
                     OpcodeStr, !strconcat(Dt, "16"), v4i16, OpNode> {
    let Inst{21-20} = 0b01;  // imm6 = 01xxxx
  }
  def v2i32 : N2VDSh<op24, op23, op11_8, 0, op4, N2RegVShRFrm, itin, shr_imm32,
                     OpcodeStr, !strconcat(Dt, "32"), v2i32, OpNode> {
    let Inst{21} = 0b1;      // imm6 = 1xxxxx
  }
  def v1i64 : N2VDSh<op24, op23, op11_8, 1, op4, N2RegVShRFrm, itin, shr_imm64,
                     OpcodeStr, !strconcat(Dt, "64"), v1i64, OpNode>;
                             // imm6 = xxxxxx

  // 128-bit vector types.
  def v16i8 : N2VQSh<op24, op23, op11_8, 0, op4, N2RegVShRFrm, itin, shr_imm8,
                     OpcodeStr, !strconcat(Dt, "8"), v16i8, OpNode> {
    let Inst{21-19} = 0b001; // imm6 = 001xxx
  }
  def v8i16 : N2VQSh<op24, op23, op11_8, 0, op4, N2RegVShRFrm, itin, shr_imm16,
                     OpcodeStr, !strconcat(Dt, "16"), v8i16, OpNode> {
    let Inst{21-20} = 0b01;  // imm6 = 01xxxx
  }
  def v4i32 : N2VQSh<op24, op23, op11_8, 0, op4, N2RegVShRFrm, itin, shr_imm32,
                     OpcodeStr, !strconcat(Dt, "32"), v4i32, OpNode> {
    let Inst{21} = 0b1;      // imm6 = 1xxxxx
  }
  def v2i64 : N2VQSh<op24, op23, op11_8, 1, op4, N2RegVShRFrm, itin, shr_imm64,
                     OpcodeStr, !strconcat(Dt, "64"), v2i64, OpNode>;
                             // imm6 = xxxxxx
}

// Neon Shift-Accumulate vector operations,
//   element sizes of 8, 16, 32 and 64 bits:
multiclass N2VShAdd_QHSD<bit op24, bit op23, bits<4> op11_8, bit op4,
                         string OpcodeStr, string Dt, SDNode ShOp> {
  // 64-bit vector types.
  def v8i8  : N2VDShAdd<op24, op23, op11_8, 0, op4, shr_imm8,
                        OpcodeStr, !strconcat(Dt, "8"), v8i8, ShOp> {
    let Inst{21-19} = 0b001; // imm6 = 001xxx
  }
  def v4i16 : N2VDShAdd<op24, op23, op11_8, 0, op4, shr_imm16,
                        OpcodeStr, !strconcat(Dt, "16"), v4i16, ShOp> {
    let Inst{21-20} = 0b01;  // imm6 = 01xxxx
  }
  def v2i32 : N2VDShAdd<op24, op23, op11_8, 0, op4, shr_imm32,
                        OpcodeStr, !strconcat(Dt, "32"), v2i32, ShOp> {
    let Inst{21} = 0b1;      // imm6 = 1xxxxx
  }
  def v1i64 : N2VDShAdd<op24, op23, op11_8, 1, op4, shr_imm64,
                        OpcodeStr, !strconcat(Dt, "64"), v1i64, ShOp>;
                             // imm6 = xxxxxx

  // 128-bit vector types.
  def v16i8 : N2VQShAdd<op24, op23, op11_8, 0, op4, shr_imm8,
                        OpcodeStr, !strconcat(Dt, "8"), v16i8, ShOp> {
    let Inst{21-19} = 0b001; // imm6 = 001xxx
  }
  def v8i16 : N2VQShAdd<op24, op23, op11_8, 0, op4, shr_imm16,
                        OpcodeStr, !strconcat(Dt, "16"), v8i16, ShOp> {
    let Inst{21-20} = 0b01;  // imm6 = 01xxxx
  }
  def v4i32 : N2VQShAdd<op24, op23, op11_8, 0, op4, shr_imm32,
                        OpcodeStr, !strconcat(Dt, "32"), v4i32, ShOp> {
    let Inst{21} = 0b1;      // imm6 = 1xxxxx
  }
  def v2i64 : N2VQShAdd<op24, op23, op11_8, 1, op4, shr_imm64,
                        OpcodeStr, !strconcat(Dt, "64"), v2i64, ShOp>;
                             // imm6 = xxxxxx
}

// Neon Shift-Insert vector operations,
//   with f of either N2RegVShLFrm or N2RegVShRFrm
//   element sizes of 8, 16, 32 and 64 bits:
multiclass N2VShInsL_QHSD<bit op24, bit op23, bits<4> op11_8, bit op4,
                          string OpcodeStr> {
  // 64-bit vector types.
  def v8i8  : N2VDShIns<op24, op23, op11_8, 0, op4, i32imm,
                        N2RegVShLFrm, OpcodeStr, "8", v8i8, NEONvsli> {
    let Inst{21-19} = 0b001; // imm6 = 001xxx
  }
  def v4i16 : N2VDShIns<op24, op23, op11_8, 0, op4, i32imm,
                        N2RegVShLFrm, OpcodeStr, "16", v4i16, NEONvsli> {
    let Inst{21-20} = 0b01;  // imm6 = 01xxxx
  }
  def v2i32 : N2VDShIns<op24, op23, op11_8, 0, op4, i32imm,
                        N2RegVShLFrm, OpcodeStr, "32", v2i32, NEONvsli> {
    let Inst{21} = 0b1;      // imm6 = 1xxxxx
  }
  def v1i64 : N2VDShIns<op24, op23, op11_8, 1, op4, i32imm,
                        N2RegVShLFrm, OpcodeStr, "64", v1i64, NEONvsli>;
                             // imm6 = xxxxxx

  // 128-bit vector types.
  def v16i8 : N2VQShIns<op24, op23, op11_8, 0, op4, i32imm,
                        N2RegVShLFrm, OpcodeStr, "8", v16i8, NEONvsli> {
    let Inst{21-19} = 0b001; // imm6 = 001xxx
  }
  def v8i16 : N2VQShIns<op24, op23, op11_8, 0, op4, i32imm,
                        N2RegVShLFrm, OpcodeStr, "16", v8i16, NEONvsli> {
    let Inst{21-20} = 0b01;  // imm6 = 01xxxx
  }
  def v4i32 : N2VQShIns<op24, op23, op11_8, 0, op4, i32imm,
                        N2RegVShLFrm, OpcodeStr, "32", v4i32, NEONvsli> {
    let Inst{21} = 0b1;      // imm6 = 1xxxxx
  }
  def v2i64 : N2VQShIns<op24, op23, op11_8, 1, op4, i32imm,
                        N2RegVShLFrm, OpcodeStr, "64", v2i64, NEONvsli>;
                             // imm6 = xxxxxx
}
multiclass N2VShInsR_QHSD<bit op24, bit op23, bits<4> op11_8, bit op4,
                          string OpcodeStr> {
  // 64-bit vector types.
  def v8i8  : N2VDShIns<op24, op23, op11_8, 0, op4, shr_imm8,
                        N2RegVShRFrm, OpcodeStr, "8", v8i8, NEONvsri> {
    let Inst{21-19} = 0b001; // imm6 = 001xxx
  }
  def v4i16 : N2VDShIns<op24, op23, op11_8, 0, op4, shr_imm16,
                        N2RegVShRFrm, OpcodeStr, "16", v4i16, NEONvsri> {
    let Inst{21-20} = 0b01;  // imm6 = 01xxxx
  }
  def v2i32 : N2VDShIns<op24, op23, op11_8, 0, op4, shr_imm32,
                        N2RegVShRFrm, OpcodeStr, "32", v2i32, NEONvsri> {
    let Inst{21} = 0b1;      // imm6 = 1xxxxx
  }
  def v1i64 : N2VDShIns<op24, op23, op11_8, 1, op4, shr_imm64,
                        N2RegVShRFrm, OpcodeStr, "64", v1i64, NEONvsri>;
                             // imm6 = xxxxxx

  // 128-bit vector types.
  def v16i8 : N2VQShIns<op24, op23, op11_8, 0, op4, shr_imm8,
                        N2RegVShRFrm, OpcodeStr, "8", v16i8, NEONvsri> {
    let Inst{21-19} = 0b001; // imm6 = 001xxx
  }
  def v8i16 : N2VQShIns<op24, op23, op11_8, 0, op4, shr_imm16,
                        N2RegVShRFrm, OpcodeStr, "16", v8i16, NEONvsri> {
    let Inst{21-20} = 0b01;  // imm6 = 01xxxx
  }
  def v4i32 : N2VQShIns<op24, op23, op11_8, 0, op4, shr_imm32,
                        N2RegVShRFrm, OpcodeStr, "32", v4i32, NEONvsri> {
    let Inst{21} = 0b1;      // imm6 = 1xxxxx
  }
  def v2i64 : N2VQShIns<op24, op23, op11_8, 1, op4, shr_imm64,
                        N2RegVShRFrm, OpcodeStr, "64", v2i64, NEONvsri>;
                             // imm6 = xxxxxx
}

// Neon Shift Long operations,
//   element sizes of 8, 16, 32 bits:
multiclass N2VLSh_QHS<bit op24, bit op23, bits<4> op11_8, bit op7, bit op6,
                      bit op4, string OpcodeStr, string Dt, SDNode OpNode> {
  def v8i16 : N2VLSh<op24, op23, op11_8, op7, op6, op4,
              OpcodeStr, !strconcat(Dt, "8"), v8i16, v8i8, imm1_7, OpNode> {
    let Inst{21-19} = 0b001; // imm6 = 001xxx
  }
  def v4i32 : N2VLSh<op24, op23, op11_8, op7, op6, op4,
               OpcodeStr, !strconcat(Dt, "16"), v4i32, v4i16, imm1_15, OpNode> {
    let Inst{21-20} = 0b01;  // imm6 = 01xxxx
  }
  def v2i64 : N2VLSh<op24, op23, op11_8, op7, op6, op4,
               OpcodeStr, !strconcat(Dt, "32"), v2i64, v2i32, imm1_31, OpNode> {
    let Inst{21} = 0b1;      // imm6 = 1xxxxx
  }
}

// Neon Shift Narrow operations,
//   element sizes of 16, 32, 64 bits:
multiclass N2VNSh_HSD<bit op24, bit op23, bits<4> op11_8, bit op7, bit op6,
                      bit op4, InstrItinClass itin, string OpcodeStr, string Dt,
                      SDNode OpNode> {
  def v8i8 : N2VNSh<op24, op23, op11_8, op7, op6, op4, itin,
                    OpcodeStr, !strconcat(Dt, "16"),
                    v8i8, v8i16, shr_imm8, OpNode> {
    let Inst{21-19} = 0b001; // imm6 = 001xxx
  }
  def v4i16 : N2VNSh<op24, op23, op11_8, op7, op6, op4, itin,
                     OpcodeStr, !strconcat(Dt, "32"),
                     v4i16, v4i32, shr_imm16, OpNode> {
    let Inst{21-20} = 0b01;  // imm6 = 01xxxx
  }
  def v2i32 : N2VNSh<op24, op23, op11_8, op7, op6, op4, itin,
                     OpcodeStr, !strconcat(Dt, "64"),
                     v2i32, v2i64, shr_imm32, OpNode> {
    let Inst{21} = 0b1;      // imm6 = 1xxxxx
  }
}

//===----------------------------------------------------------------------===//
// Instruction Definitions.
//===----------------------------------------------------------------------===//

// Vector Add Operations.

//   VADD     : Vector Add (integer and floating-point)
defm VADD     : N3V_QHSD<0, 0, 0b1000, 0, IIC_VBINiD, IIC_VBINiQ, "vadd", "i",
                         add, 1>;
def  VADDfd   : N3VD<0, 0, 0b00, 0b1101, 0, IIC_VBIND, "vadd", "f32",
                     v2f32, v2f32, fadd, 1>;
def  VADDfq   : N3VQ<0, 0, 0b00, 0b1101, 0, IIC_VBINQ, "vadd", "f32",
                     v4f32, v4f32, fadd, 1>;
//   VADDL    : Vector Add Long (Q = D + D)
defm VADDLs   : N3VLExt_QHS<0,1,0b0000,0, IIC_VSHLiD, IIC_VSHLiD,
                            "vaddl", "s", add, sext, 1>;
defm VADDLu   : N3VLExt_QHS<1,1,0b0000,0, IIC_VSHLiD, IIC_VSHLiD,
                            "vaddl", "u", add, zext, 1>;
//   VADDW    : Vector Add Wide (Q = Q + D)
defm VADDWs   : N3VW_QHS<0,1,0b0001,0, "vaddw", "s", add, sext, 0>;
defm VADDWu   : N3VW_QHS<1,1,0b0001,0, "vaddw", "u", add, zext, 0>;
//   VHADD    : Vector Halving Add
defm VHADDs   : N3VInt_QHS<0, 0, 0b0000, 0, N3RegFrm,
                           IIC_VBINi4D, IIC_VBINi4D, IIC_VBINi4Q, IIC_VBINi4Q,
                           "vhadd", "s", int_arm_neon_vhadds, 1>;
defm VHADDu   : N3VInt_QHS<1, 0, 0b0000, 0, N3RegFrm,
                           IIC_VBINi4D, IIC_VBINi4D, IIC_VBINi4Q, IIC_VBINi4Q,
                           "vhadd", "u", int_arm_neon_vhaddu, 1>;
//   VRHADD   : Vector Rounding Halving Add
defm VRHADDs  : N3VInt_QHS<0, 0, 0b0001, 0, N3RegFrm,
                           IIC_VBINi4D, IIC_VBINi4D, IIC_VBINi4Q, IIC_VBINi4Q,
                           "vrhadd", "s", int_arm_neon_vrhadds, 1>;
defm VRHADDu  : N3VInt_QHS<1, 0, 0b0001, 0, N3RegFrm,
                           IIC_VBINi4D, IIC_VBINi4D, IIC_VBINi4Q, IIC_VBINi4Q,
                           "vrhadd", "u", int_arm_neon_vrhaddu, 1>;
//   VQADD    : Vector Saturating Add
defm VQADDs   : N3VInt_QHSD<0, 0, 0b0000, 1, N3RegFrm,
                            IIC_VBINi4D, IIC_VBINi4D, IIC_VBINi4Q, IIC_VBINi4Q,
                            "vqadd", "s", int_arm_neon_vqadds, 1>;
defm VQADDu   : N3VInt_QHSD<1, 0, 0b0000, 1, N3RegFrm,
                            IIC_VBINi4D, IIC_VBINi4D, IIC_VBINi4Q, IIC_VBINi4Q,
                            "vqadd", "u", int_arm_neon_vqaddu, 1>;
//   VADDHN   : Vector Add and Narrow Returning High Half (D = Q + Q)
defm VADDHN   : N3VNInt_HSD<0,1,0b0100,0, "vaddhn", "i",
                            int_arm_neon_vaddhn, 1>;
//   VRADDHN  : Vector Rounding Add and Narrow Returning High Half (D = Q + Q)
defm VRADDHN  : N3VNInt_HSD<1,1,0b0100,0, "vraddhn", "i",
                            int_arm_neon_vraddhn, 1>;

// Vector Multiply Operations.

//   VMUL     : Vector Multiply (integer, polynomial and floating-point)
defm VMUL     : N3V_QHS<0, 0, 0b1001, 1, IIC_VMULi16D, IIC_VMULi32D,
                        IIC_VMULi16Q, IIC_VMULi32Q, "vmul", "i", mul, 1>;
def  VMULpd   : N3VDInt<1, 0, 0b00, 0b1001, 1, N3RegFrm, IIC_VMULi16D, "vmul",
                        "p8", v8i8, v8i8, int_arm_neon_vmulp, 1>;
def  VMULpq   : N3VQInt<1, 0, 0b00, 0b1001, 1, N3RegFrm, IIC_VMULi16Q, "vmul",
                        "p8", v16i8, v16i8, int_arm_neon_vmulp, 1>;
def  VMULfd   : N3VD<1, 0, 0b00, 0b1101, 1, IIC_VFMULD, "vmul", "f32",
                     v2f32, v2f32, fmul, 1>;
def  VMULfq   : N3VQ<1, 0, 0b00, 0b1101, 1, IIC_VFMULQ, "vmul", "f32",
                     v4f32, v4f32, fmul, 1>;
defm VMULsl   : N3VSL_HS<0b1000, "vmul", mul>;
def  VMULslfd : N3VDSL<0b10, 0b1001, IIC_VBIND, "vmul", "f32", v2f32, fmul>;
def  VMULslfq : N3VQSL<0b10, 0b1001, IIC_VBINQ, "vmul", "f32", v4f32,
                       v2f32, fmul>;

def : Pat<(v8i16 (mul (v8i16 QPR:$src1),
                      (v8i16 (NEONvduplane (v8i16 QPR:$src2), imm:$lane)))),
          (v8i16 (VMULslv8i16 (v8i16 QPR:$src1),
                              (v4i16 (EXTRACT_SUBREG QPR:$src2,
                                      (DSubReg_i16_reg imm:$lane))),
                              (SubReg_i16_lane imm:$lane)))>;
def : Pat<(v4i32 (mul (v4i32 QPR:$src1),
                      (v4i32 (NEONvduplane (v4i32 QPR:$src2), imm:$lane)))),
          (v4i32 (VMULslv4i32 (v4i32 QPR:$src1),
                              (v2i32 (EXTRACT_SUBREG QPR:$src2,
                                      (DSubReg_i32_reg imm:$lane))),
                              (SubReg_i32_lane imm:$lane)))>;
def : Pat<(v4f32 (fmul (v4f32 QPR:$src1),
                       (v4f32 (NEONvduplane (v4f32 QPR:$src2), imm:$lane)))),
          (v4f32 (VMULslfq (v4f32 QPR:$src1),
                           (v2f32 (EXTRACT_SUBREG QPR:$src2,
                                   (DSubReg_i32_reg imm:$lane))),
                           (SubReg_i32_lane imm:$lane)))>;

//   VQDMULH  : Vector Saturating Doubling Multiply Returning High Half
defm VQDMULH  : N3VInt_HS<0, 0, 0b1011, 0, N3RegFrm, IIC_VMULi16D, IIC_VMULi32D,
                          IIC_VMULi16Q, IIC_VMULi32Q,
                          "vqdmulh", "s", int_arm_neon_vqdmulh, 1>;
defm VQDMULHsl: N3VIntSL_HS<0b1100, IIC_VMULi16D, IIC_VMULi32D,
                            IIC_VMULi16Q, IIC_VMULi32Q,
                            "vqdmulh", "s",  int_arm_neon_vqdmulh>;
def : Pat<(v8i16 (int_arm_neon_vqdmulh (v8i16 QPR:$src1),
                                       (v8i16 (NEONvduplane (v8i16 QPR:$src2),
                                                            imm:$lane)))),
          (v8i16 (VQDMULHslv8i16 (v8i16 QPR:$src1),
                                 (v4i16 (EXTRACT_SUBREG QPR:$src2,
                                         (DSubReg_i16_reg imm:$lane))),
                                 (SubReg_i16_lane imm:$lane)))>;
def : Pat<(v4i32 (int_arm_neon_vqdmulh (v4i32 QPR:$src1),
                                       (v4i32 (NEONvduplane (v4i32 QPR:$src2),
                                                            imm:$lane)))),
          (v4i32 (VQDMULHslv4i32 (v4i32 QPR:$src1),
                                 (v2i32 (EXTRACT_SUBREG QPR:$src2,
                                         (DSubReg_i32_reg imm:$lane))),
                                 (SubReg_i32_lane imm:$lane)))>;

//   VQRDMULH : Vector Rounding Saturating Doubling Multiply Returning High Half
defm VQRDMULH   : N3VInt_HS<1, 0, 0b1011, 0, N3RegFrm,
                            IIC_VMULi16D,IIC_VMULi32D,IIC_VMULi16Q,IIC_VMULi32Q,
                            "vqrdmulh", "s", int_arm_neon_vqrdmulh, 1>;
defm VQRDMULHsl : N3VIntSL_HS<0b1101, IIC_VMULi16D, IIC_VMULi32D,
                              IIC_VMULi16Q, IIC_VMULi32Q,
                              "vqrdmulh", "s",  int_arm_neon_vqrdmulh>;
def : Pat<(v8i16 (int_arm_neon_vqrdmulh (v8i16 QPR:$src1),
                                        (v8i16 (NEONvduplane (v8i16 QPR:$src2),
                                                             imm:$lane)))),
          (v8i16 (VQRDMULHslv8i16 (v8i16 QPR:$src1),
                                  (v4i16 (EXTRACT_SUBREG QPR:$src2,
                                          (DSubReg_i16_reg imm:$lane))),
                                  (SubReg_i16_lane imm:$lane)))>;
def : Pat<(v4i32 (int_arm_neon_vqrdmulh (v4i32 QPR:$src1),
                                        (v4i32 (NEONvduplane (v4i32 QPR:$src2),
                                                             imm:$lane)))),
          (v4i32 (VQRDMULHslv4i32 (v4i32 QPR:$src1),
                                  (v2i32 (EXTRACT_SUBREG QPR:$src2,
                                          (DSubReg_i32_reg imm:$lane))),
                                  (SubReg_i32_lane imm:$lane)))>;

//   VMULL    : Vector Multiply Long (integer and polynomial) (Q = D * D)
defm VMULLs   : N3VL_QHS<0,1,0b1100,0, IIC_VMULi16D, IIC_VMULi32D,
                         "vmull", "s", NEONvmulls, 1>;
defm VMULLu   : N3VL_QHS<1,1,0b1100,0, IIC_VMULi16D, IIC_VMULi32D,
                         "vmull", "u", NEONvmullu, 1>;
def  VMULLp   : N3VLInt<0, 1, 0b00, 0b1110, 0, IIC_VMULi16D, "vmull", "p8",
                        v8i16, v8i8, int_arm_neon_vmullp, 1>;
defm VMULLsls : N3VLSL_HS<0, 0b1010, IIC_VMULi16D, "vmull", "s", NEONvmulls>;
defm VMULLslu : N3VLSL_HS<1, 0b1010, IIC_VMULi16D, "vmull", "u", NEONvmullu>;

//   VQDMULL  : Vector Saturating Doubling Multiply Long (Q = D * D)
defm VQDMULL  : N3VLInt_HS<0,1,0b1101,0, IIC_VMULi16D, IIC_VMULi32D,
                           "vqdmull", "s", int_arm_neon_vqdmull, 1>;
defm VQDMULLsl: N3VLIntSL_HS<0, 0b1011, IIC_VMULi16D,
                             "vqdmull", "s", int_arm_neon_vqdmull>;

// Vector Multiply-Accumulate and Multiply-Subtract Operations.

//   VMLA     : Vector Multiply Accumulate (integer and floating-point)
defm VMLA     : N3VMulOp_QHS<0, 0, 0b1001, 0, IIC_VMACi16D, IIC_VMACi32D,
                             IIC_VMACi16Q, IIC_VMACi32Q, "vmla", "i", add>;
def  VMLAfd   : N3VDMulOp<0, 0, 0b00, 0b1101, 1, IIC_VMACD, "vmla", "f32",
                          v2f32, fmul_su, fadd_mlx>,
                Requires<[HasNEON, UseFPVMLx, DontUseFusedMAC]>;
def  VMLAfq   : N3VQMulOp<0, 0, 0b00, 0b1101, 1, IIC_VMACQ, "vmla", "f32",
                          v4f32, fmul_su, fadd_mlx>,
                Requires<[HasNEON, UseFPVMLx, DontUseFusedMAC]>;
defm VMLAsl   : N3VMulOpSL_HS<0b0000, IIC_VMACi16D, IIC_VMACi32D,
                              IIC_VMACi16Q, IIC_VMACi32Q, "vmla", "i", add>;
def  VMLAslfd : N3VDMulOpSL<0b10, 0b0001, IIC_VMACD, "vmla", "f32",
                            v2f32, fmul_su, fadd_mlx>,
                Requires<[HasNEON, UseFPVMLx]>;
def  VMLAslfq : N3VQMulOpSL<0b10, 0b0001, IIC_VMACQ, "vmla", "f32",
                            v4f32, v2f32, fmul_su, fadd_mlx>,
                Requires<[HasNEON, UseFPVMLx]>;

def : Pat<(v8i16 (add (v8i16 QPR:$src1),
                  (mul (v8i16 QPR:$src2),
                       (v8i16 (NEONvduplane (v8i16 QPR:$src3), imm:$lane))))),
          (v8i16 (VMLAslv8i16 (v8i16 QPR:$src1), (v8i16 QPR:$src2),
                              (v4i16 (EXTRACT_SUBREG QPR:$src3,
                                      (DSubReg_i16_reg imm:$lane))),
                              (SubReg_i16_lane imm:$lane)))>;

def : Pat<(v4i32 (add (v4i32 QPR:$src1),
                  (mul (v4i32 QPR:$src2),
                       (v4i32 (NEONvduplane (v4i32 QPR:$src3), imm:$lane))))),
          (v4i32 (VMLAslv4i32 (v4i32 QPR:$src1), (v4i32 QPR:$src2),
                              (v2i32 (EXTRACT_SUBREG QPR:$src3,
                                      (DSubReg_i32_reg imm:$lane))),
                              (SubReg_i32_lane imm:$lane)))>;

def : Pat<(v4f32 (fadd_mlx (v4f32 QPR:$src1),
                  (fmul_su (v4f32 QPR:$src2),
                        (v4f32 (NEONvduplane (v4f32 QPR:$src3), imm:$lane))))),
          (v4f32 (VMLAslfq (v4f32 QPR:$src1),
                           (v4f32 QPR:$src2),
                           (v2f32 (EXTRACT_SUBREG QPR:$src3,
                                   (DSubReg_i32_reg imm:$lane))),
                           (SubReg_i32_lane imm:$lane)))>,
          Requires<[HasNEON, UseFPVMLx]>;

//   VMLAL    : Vector Multiply Accumulate Long (Q += D * D)
defm VMLALs   : N3VLMulOp_QHS<0,1,0b1000,0, IIC_VMACi16D, IIC_VMACi32D,
                              "vmlal", "s", NEONvmulls, add>;
defm VMLALu   : N3VLMulOp_QHS<1,1,0b1000,0, IIC_VMACi16D, IIC_VMACi32D,
                              "vmlal", "u", NEONvmullu, add>;

defm VMLALsls : N3VLMulOpSL_HS<0, 0b0010, "vmlal", "s", NEONvmulls, add>;
defm VMLALslu : N3VLMulOpSL_HS<1, 0b0010, "vmlal", "u", NEONvmullu, add>;

//   VQDMLAL  : Vector Saturating Doubling Multiply Accumulate Long (Q += D * D)
defm VQDMLAL  : N3VLInt3_HS<0, 1, 0b1001, 0, IIC_VMACi16D, IIC_VMACi32D,
                            "vqdmlal", "s", int_arm_neon_vqdmlal>;
defm VQDMLALsl: N3VLInt3SL_HS<0, 0b0011, "vqdmlal", "s", int_arm_neon_vqdmlal>;

//   VMLS     : Vector Multiply Subtract (integer and floating-point)
defm VMLS     : N3VMulOp_QHS<1, 0, 0b1001, 0, IIC_VMACi16D, IIC_VMACi32D,
                             IIC_VMACi16Q, IIC_VMACi32Q, "vmls", "i", sub>;
def  VMLSfd   : N3VDMulOp<0, 0, 0b10, 0b1101, 1, IIC_VMACD, "vmls", "f32",
                          v2f32, fmul_su, fsub_mlx>,
                Requires<[HasNEON, UseFPVMLx, DontUseFusedMAC]>;
def  VMLSfq   : N3VQMulOp<0, 0, 0b10, 0b1101, 1, IIC_VMACQ, "vmls", "f32",
                          v4f32, fmul_su, fsub_mlx>,
                Requires<[HasNEON, UseFPVMLx, DontUseFusedMAC]>;
defm VMLSsl   : N3VMulOpSL_HS<0b0100, IIC_VMACi16D, IIC_VMACi32D,
                              IIC_VMACi16Q, IIC_VMACi32Q, "vmls", "i", sub>;
def  VMLSslfd : N3VDMulOpSL<0b10, 0b0101, IIC_VMACD, "vmls", "f32",
                            v2f32, fmul_su, fsub_mlx>,
                Requires<[HasNEON, UseFPVMLx]>;
def  VMLSslfq : N3VQMulOpSL<0b10, 0b0101, IIC_VMACQ, "vmls", "f32",
                            v4f32, v2f32, fmul_su, fsub_mlx>,
                Requires<[HasNEON, UseFPVMLx]>;

def : Pat<(v8i16 (sub (v8i16 QPR:$src1),
                  (mul (v8i16 QPR:$src2),
                       (v8i16 (NEONvduplane (v8i16 QPR:$src3), imm:$lane))))),
          (v8i16 (VMLSslv8i16 (v8i16 QPR:$src1), (v8i16 QPR:$src2),
                              (v4i16 (EXTRACT_SUBREG QPR:$src3,
                                      (DSubReg_i16_reg imm:$lane))),
                              (SubReg_i16_lane imm:$lane)))>;

def : Pat<(v4i32 (sub (v4i32 QPR:$src1),
                  (mul (v4i32 QPR:$src2),
                     (v4i32 (NEONvduplane (v4i32 QPR:$src3), imm:$lane))))),
          (v4i32 (VMLSslv4i32 (v4i32 QPR:$src1), (v4i32 QPR:$src2),
                              (v2i32 (EXTRACT_SUBREG QPR:$src3,
                                      (DSubReg_i32_reg imm:$lane))),
                              (SubReg_i32_lane imm:$lane)))>;

def : Pat<(v4f32 (fsub_mlx (v4f32 QPR:$src1),
                  (fmul_su (v4f32 QPR:$src2),
                        (v4f32 (NEONvduplane (v4f32 QPR:$src3), imm:$lane))))),
          (v4f32 (VMLSslfq (v4f32 QPR:$src1), (v4f32 QPR:$src2),
                           (v2f32 (EXTRACT_SUBREG QPR:$src3,
                                   (DSubReg_i32_reg imm:$lane))),
                           (SubReg_i32_lane imm:$lane)))>,
          Requires<[HasNEON, UseFPVMLx]>;

//   VMLSL    : Vector Multiply Subtract Long (Q -= D * D)
defm VMLSLs   : N3VLMulOp_QHS<0,1,0b1010,0, IIC_VMACi16D, IIC_VMACi32D,
                              "vmlsl", "s", NEONvmulls, sub>;
defm VMLSLu   : N3VLMulOp_QHS<1,1,0b1010,0, IIC_VMACi16D, IIC_VMACi32D,
                              "vmlsl", "u", NEONvmullu, sub>;

defm VMLSLsls : N3VLMulOpSL_HS<0, 0b0110, "vmlsl", "s", NEONvmulls, sub>;
defm VMLSLslu : N3VLMulOpSL_HS<1, 0b0110, "vmlsl", "u", NEONvmullu, sub>;

//   VQDMLSL  : Vector Saturating Doubling Multiply Subtract Long (Q -= D * D)
defm VQDMLSL  : N3VLInt3_HS<0, 1, 0b1011, 0, IIC_VMACi16D, IIC_VMACi32D,
                            "vqdmlsl", "s", int_arm_neon_vqdmlsl>;
defm VQDMLSLsl: N3VLInt3SL_HS<0, 0b111, "vqdmlsl", "s", int_arm_neon_vqdmlsl>;

// Fused Vector Multiply-Accumulate and Fused Multiply-Subtract Operations.
def  VFMAfd   : N3VDMulOp<0, 0, 0b00, 0b1100, 1, IIC_VFMACD, "vfma", "f32",
                          v2f32, fmul_su, fadd_mlx>,
                Requires<[HasVFP4,UseFusedMAC]>;

def  VFMAfq   : N3VQMulOp<0, 0, 0b00, 0b1100, 1, IIC_VFMACQ, "vfma", "f32",
                          v4f32, fmul_su, fadd_mlx>,
                Requires<[HasVFP4,UseFusedMAC]>;

//   Fused Vector Multiply Subtract (floating-point)
def  VFMSfd   : N3VDMulOp<0, 0, 0b10, 0b1100, 1, IIC_VFMACD, "vfms", "f32",
                          v2f32, fmul_su, fsub_mlx>,
                Requires<[HasVFP4,UseFusedMAC]>;
def  VFMSfq   : N3VQMulOp<0, 0, 0b10, 0b1100, 1, IIC_VFMACQ, "vfms", "f32",
                          v4f32, fmul_su, fsub_mlx>,
                Requires<[HasVFP4,UseFusedMAC]>;

// Match @llvm.fma.* intrinsics
def : Pat<(v2f32 (fma DPR:$Vn, DPR:$Vm, DPR:$src1)),
          (VFMAfd DPR:$src1, DPR:$Vn, DPR:$Vm)>,
          Requires<[HasVFP4]>;
def : Pat<(v4f32 (fma QPR:$Vn, QPR:$Vm, QPR:$src1)),
          (VFMAfq QPR:$src1, QPR:$Vn, QPR:$Vm)>,
          Requires<[HasVFP4]>;
def : Pat<(v2f32 (fma (fneg DPR:$Vn), DPR:$Vm, DPR:$src1)),
          (VFMSfd DPR:$src1, DPR:$Vn, DPR:$Vm)>,
      Requires<[HasVFP4]>;
def : Pat<(v4f32 (fma (fneg QPR:$Vn), QPR:$Vm, QPR:$src1)),
          (VFMSfq QPR:$src1, QPR:$Vn, QPR:$Vm)>,
      Requires<[HasVFP4]>;

// Vector Subtract Operations.

//   VSUB     : Vector Subtract (integer and floating-point)
defm VSUB     : N3V_QHSD<1, 0, 0b1000, 0, IIC_VSUBiD, IIC_VSUBiQ,
                         "vsub", "i", sub, 0>;
def  VSUBfd   : N3VD<0, 0, 0b10, 0b1101, 0, IIC_VBIND, "vsub", "f32",
                     v2f32, v2f32, fsub, 0>;
def  VSUBfq   : N3VQ<0, 0, 0b10, 0b1101, 0, IIC_VBINQ, "vsub", "f32",
                     v4f32, v4f32, fsub, 0>;
//   VSUBL    : Vector Subtract Long (Q = D - D)
defm VSUBLs   : N3VLExt_QHS<0,1,0b0010,0, IIC_VSHLiD, IIC_VSHLiD,
                            "vsubl", "s", sub, sext, 0>;
defm VSUBLu   : N3VLExt_QHS<1,1,0b0010,0, IIC_VSHLiD, IIC_VSHLiD,
                            "vsubl", "u", sub, zext, 0>;
//   VSUBW    : Vector Subtract Wide (Q = Q - D)
defm VSUBWs   : N3VW_QHS<0,1,0b0011,0, "vsubw", "s", sub, sext, 0>;
defm VSUBWu   : N3VW_QHS<1,1,0b0011,0, "vsubw", "u", sub, zext, 0>;
//   VHSUB    : Vector Halving Subtract
defm VHSUBs   : N3VInt_QHS<0, 0, 0b0010, 0, N3RegFrm,
                           IIC_VSUBi4D, IIC_VSUBi4D, IIC_VSUBi4Q, IIC_VSUBi4Q,
                           "vhsub", "s", int_arm_neon_vhsubs, 0>;
defm VHSUBu   : N3VInt_QHS<1, 0, 0b0010, 0, N3RegFrm,
                           IIC_VSUBi4D, IIC_VSUBi4D, IIC_VSUBi4Q, IIC_VSUBi4Q,
                           "vhsub", "u", int_arm_neon_vhsubu, 0>;
//   VQSUB    : Vector Saturing Subtract
defm VQSUBs   : N3VInt_QHSD<0, 0, 0b0010, 1, N3RegFrm,
                            IIC_VSUBi4D, IIC_VSUBi4D, IIC_VSUBi4Q, IIC_VSUBi4Q,
                            "vqsub", "s", int_arm_neon_vqsubs, 0>;
defm VQSUBu   : N3VInt_QHSD<1, 0, 0b0010, 1, N3RegFrm,
                            IIC_VSUBi4D, IIC_VSUBi4D, IIC_VSUBi4Q, IIC_VSUBi4Q,
                            "vqsub", "u", int_arm_neon_vqsubu, 0>;
//   VSUBHN   : Vector Subtract and Narrow Returning High Half (D = Q - Q)
defm VSUBHN   : N3VNInt_HSD<0,1,0b0110,0, "vsubhn", "i",
                            int_arm_neon_vsubhn, 0>;
//   VRSUBHN  : Vector Rounding Subtract and Narrow Returning High Half (D=Q-Q)
defm VRSUBHN  : N3VNInt_HSD<1,1,0b0110,0, "vrsubhn", "i",
                            int_arm_neon_vrsubhn, 0>;

// Vector Comparisons.

//   VCEQ     : Vector Compare Equal
defm VCEQ     : N3V_QHS<1, 0, 0b1000, 1, IIC_VSUBi4D, IIC_VSUBi4D, IIC_VSUBi4Q,
                        IIC_VSUBi4Q, "vceq", "i", NEONvceq, 1>;
def  VCEQfd   : N3VD<0,0,0b00,0b1110,0, IIC_VBIND, "vceq", "f32", v2i32, v2f32,
                     NEONvceq, 1>;
def  VCEQfq   : N3VQ<0,0,0b00,0b1110,0, IIC_VBINQ, "vceq", "f32", v4i32, v4f32,
                     NEONvceq, 1>;

let TwoOperandAliasConstraint = "$Vm = $Vd" in
defm VCEQz    : N2V_QHS_cmp<0b11, 0b11, 0b01, 0b00010, 0, "vceq", "i",
                            "$Vd, $Vm, #0", NEONvceqz>;

//   VCGE     : Vector Compare Greater Than or Equal
defm VCGEs    : N3V_QHS<0, 0, 0b0011, 1, IIC_VSUBi4D, IIC_VSUBi4D, IIC_VSUBi4Q,
                        IIC_VSUBi4Q, "vcge", "s", NEONvcge, 0>;
defm VCGEu    : N3V_QHS<1, 0, 0b0011, 1, IIC_VSUBi4D, IIC_VSUBi4D, IIC_VSUBi4Q,
                        IIC_VSUBi4Q, "vcge", "u", NEONvcgeu, 0>;
def  VCGEfd   : N3VD<1,0,0b00,0b1110,0, IIC_VBIND, "vcge", "f32", v2i32, v2f32,
                     NEONvcge, 0>;
def  VCGEfq   : N3VQ<1,0,0b00,0b1110,0, IIC_VBINQ, "vcge", "f32", v4i32, v4f32,
                     NEONvcge, 0>;

let TwoOperandAliasConstraint = "$Vm = $Vd" in {
defm VCGEz    : N2V_QHS_cmp<0b11, 0b11, 0b01, 0b00001, 0, "vcge", "s",
                            "$Vd, $Vm, #0", NEONvcgez>;
defm VCLEz    : N2V_QHS_cmp<0b11, 0b11, 0b01, 0b00011, 0, "vcle", "s",
                            "$Vd, $Vm, #0", NEONvclez>;
}

//   VCGT     : Vector Compare Greater Than
defm VCGTs    : N3V_QHS<0, 0, 0b0011, 0, IIC_VSUBi4D, IIC_VSUBi4D, IIC_VSUBi4Q,
                        IIC_VSUBi4Q, "vcgt", "s", NEONvcgt, 0>;
defm VCGTu    : N3V_QHS<1, 0, 0b0011, 0, IIC_VSUBi4D, IIC_VSUBi4D, IIC_VSUBi4Q,
                        IIC_VSUBi4Q, "vcgt", "u", NEONvcgtu, 0>;
def  VCGTfd   : N3VD<1,0,0b10,0b1110,0, IIC_VBIND, "vcgt", "f32", v2i32, v2f32,
                     NEONvcgt, 0>;
def  VCGTfq   : N3VQ<1,0,0b10,0b1110,0, IIC_VBINQ, "vcgt", "f32", v4i32, v4f32,
                     NEONvcgt, 0>;

let TwoOperandAliasConstraint = "$Vm = $Vd" in {
defm VCGTz    : N2V_QHS_cmp<0b11, 0b11, 0b01, 0b00000, 0, "vcgt", "s",
                            "$Vd, $Vm, #0", NEONvcgtz>;
defm VCLTz    : N2V_QHS_cmp<0b11, 0b11, 0b01, 0b00100, 0, "vclt", "s",
                            "$Vd, $Vm, #0", NEONvcltz>;
}

//   VACGE    : Vector Absolute Compare Greater Than or Equal (aka VCAGE)
def  VACGEd   : N3VDInt<1, 0, 0b00, 0b1110, 1, N3RegFrm, IIC_VBIND, "vacge",
                        "f32", v2i32, v2f32, int_arm_neon_vacged, 0>;
def  VACGEq   : N3VQInt<1, 0, 0b00, 0b1110, 1, N3RegFrm, IIC_VBINQ, "vacge",
                        "f32", v4i32, v4f32, int_arm_neon_vacgeq, 0>;
//   VACGT    : Vector Absolute Compare Greater Than (aka VCAGT)
def  VACGTd   : N3VDInt<1, 0, 0b10, 0b1110, 1, N3RegFrm, IIC_VBIND, "vacgt",
                        "f32", v2i32, v2f32, int_arm_neon_vacgtd, 0>;
def  VACGTq   : N3VQInt<1, 0, 0b10, 0b1110, 1, N3RegFrm, IIC_VBINQ, "vacgt",
                        "f32", v4i32, v4f32, int_arm_neon_vacgtq, 0>;
//   VTST     : Vector Test Bits
defm VTST     : N3V_QHS<0, 0, 0b1000, 1, IIC_VBINi4D, IIC_VBINi4D, IIC_VBINi4Q,
                        IIC_VBINi4Q, "vtst", "", NEONvtst, 1>;

def: NEONInstAlias<"vaclt${p}.f32 $Vd, $Vn, $Vm",
                   (VACGTd DPR:$Vd, DPR:$Vm, DPR:$Vn, pred:$p)>;
def: NEONInstAlias<"vaclt${p}.f32 $Vd, $Vn, $Vm",
                   (VACGTq QPR:$Vd, QPR:$Vm, QPR:$Vn, pred:$p)>;
def: NEONInstAlias<"vacle${p}.f32 $Vd, $Vn, $Vm",
                   (VACGEd DPR:$Vd, DPR:$Vm, DPR:$Vn, pred:$p)>;
def: NEONInstAlias<"vacle${p}.f32 $Vd, $Vn, $Vm",
                   (VACGEq QPR:$Vd, QPR:$Vm, QPR:$Vn, pred:$p)>;

def: NEONInstAlias<"vaclt${p}.f32 $Vd, $Vm",
                   (VACGTd DPR:$Vd, DPR:$Vm, DPR:$Vd, pred:$p)>;
def: NEONInstAlias<"vaclt${p}.f32 $Vd, $Vm",
                   (VACGTq QPR:$Vd, QPR:$Vm, QPR:$Vd, pred:$p)>;
def: NEONInstAlias<"vacle${p}.f32 $Vd, $Vm",
                   (VACGEd DPR:$Vd, DPR:$Vm, DPR:$Vd, pred:$p)>;
def: NEONInstAlias<"vacle${p}.f32 $Vd, $Vm",
                   (VACGEq QPR:$Vd, QPR:$Vm, QPR:$Vd, pred:$p)>;

// Vector Bitwise Operations.

def vnotd : PatFrag<(ops node:$in),
                    (xor node:$in, (bitconvert (v8i8 NEONimmAllOnesV)))>;
def vnotq : PatFrag<(ops node:$in),
                    (xor node:$in, (bitconvert (v16i8 NEONimmAllOnesV)))>;


//   VAND     : Vector Bitwise AND
def  VANDd    : N3VDX<0, 0, 0b00, 0b0001, 1, IIC_VBINiD, "vand",
                      v2i32, v2i32, and, 1>;
def  VANDq    : N3VQX<0, 0, 0b00, 0b0001, 1, IIC_VBINiQ, "vand",
                      v4i32, v4i32, and, 1>;

//   VEOR     : Vector Bitwise Exclusive OR
def  VEORd    : N3VDX<1, 0, 0b00, 0b0001, 1, IIC_VBINiD, "veor",
                      v2i32, v2i32, xor, 1>;
def  VEORq    : N3VQX<1, 0, 0b00, 0b0001, 1, IIC_VBINiQ, "veor",
                      v4i32, v4i32, xor, 1>;

//   VORR     : Vector Bitwise OR
def  VORRd    : N3VDX<0, 0, 0b10, 0b0001, 1, IIC_VBINiD, "vorr",
                      v2i32, v2i32, or, 1>;
def  VORRq    : N3VQX<0, 0, 0b10, 0b0001, 1, IIC_VBINiQ, "vorr",
                      v4i32, v4i32, or, 1>;

def VORRiv4i16 : N1ModImm<1, 0b000, {1,0,?,1}, 0, 0, 0, 1,
                          (outs DPR:$Vd), (ins nImmSplatI16:$SIMM, DPR:$src),
                          IIC_VMOVImm,
                          "vorr", "i16", "$Vd, $SIMM", "$src = $Vd",
                          [(set DPR:$Vd,
                            (v4i16 (NEONvorrImm DPR:$src, timm:$SIMM)))]> {
  let Inst{9} = SIMM{9};
}

def VORRiv2i32 : N1ModImm<1, 0b000, {0,?,?,1}, 0, 0, 0, 1,
                          (outs DPR:$Vd), (ins nImmSplatI32:$SIMM, DPR:$src),
                          IIC_VMOVImm,
                          "vorr", "i32", "$Vd, $SIMM", "$src = $Vd",
                          [(set DPR:$Vd,
                            (v2i32 (NEONvorrImm DPR:$src, timm:$SIMM)))]> {
  let Inst{10-9} = SIMM{10-9};
}

def VORRiv8i16 : N1ModImm<1, 0b000, {1,0,?,1}, 0, 1, 0, 1,
                          (outs QPR:$Vd), (ins nImmSplatI16:$SIMM, QPR:$src),
                          IIC_VMOVImm,
                          "vorr", "i16", "$Vd, $SIMM", "$src = $Vd",
                          [(set QPR:$Vd,
                            (v8i16 (NEONvorrImm QPR:$src, timm:$SIMM)))]> {
  let Inst{9} = SIMM{9};
}

def VORRiv4i32 : N1ModImm<1, 0b000, {0,?,?,1}, 0, 1, 0, 1,
                          (outs QPR:$Vd), (ins nImmSplatI32:$SIMM, QPR:$src),
                          IIC_VMOVImm,
                          "vorr", "i32", "$Vd, $SIMM", "$src = $Vd",
                          [(set QPR:$Vd,
                            (v4i32 (NEONvorrImm QPR:$src, timm:$SIMM)))]> {
  let Inst{10-9} = SIMM{10-9};
}


//   VBIC     : Vector Bitwise Bit Clear (AND NOT)
let TwoOperandAliasConstraint = "$Vn = $Vd" in {
def  VBICd    : N3VX<0, 0, 0b01, 0b0001, 0, 1, (outs DPR:$Vd),
                     (ins DPR:$Vn, DPR:$Vm), N3RegFrm, IIC_VBINiD,
                     "vbic", "$Vd, $Vn, $Vm", "",
                     [(set DPR:$Vd, (v2i32 (and DPR:$Vn,
                                                 (vnotd DPR:$Vm))))]>;
def  VBICq    : N3VX<0, 0, 0b01, 0b0001, 1, 1, (outs QPR:$Vd),
                     (ins QPR:$Vn, QPR:$Vm), N3RegFrm, IIC_VBINiQ,
                     "vbic", "$Vd, $Vn, $Vm", "",
                     [(set QPR:$Vd, (v4i32 (and QPR:$Vn,
                                                 (vnotq QPR:$Vm))))]>;
}

def VBICiv4i16 : N1ModImm<1, 0b000, {1,0,?,1}, 0, 0, 1, 1,
                          (outs DPR:$Vd), (ins nImmSplatI16:$SIMM, DPR:$src),
                          IIC_VMOVImm,
                          "vbic", "i16", "$Vd, $SIMM", "$src = $Vd",
                          [(set DPR:$Vd,
                            (v4i16 (NEONvbicImm DPR:$src, timm:$SIMM)))]> {
  let Inst{9} = SIMM{9};
}

def VBICiv2i32 : N1ModImm<1, 0b000, {0,?,?,1}, 0, 0, 1, 1,
                          (outs DPR:$Vd), (ins nImmSplatI32:$SIMM, DPR:$src),
                          IIC_VMOVImm,
                          "vbic", "i32", "$Vd, $SIMM", "$src = $Vd",
                          [(set DPR:$Vd,
                            (v2i32 (NEONvbicImm DPR:$src, timm:$SIMM)))]> {
  let Inst{10-9} = SIMM{10-9};
}

def VBICiv8i16 : N1ModImm<1, 0b000, {1,0,?,1}, 0, 1, 1, 1,
                          (outs QPR:$Vd), (ins nImmSplatI16:$SIMM, QPR:$src),
                          IIC_VMOVImm,
                          "vbic", "i16", "$Vd, $SIMM", "$src = $Vd",
                          [(set QPR:$Vd,
                            (v8i16 (NEONvbicImm QPR:$src, timm:$SIMM)))]> {
  let Inst{9} = SIMM{9};
}

def VBICiv4i32 : N1ModImm<1, 0b000, {0,?,?,1}, 0, 1, 1, 1,
                          (outs QPR:$Vd), (ins nImmSplatI32:$SIMM, QPR:$src),
                          IIC_VMOVImm,
                          "vbic", "i32", "$Vd, $SIMM", "$src = $Vd",
                          [(set QPR:$Vd,
                            (v4i32 (NEONvbicImm QPR:$src, timm:$SIMM)))]> {
  let Inst{10-9} = SIMM{10-9};
}

//   VORN     : Vector Bitwise OR NOT
def  VORNd    : N3VX<0, 0, 0b11, 0b0001, 0, 1, (outs DPR:$Vd),
                     (ins DPR:$Vn, DPR:$Vm), N3RegFrm, IIC_VBINiD,
                     "vorn", "$Vd, $Vn, $Vm", "",
                     [(set DPR:$Vd, (v2i32 (or DPR:$Vn,
                                                (vnotd DPR:$Vm))))]>;
def  VORNq    : N3VX<0, 0, 0b11, 0b0001, 1, 1, (outs QPR:$Vd),
                     (ins QPR:$Vn, QPR:$Vm), N3RegFrm, IIC_VBINiQ,
                     "vorn", "$Vd, $Vn, $Vm", "",
                     [(set QPR:$Vd, (v4i32 (or QPR:$Vn,
                                                (vnotq QPR:$Vm))))]>;

//   VMVN     : Vector Bitwise NOT (Immediate)

let isReMaterializable = 1 in {

def VMVNv4i16 : N1ModImm<1, 0b000, {1,0,?,0}, 0, 0, 1, 1, (outs DPR:$Vd),
                         (ins nImmSplatI16:$SIMM), IIC_VMOVImm,
                         "vmvn", "i16", "$Vd, $SIMM", "",
                         [(set DPR:$Vd, (v4i16 (NEONvmvnImm timm:$SIMM)))]> {
  let Inst{9} = SIMM{9};
}

def VMVNv8i16 : N1ModImm<1, 0b000, {1,0,?,0}, 0, 1, 1, 1, (outs QPR:$Vd),
                         (ins nImmSplatI16:$SIMM), IIC_VMOVImm,
                         "vmvn", "i16", "$Vd, $SIMM", "",
                         [(set QPR:$Vd, (v8i16 (NEONvmvnImm timm:$SIMM)))]> {
  let Inst{9} = SIMM{9};
}

def VMVNv2i32 : N1ModImm<1, 0b000, {?,?,?,?}, 0, 0, 1, 1, (outs DPR:$Vd),
                         (ins nImmVMOVI32:$SIMM), IIC_VMOVImm,
                         "vmvn", "i32", "$Vd, $SIMM", "",
                         [(set DPR:$Vd, (v2i32 (NEONvmvnImm timm:$SIMM)))]> {
  let Inst{11-8} = SIMM{11-8};
}

def VMVNv4i32 : N1ModImm<1, 0b000, {?,?,?,?}, 0, 1, 1, 1, (outs QPR:$Vd),
                         (ins nImmVMOVI32:$SIMM), IIC_VMOVImm,
                         "vmvn", "i32", "$Vd, $SIMM", "",
                         [(set QPR:$Vd, (v4i32 (NEONvmvnImm timm:$SIMM)))]> {
  let Inst{11-8} = SIMM{11-8};
}
}

//   VMVN     : Vector Bitwise NOT
def  VMVNd    : N2VX<0b11, 0b11, 0b00, 0b00, 0b01011, 0, 0,
                     (outs DPR:$Vd), (ins DPR:$Vm), IIC_VSUBiD,
                     "vmvn", "$Vd, $Vm", "",
                     [(set DPR:$Vd, (v2i32 (vnotd DPR:$Vm)))]>;
def  VMVNq    : N2VX<0b11, 0b11, 0b00, 0b00, 0b01011, 1, 0,
                     (outs QPR:$Vd), (ins QPR:$Vm), IIC_VSUBiD,
                     "vmvn", "$Vd, $Vm", "",
                     [(set QPR:$Vd, (v4i32 (vnotq QPR:$Vm)))]>;
def : Pat<(v2i32 (vnotd DPR:$src)), (VMVNd DPR:$src)>;
def : Pat<(v4i32 (vnotq QPR:$src)), (VMVNq QPR:$src)>;

//   VBSL     : Vector Bitwise Select
def  VBSLd    : N3VX<1, 0, 0b01, 0b0001, 0, 1, (outs DPR:$Vd),
                     (ins DPR:$src1, DPR:$Vn, DPR:$Vm),
                     N3RegFrm, IIC_VCNTiD,
                     "vbsl", "$Vd, $Vn, $Vm", "$src1 = $Vd",
                     [(set DPR:$Vd,
                           (v2i32 (NEONvbsl DPR:$src1, DPR:$Vn, DPR:$Vm)))]>;
def : Pat<(v8i8 (int_arm_neon_vbsl (v8i8 DPR:$src1),
                                   (v8i8 DPR:$Vn), (v8i8 DPR:$Vm))),
          (VBSLd DPR:$src1, DPR:$Vn, DPR:$Vm)>,
        Requires<[HasNEON]>;
def : Pat<(v4i16 (int_arm_neon_vbsl (v4i16 DPR:$src1),
                                    (v4i16 DPR:$Vn), (v4i16 DPR:$Vm))),
          (VBSLd DPR:$src1, DPR:$Vn, DPR:$Vm)>,
        Requires<[HasNEON]>;
def : Pat<(v2i32 (int_arm_neon_vbsl (v2i32 DPR:$src1),
                                    (v2i32 DPR:$Vn), (v2i32 DPR:$Vm))),
          (VBSLd DPR:$src1, DPR:$Vn, DPR:$Vm)>,
        Requires<[HasNEON]>;
def : Pat<(v2f32 (int_arm_neon_vbsl (v2f32 DPR:$src1),
                                    (v2f32 DPR:$Vn), (v2f32 DPR:$Vm))),
          (VBSLd DPR:$src1, DPR:$Vn, DPR:$Vm)>,
        Requires<[HasNEON]>;
def : Pat<(v1i64 (int_arm_neon_vbsl (v1i64 DPR:$src1),
                                    (v1i64 DPR:$Vn), (v1i64 DPR:$Vm))),
          (VBSLd DPR:$src1, DPR:$Vn, DPR:$Vm)>,
        Requires<[HasNEON]>;

def : Pat<(v2i32 (or (and DPR:$Vn, DPR:$Vd),
                     (and DPR:$Vm, (vnotd DPR:$Vd)))),
          (VBSLd DPR:$Vd, DPR:$Vn, DPR:$Vm)>,
        Requires<[HasNEON]>;

def : Pat<(v1i64 (or (and DPR:$Vn, DPR:$Vd),
                     (and DPR:$Vm, (vnotd DPR:$Vd)))),
          (VBSLd DPR:$Vd, DPR:$Vn, DPR:$Vm)>,
        Requires<[HasNEON]>;

def  VBSLq    : N3VX<1, 0, 0b01, 0b0001, 1, 1, (outs QPR:$Vd),
                     (ins QPR:$src1, QPR:$Vn, QPR:$Vm),
                     N3RegFrm, IIC_VCNTiQ,
                     "vbsl", "$Vd, $Vn, $Vm", "$src1 = $Vd",
                     [(set QPR:$Vd,
                           (v4i32 (NEONvbsl QPR:$src1, QPR:$Vn, QPR:$Vm)))]>;

def : Pat<(v16i8 (int_arm_neon_vbsl (v16i8 QPR:$src1),
                                   (v16i8 QPR:$Vn), (v16i8 QPR:$Vm))),
          (VBSLq QPR:$src1, QPR:$Vn, QPR:$Vm)>,
        Requires<[HasNEON]>;
def : Pat<(v8i16 (int_arm_neon_vbsl (v8i16 QPR:$src1),
                                    (v8i16 QPR:$Vn), (v8i16 QPR:$Vm))),
          (VBSLq QPR:$src1, QPR:$Vn, QPR:$Vm)>,
        Requires<[HasNEON]>;
def : Pat<(v4i32 (int_arm_neon_vbsl (v4i32 QPR:$src1),
                                    (v4i32 QPR:$Vn), (v4i32 QPR:$Vm))),
          (VBSLq QPR:$src1, QPR:$Vn, QPR:$Vm)>,
        Requires<[HasNEON]>;
def : Pat<(v4f32 (int_arm_neon_vbsl (v4f32 QPR:$src1),
                                    (v4f32 QPR:$Vn), (v4f32 QPR:$Vm))),
          (VBSLq QPR:$src1, QPR:$Vn, QPR:$Vm)>,
        Requires<[HasNEON]>;
def : Pat<(v2i64 (int_arm_neon_vbsl (v2i64 QPR:$src1),
                                    (v2i64 QPR:$Vn), (v2i64 QPR:$Vm))),
          (VBSLq QPR:$src1, QPR:$Vn, QPR:$Vm)>,
        Requires<[HasNEON]>;

def : Pat<(v4i32 (or (and QPR:$Vn, QPR:$Vd),
                     (and QPR:$Vm, (vnotq QPR:$Vd)))),
          (VBSLq QPR:$Vd, QPR:$Vn, QPR:$Vm)>,
        Requires<[HasNEON]>;
def : Pat<(v2i64 (or (and QPR:$Vn, QPR:$Vd),
                     (and QPR:$Vm, (vnotq QPR:$Vd)))),
          (VBSLq QPR:$Vd, QPR:$Vn, QPR:$Vm)>,
        Requires<[HasNEON]>;

//   VBIF     : Vector Bitwise Insert if False
//              like VBSL but with: "vbif $dst, $src3, $src1", "$src2 = $dst",
// FIXME: This instruction's encoding MAY NOT BE correct.
def  VBIFd    : N3VX<1, 0, 0b11, 0b0001, 0, 1,
                     (outs DPR:$Vd), (ins DPR:$src1, DPR:$Vn, DPR:$Vm),
                     N3RegFrm, IIC_VBINiD,
                     "vbif", "$Vd, $Vn, $Vm", "$src1 = $Vd",
                     []>;
def  VBIFq    : N3VX<1, 0, 0b11, 0b0001, 1, 1,
                     (outs QPR:$Vd), (ins QPR:$src1, QPR:$Vn, QPR:$Vm),
                     N3RegFrm, IIC_VBINiQ,
                     "vbif", "$Vd, $Vn, $Vm", "$src1 = $Vd",
                     []>;

//   VBIT     : Vector Bitwise Insert if True
//              like VBSL but with: "vbit $dst, $src2, $src1", "$src3 = $dst",
// FIXME: This instruction's encoding MAY NOT BE correct.
def  VBITd    : N3VX<1, 0, 0b10, 0b0001, 0, 1,
                     (outs DPR:$Vd), (ins DPR:$src1, DPR:$Vn, DPR:$Vm),
                     N3RegFrm, IIC_VBINiD,
                     "vbit", "$Vd, $Vn, $Vm", "$src1 = $Vd",
                     []>;
def  VBITq    : N3VX<1, 0, 0b10, 0b0001, 1, 1,
                     (outs QPR:$Vd), (ins QPR:$src1, QPR:$Vn, QPR:$Vm),
                     N3RegFrm, IIC_VBINiQ,
                     "vbit", "$Vd, $Vn, $Vm", "$src1 = $Vd",
                     []>;

// VBIT/VBIF are not yet implemented.  The TwoAddress pass will not go looking
// for equivalent operations with different register constraints; it just
// inserts copies.

// Vector Absolute Differences.

//   VABD     : Vector Absolute Difference
defm VABDs    : N3VInt_QHS<0, 0, 0b0111, 0, N3RegFrm,
                           IIC_VSUBi4D, IIC_VSUBi4D, IIC_VSUBi4Q, IIC_VSUBi4Q,
                           "vabd", "s", int_arm_neon_vabds, 1>;
defm VABDu    : N3VInt_QHS<1, 0, 0b0111, 0, N3RegFrm,
                           IIC_VSUBi4D, IIC_VSUBi4D, IIC_VSUBi4Q, IIC_VSUBi4Q,
                           "vabd", "u", int_arm_neon_vabdu, 1>;
def  VABDfd   : N3VDInt<1, 0, 0b10, 0b1101, 0, N3RegFrm, IIC_VBIND,
                        "vabd", "f32", v2f32, v2f32, int_arm_neon_vabds, 1>;
def  VABDfq   : N3VQInt<1, 0, 0b10, 0b1101, 0, N3RegFrm, IIC_VBINQ,
                        "vabd", "f32", v4f32, v4f32, int_arm_neon_vabds, 1>;

//   VABDL    : Vector Absolute Difference Long (Q = | D - D |)
defm VABDLs   : N3VLIntExt_QHS<0,1,0b0111,0, IIC_VSUBi4Q,
                               "vabdl", "s", int_arm_neon_vabds, zext, 1>;
defm VABDLu   : N3VLIntExt_QHS<1,1,0b0111,0, IIC_VSUBi4Q,
                               "vabdl", "u", int_arm_neon_vabdu, zext, 1>;

//   VABA     : Vector Absolute Difference and Accumulate
defm VABAs    : N3VIntOp_QHS<0,0,0b0111,1, IIC_VABAD, IIC_VABAQ,
                             "vaba", "s", int_arm_neon_vabds, add>;
defm VABAu    : N3VIntOp_QHS<1,0,0b0111,1, IIC_VABAD, IIC_VABAQ,
                             "vaba", "u", int_arm_neon_vabdu, add>;

//   VABAL    : Vector Absolute Difference and Accumulate Long (Q += | D - D |)
defm VABALs   : N3VLIntExtOp_QHS<0,1,0b0101,0, IIC_VABAD,
                                 "vabal", "s", int_arm_neon_vabds, zext, add>;
defm VABALu   : N3VLIntExtOp_QHS<1,1,0b0101,0, IIC_VABAD,
                                 "vabal", "u", int_arm_neon_vabdu, zext, add>;

// Vector Maximum and Minimum.

//   VMAX     : Vector Maximum
defm VMAXs    : N3VInt_QHS<0, 0, 0b0110, 0, N3RegFrm,
                           IIC_VSUBi4D, IIC_VSUBi4D, IIC_VSUBi4Q, IIC_VSUBi4Q,
                           "vmax", "s", int_arm_neon_vmaxs, 1>;
defm VMAXu    : N3VInt_QHS<1, 0, 0b0110, 0, N3RegFrm,
                           IIC_VSUBi4D, IIC_VSUBi4D, IIC_VSUBi4Q, IIC_VSUBi4Q,
                           "vmax", "u", int_arm_neon_vmaxu, 1>;
def  VMAXfd   : N3VDInt<0, 0, 0b00, 0b1111, 0, N3RegFrm, IIC_VBIND,
                        "vmax", "f32",
                        v2f32, v2f32, int_arm_neon_vmaxs, 1>;
def  VMAXfq   : N3VQInt<0, 0, 0b00, 0b1111, 0, N3RegFrm, IIC_VBINQ,
                        "vmax", "f32",
                        v4f32, v4f32, int_arm_neon_vmaxs, 1>;

//   VMIN     : Vector Minimum
defm VMINs    : N3VInt_QHS<0, 0, 0b0110, 1, N3RegFrm,
                           IIC_VSUBi4D, IIC_VSUBi4D, IIC_VSUBi4Q, IIC_VSUBi4Q,
                           "vmin", "s", int_arm_neon_vmins, 1>;
defm VMINu    : N3VInt_QHS<1, 0, 0b0110, 1, N3RegFrm,
                           IIC_VSUBi4D, IIC_VSUBi4D, IIC_VSUBi4Q, IIC_VSUBi4Q,
                           "vmin", "u", int_arm_neon_vminu, 1>;
def  VMINfd   : N3VDInt<0, 0, 0b10, 0b1111, 0, N3RegFrm, IIC_VBIND,
                        "vmin", "f32",
                        v2f32, v2f32, int_arm_neon_vmins, 1>;
def  VMINfq   : N3VQInt<0, 0, 0b10, 0b1111, 0, N3RegFrm, IIC_VBINQ,
                        "vmin", "f32",
                        v4f32, v4f32, int_arm_neon_vmins, 1>;

// Vector Pairwise Operations.

//   VPADD    : Vector Pairwise Add
def  VPADDi8  : N3VDInt<0, 0, 0b00, 0b1011, 1, N3RegFrm, IIC_VSHLiD,
                        "vpadd", "i8",
                        v8i8, v8i8, int_arm_neon_vpadd, 0>;
def  VPADDi16 : N3VDInt<0, 0, 0b01, 0b1011, 1, N3RegFrm, IIC_VSHLiD,
                        "vpadd", "i16",
                        v4i16, v4i16, int_arm_neon_vpadd, 0>;
def  VPADDi32 : N3VDInt<0, 0, 0b10, 0b1011, 1, N3RegFrm, IIC_VSHLiD,
                        "vpadd", "i32",
                        v2i32, v2i32, int_arm_neon_vpadd, 0>;
def  VPADDf   : N3VDInt<1, 0, 0b00, 0b1101, 0, N3RegFrm,
                        IIC_VPBIND, "vpadd", "f32",
                        v2f32, v2f32, int_arm_neon_vpadd, 0>;

//   VPADDL   : Vector Pairwise Add Long
defm VPADDLs  : N2VPLInt_QHS<0b11, 0b11, 0b00, 0b00100, 0, "vpaddl", "s",
                             int_arm_neon_vpaddls>;
defm VPADDLu  : N2VPLInt_QHS<0b11, 0b11, 0b00, 0b00101, 0, "vpaddl", "u",
                             int_arm_neon_vpaddlu>;

//   VPADAL   : Vector Pairwise Add and Accumulate Long
defm VPADALs  : N2VPLInt2_QHS<0b11, 0b11, 0b00, 0b01100, 0, "vpadal", "s",
                              int_arm_neon_vpadals>;
defm VPADALu  : N2VPLInt2_QHS<0b11, 0b11, 0b00, 0b01101, 0, "vpadal", "u",
                              int_arm_neon_vpadalu>;

//   VPMAX    : Vector Pairwise Maximum
def  VPMAXs8  : N3VDInt<0, 0, 0b00, 0b1010, 0, N3RegFrm, IIC_VSUBi4D, "vpmax",
                        "s8", v8i8, v8i8, int_arm_neon_vpmaxs, 0>;
def  VPMAXs16 : N3VDInt<0, 0, 0b01, 0b1010, 0, N3RegFrm, IIC_VSUBi4D, "vpmax",
                        "s16", v4i16, v4i16, int_arm_neon_vpmaxs, 0>;
def  VPMAXs32 : N3VDInt<0, 0, 0b10, 0b1010, 0, N3RegFrm, IIC_VSUBi4D, "vpmax",
                        "s32", v2i32, v2i32, int_arm_neon_vpmaxs, 0>;
def  VPMAXu8  : N3VDInt<1, 0, 0b00, 0b1010, 0, N3RegFrm, IIC_VSUBi4D, "vpmax",
                        "u8", v8i8, v8i8, int_arm_neon_vpmaxu, 0>;
def  VPMAXu16 : N3VDInt<1, 0, 0b01, 0b1010, 0, N3RegFrm, IIC_VSUBi4D, "vpmax",
                        "u16", v4i16, v4i16, int_arm_neon_vpmaxu, 0>;
def  VPMAXu32 : N3VDInt<1, 0, 0b10, 0b1010, 0, N3RegFrm, IIC_VSUBi4D, "vpmax",
                        "u32", v2i32, v2i32, int_arm_neon_vpmaxu, 0>;
def  VPMAXf   : N3VDInt<1, 0, 0b00, 0b1111, 0, N3RegFrm, IIC_VPBIND, "vpmax",
                        "f32", v2f32, v2f32, int_arm_neon_vpmaxs, 0>;

//   VPMIN    : Vector Pairwise Minimum
def  VPMINs8  : N3VDInt<0, 0, 0b00, 0b1010, 1, N3RegFrm, IIC_VSUBi4D, "vpmin",
                        "s8", v8i8, v8i8, int_arm_neon_vpmins, 0>;
def  VPMINs16 : N3VDInt<0, 0, 0b01, 0b1010, 1, N3RegFrm, IIC_VSUBi4D, "vpmin",
                        "s16", v4i16, v4i16, int_arm_neon_vpmins, 0>;
def  VPMINs32 : N3VDInt<0, 0, 0b10, 0b1010, 1, N3RegFrm, IIC_VSUBi4D, "vpmin",
                        "s32", v2i32, v2i32, int_arm_neon_vpmins, 0>;
def  VPMINu8  : N3VDInt<1, 0, 0b00, 0b1010, 1, N3RegFrm, IIC_VSUBi4D, "vpmin",
                        "u8", v8i8, v8i8, int_arm_neon_vpminu, 0>;
def  VPMINu16 : N3VDInt<1, 0, 0b01, 0b1010, 1, N3RegFrm, IIC_VSUBi4D, "vpmin",
                        "u16", v4i16, v4i16, int_arm_neon_vpminu, 0>;
def  VPMINu32 : N3VDInt<1, 0, 0b10, 0b1010, 1, N3RegFrm, IIC_VSUBi4D, "vpmin",
                        "u32", v2i32, v2i32, int_arm_neon_vpminu, 0>;
def  VPMINf   : N3VDInt<1, 0, 0b10, 0b1111, 0, N3RegFrm, IIC_VPBIND, "vpmin",
                        "f32", v2f32, v2f32, int_arm_neon_vpmins, 0>;

// Vector Reciprocal and Reciprocal Square Root Estimate and Step.

//   VRECPE   : Vector Reciprocal Estimate
def  VRECPEd  : N2VDInt<0b11, 0b11, 0b10, 0b11, 0b01000, 0,
                        IIC_VUNAD, "vrecpe", "u32",
                        v2i32, v2i32, int_arm_neon_vrecpe>;
def  VRECPEq  : N2VQInt<0b11, 0b11, 0b10, 0b11, 0b01000, 0,
                        IIC_VUNAQ, "vrecpe", "u32",
                        v4i32, v4i32, int_arm_neon_vrecpe>;
def  VRECPEfd : N2VDInt<0b11, 0b11, 0b10, 0b11, 0b01010, 0,
                        IIC_VUNAD, "vrecpe", "f32",
                        v2f32, v2f32, int_arm_neon_vrecpe>;
def  VRECPEfq : N2VQInt<0b11, 0b11, 0b10, 0b11, 0b01010, 0,
                        IIC_VUNAQ, "vrecpe", "f32",
                        v4f32, v4f32, int_arm_neon_vrecpe>;

//   VRECPS   : Vector Reciprocal Step
def  VRECPSfd : N3VDInt<0, 0, 0b00, 0b1111, 1, N3RegFrm,
                        IIC_VRECSD, "vrecps", "f32",
                        v2f32, v2f32, int_arm_neon_vrecps, 1>;
def  VRECPSfq : N3VQInt<0, 0, 0b00, 0b1111, 1, N3RegFrm,
                        IIC_VRECSQ, "vrecps", "f32",
                        v4f32, v4f32, int_arm_neon_vrecps, 1>;

//   VRSQRTE  : Vector Reciprocal Square Root Estimate
def  VRSQRTEd  : N2VDInt<0b11, 0b11, 0b10, 0b11, 0b01001, 0,
                         IIC_VUNAD, "vrsqrte", "u32",
                         v2i32, v2i32, int_arm_neon_vrsqrte>;
def  VRSQRTEq  : N2VQInt<0b11, 0b11, 0b10, 0b11, 0b01001, 0,
                         IIC_VUNAQ, "vrsqrte", "u32",
                         v4i32, v4i32, int_arm_neon_vrsqrte>;
def  VRSQRTEfd : N2VDInt<0b11, 0b11, 0b10, 0b11, 0b01011, 0,
                         IIC_VUNAD, "vrsqrte", "f32",
                         v2f32, v2f32, int_arm_neon_vrsqrte>;
def  VRSQRTEfq : N2VQInt<0b11, 0b11, 0b10, 0b11, 0b01011, 0,
                         IIC_VUNAQ, "vrsqrte", "f32",
                         v4f32, v4f32, int_arm_neon_vrsqrte>;

//   VRSQRTS  : Vector Reciprocal Square Root Step
def VRSQRTSfd : N3VDInt<0, 0, 0b10, 0b1111, 1, N3RegFrm,
                        IIC_VRECSD, "vrsqrts", "f32",
                        v2f32, v2f32, int_arm_neon_vrsqrts, 1>;
def VRSQRTSfq : N3VQInt<0, 0, 0b10, 0b1111, 1, N3RegFrm,
                        IIC_VRECSQ, "vrsqrts", "f32",
                        v4f32, v4f32, int_arm_neon_vrsqrts, 1>;

// Vector Shifts.

//   VSHL     : Vector Shift
defm VSHLs    : N3VInt_QHSDSh<0, 0, 0b0100, 0, N3RegVShFrm,
                            IIC_VSHLiD, IIC_VSHLiD, IIC_VSHLiQ, IIC_VSHLiQ,
                            "vshl", "s", int_arm_neon_vshifts>;
defm VSHLu    : N3VInt_QHSDSh<1, 0, 0b0100, 0, N3RegVShFrm,
                            IIC_VSHLiD, IIC_VSHLiD, IIC_VSHLiQ, IIC_VSHLiQ,
                            "vshl", "u", int_arm_neon_vshiftu>;

//   VSHL     : Vector Shift Left (Immediate)
defm VSHLi    : N2VShL_QHSD<0, 1, 0b0101, 1, IIC_VSHLiD, "vshl", "i", NEONvshl>;

//   VSHR     : Vector Shift Right (Immediate)
defm VSHRs    : N2VShR_QHSD<0, 1, 0b0000, 1, IIC_VSHLiD, "vshr", "s", "VSHRs",
                            NEONvshrs>;
defm VSHRu    : N2VShR_QHSD<1, 1, 0b0000, 1, IIC_VSHLiD, "vshr", "u", "VSHRu",
                            NEONvshru>;

//   VSHLL    : Vector Shift Left Long
defm VSHLLs   : N2VLSh_QHS<0, 1, 0b1010, 0, 0, 1, "vshll", "s", NEONvshlls>;
defm VSHLLu   : N2VLSh_QHS<1, 1, 0b1010, 0, 0, 1, "vshll", "u", NEONvshllu>;

//   VSHLL    : Vector Shift Left Long (with maximum shift count)
class N2VLShMax<bit op24, bit op23, bits<6> op21_16, bits<4> op11_8, bit op7,
                bit op6, bit op4, string OpcodeStr, string Dt, ValueType ResTy,
                ValueType OpTy, Operand ImmTy, SDNode OpNode>
  : N2VLSh<op24, op23, op11_8, op7, op6, op4, OpcodeStr, Dt,
           ResTy, OpTy, ImmTy, OpNode> {
  let Inst{21-16} = op21_16;
  let DecoderMethod = "DecodeVSHLMaxInstruction";
}
def  VSHLLi8  : N2VLShMax<1, 1, 0b110010, 0b0011, 0, 0, 0, "vshll", "i8",
                          v8i16, v8i8, imm8, NEONvshlli>;
def  VSHLLi16 : N2VLShMax<1, 1, 0b110110, 0b0011, 0, 0, 0, "vshll", "i16",
                          v4i32, v4i16, imm16, NEONvshlli>;
def  VSHLLi32 : N2VLShMax<1, 1, 0b111010, 0b0011, 0, 0, 0, "vshll", "i32",
                          v2i64, v2i32, imm32, NEONvshlli>;

//   VSHRN    : Vector Shift Right and Narrow
defm VSHRN    : N2VNSh_HSD<0,1,0b1000,0,0,1, IIC_VSHLiD, "vshrn", "i",
                           NEONvshrn>;

//   VRSHL    : Vector Rounding Shift
defm VRSHLs   : N3VInt_QHSDSh<0, 0, 0b0101, 0, N3RegVShFrm,
                            IIC_VSHLi4D, IIC_VSHLi4D, IIC_VSHLi4Q, IIC_VSHLi4Q,
                            "vrshl", "s", int_arm_neon_vrshifts>;
defm VRSHLu   : N3VInt_QHSDSh<1, 0, 0b0101, 0, N3RegVShFrm,
                            IIC_VSHLi4D, IIC_VSHLi4D, IIC_VSHLi4Q, IIC_VSHLi4Q,
                            "vrshl", "u", int_arm_neon_vrshiftu>;
//   VRSHR    : Vector Rounding Shift Right
defm VRSHRs   : N2VShR_QHSD<0,1,0b0010,1, IIC_VSHLi4D, "vrshr", "s", "VRSHRs",
                            NEONvrshrs>;
defm VRSHRu   : N2VShR_QHSD<1,1,0b0010,1, IIC_VSHLi4D, "vrshr", "u", "VRSHRu",
                            NEONvrshru>;

//   VRSHRN   : Vector Rounding Shift Right and Narrow
defm VRSHRN   : N2VNSh_HSD<0, 1, 0b1000, 0, 1, 1, IIC_VSHLi4D, "vrshrn", "i",
                           NEONvrshrn>;

//   VQSHL    : Vector Saturating Shift
defm VQSHLs   : N3VInt_QHSDSh<0, 0, 0b0100, 1, N3RegVShFrm,
                            IIC_VSHLi4D, IIC_VSHLi4D, IIC_VSHLi4Q, IIC_VSHLi4Q,
                            "vqshl", "s", int_arm_neon_vqshifts>;
defm VQSHLu   : N3VInt_QHSDSh<1, 0, 0b0100, 1, N3RegVShFrm,
                            IIC_VSHLi4D, IIC_VSHLi4D, IIC_VSHLi4Q, IIC_VSHLi4Q,
                            "vqshl", "u", int_arm_neon_vqshiftu>;
//   VQSHL    : Vector Saturating Shift Left (Immediate)
defm VQSHLsi  : N2VShL_QHSD<0,1,0b0111,1, IIC_VSHLi4D, "vqshl", "s",NEONvqshls>;
defm VQSHLui  : N2VShL_QHSD<1,1,0b0111,1, IIC_VSHLi4D, "vqshl", "u",NEONvqshlu>;

//   VQSHLU   : Vector Saturating Shift Left (Immediate, Unsigned)
defm VQSHLsu  : N2VShL_QHSD<1,1,0b0110,1, IIC_VSHLi4D,"vqshlu","s",NEONvqshlsu>;

//   VQSHRN   : Vector Saturating Shift Right and Narrow
defm VQSHRNs  : N2VNSh_HSD<0, 1, 0b1001, 0, 0, 1, IIC_VSHLi4D, "vqshrn", "s",
                           NEONvqshrns>;
defm VQSHRNu  : N2VNSh_HSD<1, 1, 0b1001, 0, 0, 1, IIC_VSHLi4D, "vqshrn", "u",
                           NEONvqshrnu>;

//   VQSHRUN  : Vector Saturating Shift Right and Narrow (Unsigned)
defm VQSHRUN  : N2VNSh_HSD<1, 1, 0b1000, 0, 0, 1, IIC_VSHLi4D, "vqshrun", "s",
                           NEONvqshrnsu>;

//   VQRSHL   : Vector Saturating Rounding Shift
defm VQRSHLs  : N3VInt_QHSDSh<0, 0, 0b0101, 1, N3RegVShFrm,
                            IIC_VSHLi4D, IIC_VSHLi4D, IIC_VSHLi4Q, IIC_VSHLi4Q,
                            "vqrshl", "s", int_arm_neon_vqrshifts>;
defm VQRSHLu  : N3VInt_QHSDSh<1, 0, 0b0101, 1, N3RegVShFrm,
                            IIC_VSHLi4D, IIC_VSHLi4D, IIC_VSHLi4Q, IIC_VSHLi4Q,
                            "vqrshl", "u", int_arm_neon_vqrshiftu>;

//   VQRSHRN  : Vector Saturating Rounding Shift Right and Narrow
defm VQRSHRNs : N2VNSh_HSD<0, 1, 0b1001, 0, 1, 1, IIC_VSHLi4D, "vqrshrn", "s",
                           NEONvqrshrns>;
defm VQRSHRNu : N2VNSh_HSD<1, 1, 0b1001, 0, 1, 1, IIC_VSHLi4D, "vqrshrn", "u",
                           NEONvqrshrnu>;

//   VQRSHRUN : Vector Saturating Rounding Shift Right and Narrow (Unsigned)
defm VQRSHRUN : N2VNSh_HSD<1, 1, 0b1000, 0, 1, 1, IIC_VSHLi4D, "vqrshrun", "s",
                           NEONvqrshrnsu>;

//   VSRA     : Vector Shift Right and Accumulate
defm VSRAs    : N2VShAdd_QHSD<0, 1, 0b0001, 1, "vsra", "s", NEONvshrs>;
defm VSRAu    : N2VShAdd_QHSD<1, 1, 0b0001, 1, "vsra", "u", NEONvshru>;
//   VRSRA    : Vector Rounding Shift Right and Accumulate
defm VRSRAs   : N2VShAdd_QHSD<0, 1, 0b0011, 1, "vrsra", "s", NEONvrshrs>;
defm VRSRAu   : N2VShAdd_QHSD<1, 1, 0b0011, 1, "vrsra", "u", NEONvrshru>;

//   VSLI     : Vector Shift Left and Insert
defm VSLI     : N2VShInsL_QHSD<1, 1, 0b0101, 1, "vsli">;

//   VSRI     : Vector Shift Right and Insert
defm VSRI     : N2VShInsR_QHSD<1, 1, 0b0100, 1, "vsri">;

// Vector Absolute and Saturating Absolute.

//   VABS     : Vector Absolute Value
defm VABS     : N2VInt_QHS<0b11, 0b11, 0b01, 0b00110, 0,
                           IIC_VUNAiD, IIC_VUNAiQ, "vabs", "s",
                           int_arm_neon_vabs>;
def  VABSfd   : N2VD<0b11, 0b11, 0b10, 0b01, 0b01110, 0,
                     "vabs", "f32",
                     v2f32, v2f32, fabs>;
def  VABSfq   : N2VQ<0b11, 0b11, 0b10, 0b01, 0b01110, 0,
                     "vabs", "f32",
                      v4f32, v4f32, fabs>;

def : Pat<(xor (v2i32 (bitconvert (v8i8 (NEONvshrs DPR:$src, (i32 7))))),
               (v2i32 (bitconvert (v8i8 (add DPR:$src,
                                             (NEONvshrs DPR:$src, (i32 7))))))),
          (VABSv8i8 DPR:$src)>;
def : Pat<(xor (v2i32 (bitconvert (v4i16 (NEONvshrs DPR:$src, (i32 15))))),
               (v2i32 (bitconvert (v4i16 (add DPR:$src,
                                            (NEONvshrs DPR:$src, (i32 15))))))),
          (VABSv4i16 DPR:$src)>;
def : Pat<(xor (v2i32 (NEONvshrs DPR:$src, (i32 31))),
               (v2i32 (add DPR:$src, (NEONvshrs DPR:$src, (i32 31))))),
          (VABSv2i32 DPR:$src)>;
def : Pat<(xor (v4i32 (bitconvert (v16i8 (NEONvshrs QPR:$src, (i32 7))))),
               (v4i32 (bitconvert (v16i8 (add QPR:$src,
                                             (NEONvshrs QPR:$src, (i32 7))))))),
          (VABSv16i8 QPR:$src)>;
def : Pat<(xor (v4i32 (bitconvert (v8i16 (NEONvshrs QPR:$src, (i32 15))))),
               (v4i32 (bitconvert (v8i16 (add QPR:$src,
                                            (NEONvshrs QPR:$src, (i32 15))))))),
          (VABSv8i16 QPR:$src)>;
def : Pat<(xor (v4i32 (NEONvshrs QPR:$src, (i32 31))),
               (v4i32 (add QPR:$src, (NEONvshrs QPR:$src, (i32 31))))),
          (VABSv4i32 QPR:$src)>;

def : Pat<(v2f32 (int_arm_neon_vabs (v2f32 DPR:$src))), (VABSfd DPR:$src)>;
def : Pat<(v4f32 (int_arm_neon_vabs (v4f32 QPR:$src))), (VABSfq QPR:$src)>;

//   VQABS    : Vector Saturating Absolute Value
defm VQABS    : N2VInt_QHS<0b11, 0b11, 0b00, 0b01110, 0,
                           IIC_VQUNAiD, IIC_VQUNAiQ, "vqabs", "s",
                           int_arm_neon_vqabs>;

// Vector Negate.

def vnegd  : PatFrag<(ops node:$in),
                     (sub (bitconvert (v2i32 NEONimmAllZerosV)), node:$in)>;
def vnegq  : PatFrag<(ops node:$in),
                     (sub (bitconvert (v4i32 NEONimmAllZerosV)), node:$in)>;

class VNEGD<bits<2> size, string OpcodeStr, string Dt, ValueType Ty>
  : N2V<0b11, 0b11, size, 0b01, 0b00111, 0, 0, (outs DPR:$Vd), (ins DPR:$Vm),
        IIC_VSHLiD, OpcodeStr, Dt, "$Vd, $Vm", "",
        [(set DPR:$Vd, (Ty (vnegd DPR:$Vm)))]>;
class VNEGQ<bits<2> size, string OpcodeStr, string Dt, ValueType Ty>
  : N2V<0b11, 0b11, size, 0b01, 0b00111, 1, 0, (outs QPR:$Vd), (ins QPR:$Vm),
        IIC_VSHLiQ, OpcodeStr, Dt, "$Vd, $Vm", "",
        [(set QPR:$Vd, (Ty (vnegq QPR:$Vm)))]>;

//   VNEG     : Vector Negate (integer)
def  VNEGs8d  : VNEGD<0b00, "vneg", "s8", v8i8>;
def  VNEGs16d : VNEGD<0b01, "vneg", "s16", v4i16>;
def  VNEGs32d : VNEGD<0b10, "vneg", "s32", v2i32>;
def  VNEGs8q  : VNEGQ<0b00, "vneg", "s8", v16i8>;
def  VNEGs16q : VNEGQ<0b01, "vneg", "s16", v8i16>;
def  VNEGs32q : VNEGQ<0b10, "vneg", "s32", v4i32>;

//   VNEG     : Vector Negate (floating-point)
def  VNEGfd   : N2V<0b11, 0b11, 0b10, 0b01, 0b01111, 0, 0,
                    (outs DPR:$Vd), (ins DPR:$Vm), IIC_VUNAD,
                    "vneg", "f32", "$Vd, $Vm", "",
                    [(set DPR:$Vd, (v2f32 (fneg DPR:$Vm)))]>;
def  VNEGf32q : N2V<0b11, 0b11, 0b10, 0b01, 0b01111, 1, 0,
                    (outs QPR:$Vd), (ins QPR:$Vm), IIC_VUNAQ,
                    "vneg", "f32", "$Vd, $Vm", "",
                    [(set QPR:$Vd, (v4f32 (fneg QPR:$Vm)))]>;

def : Pat<(v8i8  (vnegd  DPR:$src)), (VNEGs8d DPR:$src)>;
def : Pat<(v4i16 (vnegd  DPR:$src)), (VNEGs16d DPR:$src)>;
def : Pat<(v2i32 (vnegd  DPR:$src)), (VNEGs32d DPR:$src)>;
def : Pat<(v16i8 (vnegq QPR:$src)), (VNEGs8q QPR:$src)>;
def : Pat<(v8i16 (vnegq QPR:$src)), (VNEGs16q QPR:$src)>;
def : Pat<(v4i32 (vnegq QPR:$src)), (VNEGs32q QPR:$src)>;

//   VQNEG    : Vector Saturating Negate
defm VQNEG    : N2VInt_QHS<0b11, 0b11, 0b00, 0b01111, 0,
                           IIC_VQUNAiD, IIC_VQUNAiQ, "vqneg", "s",
                           int_arm_neon_vqneg>;

// Vector Bit Counting Operations.

//   VCLS     : Vector Count Leading Sign Bits
defm VCLS     : N2VInt_QHS<0b11, 0b11, 0b00, 0b01000, 0,
                           IIC_VCNTiD, IIC_VCNTiQ, "vcls", "s",
                           int_arm_neon_vcls>;
//   VCLZ     : Vector Count Leading Zeros
defm VCLZ     : N2VInt_QHS<0b11, 0b11, 0b00, 0b01001, 0,
                           IIC_VCNTiD, IIC_VCNTiQ, "vclz", "i",
                           ctlz>;
//   VCNT     : Vector Count One Bits
def  VCNTd    : N2VDInt<0b11, 0b11, 0b00, 0b00, 0b01010, 0,
                        IIC_VCNTiD, "vcnt", "8",
                        v8i8, v8i8, ctpop>;
def  VCNTq    : N2VQInt<0b11, 0b11, 0b00, 0b00, 0b01010, 0,
                        IIC_VCNTiQ, "vcnt", "8",
                        v16i8, v16i8, ctpop>;

// Vector Swap
def  VSWPd    : N2VX<0b11, 0b11, 0b00, 0b10, 0b00000, 0, 0,
                     (outs DPR:$Vd, DPR:$Vm), (ins DPR:$in1, DPR:$in2),
                     NoItinerary, "vswp", "$Vd, $Vm", "$in1 = $Vd, $in2 = $Vm",
                     []>;
def  VSWPq    : N2VX<0b11, 0b11, 0b00, 0b10, 0b00000, 1, 0,
                     (outs QPR:$Vd, QPR:$Vm), (ins QPR:$in1, QPR:$in2),
                     NoItinerary, "vswp", "$Vd, $Vm", "$in1 = $Vd, $in2 = $Vm",
                     []>;

// Vector Move Operations.

//   VMOV     : Vector Move (Register)
def : InstAlias<"vmov${p} $Vd, $Vm",
                (VORRd DPR:$Vd, DPR:$Vm, DPR:$Vm, pred:$p)>;
def : InstAlias<"vmov${p} $Vd, $Vm",
                (VORRq QPR:$Vd, QPR:$Vm, QPR:$Vm, pred:$p)>;

//   VMOV     : Vector Move (Immediate)

let isReMaterializable = 1 in {
def VMOVv8i8  : N1ModImm<1, 0b000, 0b1110, 0, 0, 0, 1, (outs DPR:$Vd),
                         (ins nImmSplatI8:$SIMM), IIC_VMOVImm,
                         "vmov", "i8", "$Vd, $SIMM", "",
                         [(set DPR:$Vd, (v8i8 (NEONvmovImm timm:$SIMM)))]>;
def VMOVv16i8 : N1ModImm<1, 0b000, 0b1110, 0, 1, 0, 1, (outs QPR:$Vd),
                         (ins nImmSplatI8:$SIMM), IIC_VMOVImm,
                         "vmov", "i8", "$Vd, $SIMM", "",
                         [(set QPR:$Vd, (v16i8 (NEONvmovImm timm:$SIMM)))]>;

def VMOVv4i16 : N1ModImm<1, 0b000, {1,0,?,0}, 0, 0, 0, 1, (outs DPR:$Vd),
                         (ins nImmSplatI16:$SIMM), IIC_VMOVImm,
                         "vmov", "i16", "$Vd, $SIMM", "",
                         [(set DPR:$Vd, (v4i16 (NEONvmovImm timm:$SIMM)))]> {
  let Inst{9} = SIMM{9};
}

def VMOVv8i16 : N1ModImm<1, 0b000, {1,0,?,0}, 0, 1, 0, 1, (outs QPR:$Vd),
                         (ins nImmSplatI16:$SIMM), IIC_VMOVImm,
                         "vmov", "i16", "$Vd, $SIMM", "",
                         [(set QPR:$Vd, (v8i16 (NEONvmovImm timm:$SIMM)))]> {
 let Inst{9} = SIMM{9};
}

def VMOVv2i32 : N1ModImm<1, 0b000, {?,?,?,?}, 0, 0, 0, 1, (outs DPR:$Vd),
                         (ins nImmVMOVI32:$SIMM), IIC_VMOVImm,
                         "vmov", "i32", "$Vd, $SIMM", "",
                         [(set DPR:$Vd, (v2i32 (NEONvmovImm timm:$SIMM)))]> {
  let Inst{11-8} = SIMM{11-8};
}

def VMOVv4i32 : N1ModImm<1, 0b000, {?,?,?,?}, 0, 1, 0, 1, (outs QPR:$Vd),
                         (ins nImmVMOVI32:$SIMM), IIC_VMOVImm,
                         "vmov", "i32", "$Vd, $SIMM", "",
                         [(set QPR:$Vd, (v4i32 (NEONvmovImm timm:$SIMM)))]> {
  let Inst{11-8} = SIMM{11-8};
}

def VMOVv1i64 : N1ModImm<1, 0b000, 0b1110, 0, 0, 1, 1, (outs DPR:$Vd),
                         (ins nImmSplatI64:$SIMM), IIC_VMOVImm,
                         "vmov", "i64", "$Vd, $SIMM", "",
                         [(set DPR:$Vd, (v1i64 (NEONvmovImm timm:$SIMM)))]>;
def VMOVv2i64 : N1ModImm<1, 0b000, 0b1110, 0, 1, 1, 1, (outs QPR:$Vd),
                         (ins nImmSplatI64:$SIMM), IIC_VMOVImm,
                         "vmov", "i64", "$Vd, $SIMM", "",
                         [(set QPR:$Vd, (v2i64 (NEONvmovImm timm:$SIMM)))]>;

def VMOVv2f32 : N1ModImm<1, 0b000, 0b1111, 0, 0, 0, 1, (outs DPR:$Vd),
                         (ins nImmVMOVF32:$SIMM), IIC_VMOVImm,
                         "vmov", "f32", "$Vd, $SIMM", "",
                         [(set DPR:$Vd, (v2f32 (NEONvmovFPImm timm:$SIMM)))]>;
def VMOVv4f32 : N1ModImm<1, 0b000, 0b1111, 0, 1, 0, 1, (outs QPR:$Vd),
                         (ins nImmVMOVF32:$SIMM), IIC_VMOVImm,
                         "vmov", "f32", "$Vd, $SIMM", "",
                         [(set QPR:$Vd, (v4f32 (NEONvmovFPImm timm:$SIMM)))]>;
} // isReMaterializable

//   VMOV     : Vector Get Lane (move scalar to ARM core register)

def VGETLNs8  : NVGetLane<{1,1,1,0,0,1,?,1}, 0b1011, {?,?},
                          (outs GPR:$R), (ins DPR:$V, VectorIndex8:$lane),
                          IIC_VMOVSI, "vmov", "s8", "$R, $V$lane",
                          [(set GPR:$R, (NEONvgetlanes (v8i8 DPR:$V),
                                           imm:$lane))]> {
  let Inst{21}  = lane{2};
  let Inst{6-5} = lane{1-0};
}
def VGETLNs16 : NVGetLane<{1,1,1,0,0,0,?,1}, 0b1011, {?,1},
                          (outs GPR:$R), (ins DPR:$V, VectorIndex16:$lane),
                          IIC_VMOVSI, "vmov", "s16", "$R, $V$lane",
                          [(set GPR:$R, (NEONvgetlanes (v4i16 DPR:$V),
                                           imm:$lane))]> {
  let Inst{21} = lane{1};
  let Inst{6}  = lane{0};
}
def VGETLNu8  : NVGetLane<{1,1,1,0,1,1,?,1}, 0b1011, {?,?},
                          (outs GPR:$R), (ins DPR:$V, VectorIndex8:$lane),
                          IIC_VMOVSI, "vmov", "u8", "$R, $V$lane",
                          [(set GPR:$R, (NEONvgetlaneu (v8i8 DPR:$V),
                                           imm:$lane))]> {
  let Inst{21}  = lane{2};
  let Inst{6-5} = lane{1-0};
}
def VGETLNu16 : NVGetLane<{1,1,1,0,1,0,?,1}, 0b1011, {?,1},
                          (outs GPR:$R), (ins DPR:$V, VectorIndex16:$lane),
                          IIC_VMOVSI, "vmov", "u16", "$R, $V$lane",
                          [(set GPR:$R, (NEONvgetlaneu (v4i16 DPR:$V),
                                           imm:$lane))]> {
  let Inst{21} = lane{1};
  let Inst{6}  = lane{0};
}
def VGETLNi32 : NVGetLane<{1,1,1,0,0,0,?,1}, 0b1011, 0b00,
                          (outs GPR:$R), (ins DPR:$V, VectorIndex32:$lane),
                          IIC_VMOVSI, "vmov", "32", "$R, $V$lane",
                          [(set GPR:$R, (extractelt (v2i32 DPR:$V),
                                           imm:$lane))]>,
                Requires<[HasNEON, HasFastVGETLNi32]> {
  let Inst{21} = lane{0};
}
// def VGETLNf32: see FMRDH and FMRDL in ARMInstrVFP.td
def : Pat<(NEONvgetlanes (v16i8 QPR:$src), imm:$lane),
          (VGETLNs8 (v8i8 (EXTRACT_SUBREG QPR:$src,
                           (DSubReg_i8_reg imm:$lane))),
                     (SubReg_i8_lane imm:$lane))>;
def : Pat<(NEONvgetlanes (v8i16 QPR:$src), imm:$lane),
          (VGETLNs16 (v4i16 (EXTRACT_SUBREG QPR:$src,
                             (DSubReg_i16_reg imm:$lane))),
                     (SubReg_i16_lane imm:$lane))>;
def : Pat<(NEONvgetlaneu (v16i8 QPR:$src), imm:$lane),
          (VGETLNu8 (v8i8 (EXTRACT_SUBREG QPR:$src,
                           (DSubReg_i8_reg imm:$lane))),
                     (SubReg_i8_lane imm:$lane))>;
def : Pat<(NEONvgetlaneu (v8i16 QPR:$src), imm:$lane),
          (VGETLNu16 (v4i16 (EXTRACT_SUBREG QPR:$src,
                             (DSubReg_i16_reg imm:$lane))),
                     (SubReg_i16_lane imm:$lane))>;
def : Pat<(extractelt (v4i32 QPR:$src), imm:$lane),
          (VGETLNi32 (v2i32 (EXTRACT_SUBREG QPR:$src,
                             (DSubReg_i32_reg imm:$lane))),
                     (SubReg_i32_lane imm:$lane))>,
      Requires<[HasNEON, HasFastVGETLNi32]>;
def : Pat<(extractelt (v2i32 DPR:$src), imm:$lane),
          (COPY_TO_REGCLASS
            (i32 (EXTRACT_SUBREG DPR:$src, (SSubReg_f32_reg imm:$lane))), GPR)>,
      Requires<[HasNEON, HasSlowVGETLNi32]>;
def : Pat<(extractelt (v4i32 QPR:$src), imm:$lane),
          (COPY_TO_REGCLASS
            (i32 (EXTRACT_SUBREG QPR:$src, (SSubReg_f32_reg imm:$lane))), GPR)>,
      Requires<[HasNEON, HasSlowVGETLNi32]>;
def : Pat<(extractelt (v2f32 DPR:$src1), imm:$src2),
          (EXTRACT_SUBREG (v2f32 (COPY_TO_REGCLASS (v2f32 DPR:$src1),DPR_VFP2)),
                          (SSubReg_f32_reg imm:$src2))>;
def : Pat<(extractelt (v4f32 QPR:$src1), imm:$src2),
          (EXTRACT_SUBREG (v4f32 (COPY_TO_REGCLASS (v4f32 QPR:$src1),QPR_VFP2)),
                          (SSubReg_f32_reg imm:$src2))>;
//def : Pat<(extractelt (v2i64 QPR:$src1), imm:$src2),
//          (EXTRACT_SUBREG QPR:$src1, (DSubReg_f64_reg imm:$src2))>;
def : Pat<(extractelt (v2f64 QPR:$src1), imm:$src2),
          (EXTRACT_SUBREG QPR:$src1, (DSubReg_f64_reg imm:$src2))>;


//   VMOV     : Vector Set Lane (move ARM core register to scalar)

let Constraints = "$src1 = $V" in {
def VSETLNi8  : NVSetLane<{1,1,1,0,0,1,?,0}, 0b1011, {?,?}, (outs DPR:$V),
                          (ins DPR:$src1, GPR:$R, VectorIndex8:$lane),
                          IIC_VMOVISL, "vmov", "8", "$V$lane, $R",
                          [(set DPR:$V, (vector_insert (v8i8 DPR:$src1),
                                           GPR:$R, imm:$lane))]> {
  let Inst{21}  = lane{2};
  let Inst{6-5} = lane{1-0};
}
def VSETLNi16 : NVSetLane<{1,1,1,0,0,0,?,0}, 0b1011, {?,1}, (outs DPR:$V),
                          (ins DPR:$src1, GPR:$R, VectorIndex16:$lane),
                          IIC_VMOVISL, "vmov", "16", "$V$lane, $R",
                          [(set DPR:$V, (vector_insert (v4i16 DPR:$src1),
                                           GPR:$R, imm:$lane))]> {
  let Inst{21} = lane{1};
  let Inst{6}  = lane{0};
}
def VSETLNi32 : NVSetLane<{1,1,1,0,0,0,?,0}, 0b1011, 0b00, (outs DPR:$V),
                          (ins DPR:$src1, GPR:$R, VectorIndex32:$lane),
                          IIC_VMOVISL, "vmov", "32", "$V$lane, $R",
                          [(set DPR:$V, (insertelt (v2i32 DPR:$src1),
                                           GPR:$R, imm:$lane))]> {
  let Inst{21} = lane{0};
}
}
def : Pat<(vector_insert (v16i8 QPR:$src1), GPR:$src2, imm:$lane),
          (v16i8 (INSERT_SUBREG QPR:$src1,
                  (v8i8 (VSETLNi8 (v8i8 (EXTRACT_SUBREG QPR:$src1,
                                   (DSubReg_i8_reg imm:$lane))),
                            GPR:$src2, (SubReg_i8_lane imm:$lane))),
                  (DSubReg_i8_reg imm:$lane)))>;
def : Pat<(vector_insert (v8i16 QPR:$src1), GPR:$src2, imm:$lane),
          (v8i16 (INSERT_SUBREG QPR:$src1,
                  (v4i16 (VSETLNi16 (v4i16 (EXTRACT_SUBREG QPR:$src1,
                                     (DSubReg_i16_reg imm:$lane))),
                             GPR:$src2, (SubReg_i16_lane imm:$lane))),
                  (DSubReg_i16_reg imm:$lane)))>;
def : Pat<(insertelt (v4i32 QPR:$src1), GPR:$src2, imm:$lane),
          (v4i32 (INSERT_SUBREG QPR:$src1,
                  (v2i32 (VSETLNi32 (v2i32 (EXTRACT_SUBREG QPR:$src1,
                                     (DSubReg_i32_reg imm:$lane))),
                             GPR:$src2, (SubReg_i32_lane imm:$lane))),
                  (DSubReg_i32_reg imm:$lane)))>;

def : Pat<(v2f32 (insertelt DPR:$src1, SPR:$src2, imm:$src3)),
          (INSERT_SUBREG (v2f32 (COPY_TO_REGCLASS DPR:$src1, DPR_VFP2)),
                                SPR:$src2, (SSubReg_f32_reg imm:$src3))>;
def : Pat<(v4f32 (insertelt QPR:$src1, SPR:$src2, imm:$src3)),
          (INSERT_SUBREG (v4f32 (COPY_TO_REGCLASS QPR:$src1, QPR_VFP2)),
                                SPR:$src2, (SSubReg_f32_reg imm:$src3))>;

//def : Pat<(v2i64 (insertelt QPR:$src1, DPR:$src2, imm:$src3)),
//          (INSERT_SUBREG QPR:$src1, DPR:$src2, (DSubReg_f64_reg imm:$src3))>;
def : Pat<(v2f64 (insertelt QPR:$src1, DPR:$src2, imm:$src3)),
          (INSERT_SUBREG QPR:$src1, DPR:$src2, (DSubReg_f64_reg imm:$src3))>;

def : Pat<(v2f32 (scalar_to_vector SPR:$src)),
          (INSERT_SUBREG (v2f32 (IMPLICIT_DEF)), SPR:$src, ssub_0)>;
def : Pat<(v2f64 (scalar_to_vector (f64 DPR:$src))),
          (INSERT_SUBREG (v2f64 (IMPLICIT_DEF)), DPR:$src, dsub_0)>;
def : Pat<(v4f32 (scalar_to_vector SPR:$src)),
          (INSERT_SUBREG (v4f32 (IMPLICIT_DEF)), SPR:$src, ssub_0)>;

def : Pat<(v8i8 (scalar_to_vector GPR:$src)),
          (VSETLNi8  (v8i8  (IMPLICIT_DEF)), GPR:$src, (i32 0))>;
def : Pat<(v4i16 (scalar_to_vector GPR:$src)),
          (VSETLNi16 (v4i16 (IMPLICIT_DEF)), GPR:$src, (i32 0))>;
def : Pat<(v2i32 (scalar_to_vector GPR:$src)),
          (VSETLNi32 (v2i32 (IMPLICIT_DEF)), GPR:$src, (i32 0))>;

def : Pat<(v16i8 (scalar_to_vector GPR:$src)),
          (INSERT_SUBREG (v16i8 (IMPLICIT_DEF)),
                         (VSETLNi8 (v8i8 (IMPLICIT_DEF)), GPR:$src, (i32 0)),
                         dsub_0)>;
def : Pat<(v8i16 (scalar_to_vector GPR:$src)),
          (INSERT_SUBREG (v8i16 (IMPLICIT_DEF)),
                         (VSETLNi16 (v4i16 (IMPLICIT_DEF)), GPR:$src, (i32 0)),
                         dsub_0)>;
def : Pat<(v4i32 (scalar_to_vector GPR:$src)),
          (INSERT_SUBREG (v4i32 (IMPLICIT_DEF)),
                         (VSETLNi32 (v2i32 (IMPLICIT_DEF)), GPR:$src, (i32 0)),
                         dsub_0)>;

//   VDUP     : Vector Duplicate (from ARM core register to all elements)

class VDUPD<bits<8> opcod1, bits<2> opcod3, string Dt, ValueType Ty>
  : NVDup<opcod1, 0b1011, opcod3, (outs DPR:$V), (ins GPR:$R),
          IIC_VMOVIS, "vdup", Dt, "$V, $R",
          [(set DPR:$V, (Ty (NEONvdup (i32 GPR:$R))))]>;
class VDUPQ<bits<8> opcod1, bits<2> opcod3, string Dt, ValueType Ty>
  : NVDup<opcod1, 0b1011, opcod3, (outs QPR:$V), (ins GPR:$R),
          IIC_VMOVIS, "vdup", Dt, "$V, $R",
          [(set QPR:$V, (Ty (NEONvdup (i32 GPR:$R))))]>;

def  VDUP8d   : VDUPD<0b11101100, 0b00, "8", v8i8>;
def  VDUP16d  : VDUPD<0b11101000, 0b01, "16", v4i16>;
def  VDUP32d  : VDUPD<0b11101000, 0b00, "32", v2i32>,
                Requires<[HasNEON, HasFastVDUP32]>;
def  VDUP8q   : VDUPQ<0b11101110, 0b00, "8", v16i8>;
def  VDUP16q  : VDUPQ<0b11101010, 0b01, "16", v8i16>;
def  VDUP32q  : VDUPQ<0b11101010, 0b00, "32", v4i32>;

// NEONvdup patterns for uarchs with fast VDUP.32.
def : Pat<(v2f32 (NEONvdup (f32 (bitconvert GPR:$R)))), (VDUP32d GPR:$R)>,
      Requires<[HasNEON,HasFastVDUP32]>;
def : Pat<(v4f32 (NEONvdup (f32 (bitconvert GPR:$R)))), (VDUP32q GPR:$R)>;

// NEONvdup patterns for uarchs with slow VDUP.32 - use VMOVDRR instead.
def : Pat<(v2i32 (NEONvdup (i32 GPR:$R))), (VMOVDRR GPR:$R, GPR:$R)>,
      Requires<[HasNEON,HasSlowVDUP32]>;
def : Pat<(v2f32 (NEONvdup (f32 (bitconvert GPR:$R)))), (VMOVDRR GPR:$R, GPR:$R)>,
      Requires<[HasNEON,HasSlowVDUP32]>;

//   VDUP     : Vector Duplicate Lane (from scalar to all elements)

class VDUPLND<bits<4> op19_16, string OpcodeStr, string Dt,
              ValueType Ty, Operand IdxTy>
  : NVDupLane<op19_16, 0, (outs DPR:$Vd), (ins DPR:$Vm, IdxTy:$lane),
              IIC_VMOVD, OpcodeStr, Dt, "$Vd, $Vm$lane",
              [(set DPR:$Vd, (Ty (NEONvduplane (Ty DPR:$Vm), imm:$lane)))]>;

class VDUPLNQ<bits<4> op19_16, string OpcodeStr, string Dt,
              ValueType ResTy, ValueType OpTy, Operand IdxTy>
  : NVDupLane<op19_16, 1, (outs QPR:$Vd), (ins DPR:$Vm, IdxTy:$lane),
              IIC_VMOVQ, OpcodeStr, Dt, "$Vd, $Vm$lane",
              [(set QPR:$Vd, (ResTy (NEONvduplane (OpTy DPR:$Vm),
                                      VectorIndex32:$lane)))]>;

// Inst{19-16} is partially specified depending on the element size.

def VDUPLN8d  : VDUPLND<{?,?,?,1}, "vdup", "8", v8i8, VectorIndex8> {
  bits<3> lane;
  let Inst{19-17} = lane{2-0};
}
def VDUPLN16d : VDUPLND<{?,?,1,0}, "vdup", "16", v4i16, VectorIndex16> {
  bits<2> lane;
  let Inst{19-18} = lane{1-0};
}
def VDUPLN32d : VDUPLND<{?,1,0,0}, "vdup", "32", v2i32, VectorIndex32> {
  bits<1> lane;
  let Inst{19} = lane{0};
}
def VDUPLN8q  : VDUPLNQ<{?,?,?,1}, "vdup", "8", v16i8, v8i8, VectorIndex8> {
  bits<3> lane;
  let Inst{19-17} = lane{2-0};
}
def VDUPLN16q : VDUPLNQ<{?,?,1,0}, "vdup", "16", v8i16, v4i16, VectorIndex16> {
  bits<2> lane;
  let Inst{19-18} = lane{1-0};
}
def VDUPLN32q : VDUPLNQ<{?,1,0,0}, "vdup", "32", v4i32, v2i32, VectorIndex32> {
  bits<1> lane;
  let Inst{19} = lane{0};
}

def : Pat<(v2f32 (NEONvduplane (v2f32 DPR:$Vm), imm:$lane)),
          (VDUPLN32d DPR:$Vm, imm:$lane)>;

def : Pat<(v4f32 (NEONvduplane (v2f32 DPR:$Vm), imm:$lane)),
          (VDUPLN32q DPR:$Vm, imm:$lane)>;

def : Pat<(v16i8 (NEONvduplane (v16i8 QPR:$src), imm:$lane)),
          (v16i8 (VDUPLN8q (v8i8 (EXTRACT_SUBREG QPR:$src,
                                  (DSubReg_i8_reg imm:$lane))),
                           (SubReg_i8_lane imm:$lane)))>;
def : Pat<(v8i16 (NEONvduplane (v8i16 QPR:$src), imm:$lane)),
          (v8i16 (VDUPLN16q (v4i16 (EXTRACT_SUBREG QPR:$src,
                                    (DSubReg_i16_reg imm:$lane))),
                            (SubReg_i16_lane imm:$lane)))>;
def : Pat<(v4i32 (NEONvduplane (v4i32 QPR:$src), imm:$lane)),
          (v4i32 (VDUPLN32q (v2i32 (EXTRACT_SUBREG QPR:$src,
                                    (DSubReg_i32_reg imm:$lane))),
                            (SubReg_i32_lane imm:$lane)))>;
def : Pat<(v4f32 (NEONvduplane (v4f32 QPR:$src), imm:$lane)),
          (v4f32 (VDUPLN32q (v2f32 (EXTRACT_SUBREG QPR:$src,
                                   (DSubReg_i32_reg imm:$lane))),
                           (SubReg_i32_lane imm:$lane)))>;

def  VDUPfdf : PseudoNeonI<(outs DPR:$dst), (ins SPR:$src), IIC_VMOVD, "",
                    [(set DPR:$dst, (v2f32 (NEONvdup (f32 SPR:$src))))]>;
def  VDUPfqf : PseudoNeonI<(outs QPR:$dst), (ins SPR:$src), IIC_VMOVD, "",
                    [(set QPR:$dst, (v4f32 (NEONvdup (f32 SPR:$src))))]>;

//   VMOVN    : Vector Narrowing Move
defm VMOVN    : N2VN_HSD<0b11,0b11,0b10,0b00100,0,0, IIC_VMOVN,
                         "vmovn", "i", trunc>;
//   VQMOVN   : Vector Saturating Narrowing Move
defm VQMOVNs  : N2VNInt_HSD<0b11,0b11,0b10,0b00101,0,0, IIC_VQUNAiD,
                            "vqmovn", "s", int_arm_neon_vqmovns>;
defm VQMOVNu  : N2VNInt_HSD<0b11,0b11,0b10,0b00101,1,0, IIC_VQUNAiD,
                            "vqmovn", "u", int_arm_neon_vqmovnu>;
defm VQMOVNsu : N2VNInt_HSD<0b11,0b11,0b10,0b00100,1,0, IIC_VQUNAiD,
                            "vqmovun", "s", int_arm_neon_vqmovnsu>;
//   VMOVL    : Vector Lengthening Move
defm VMOVLs   : N2VL_QHS<0b01,0b10100,0,1, "vmovl", "s", sext>;
defm VMOVLu   : N2VL_QHS<0b11,0b10100,0,1, "vmovl", "u", zext>;
def : Pat<(v8i16 (anyext (v8i8 DPR:$Vm))), (VMOVLuv8i16 DPR:$Vm)>;
def : Pat<(v4i32 (anyext (v4i16 DPR:$Vm))), (VMOVLuv4i32 DPR:$Vm)>;
def : Pat<(v2i64 (anyext (v2i32 DPR:$Vm))), (VMOVLuv2i64 DPR:$Vm)>;

// Vector Conversions.

//   VCVT     : Vector Convert Between Floating-Point and Integers
def  VCVTf2sd : N2VD<0b11, 0b11, 0b10, 0b11, 0b01110, 0, "vcvt", "s32.f32",
                     v2i32, v2f32, fp_to_sint>;
def  VCVTf2ud : N2VD<0b11, 0b11, 0b10, 0b11, 0b01111, 0, "vcvt", "u32.f32",
                     v2i32, v2f32, fp_to_uint>;
def  VCVTs2fd : N2VD<0b11, 0b11, 0b10, 0b11, 0b01100, 0, "vcvt", "f32.s32",
                     v2f32, v2i32, sint_to_fp>;
def  VCVTu2fd : N2VD<0b11, 0b11, 0b10, 0b11, 0b01101, 0, "vcvt", "f32.u32",
                     v2f32, v2i32, uint_to_fp>;

def  VCVTf2sq : N2VQ<0b11, 0b11, 0b10, 0b11, 0b01110, 0, "vcvt", "s32.f32",
                     v4i32, v4f32, fp_to_sint>;
def  VCVTf2uq : N2VQ<0b11, 0b11, 0b10, 0b11, 0b01111, 0, "vcvt", "u32.f32",
                     v4i32, v4f32, fp_to_uint>;
def  VCVTs2fq : N2VQ<0b11, 0b11, 0b10, 0b11, 0b01100, 0, "vcvt", "f32.s32",
                     v4f32, v4i32, sint_to_fp>;
def  VCVTu2fq : N2VQ<0b11, 0b11, 0b10, 0b11, 0b01101, 0, "vcvt", "f32.u32",
                     v4f32, v4i32, uint_to_fp>;

//   VCVT     : Vector Convert Between Floating-Point and Fixed-Point.
let DecoderMethod = "DecodeVCVTD" in {
def VCVTf2xsd : N2VCvtD<0, 1, 0b1111, 0, 1, "vcvt", "s32.f32",
                        v2i32, v2f32, int_arm_neon_vcvtfp2fxs>;
def VCVTf2xud : N2VCvtD<1, 1, 0b1111, 0, 1, "vcvt", "u32.f32",
                        v2i32, v2f32, int_arm_neon_vcvtfp2fxu>;
def VCVTxs2fd : N2VCvtD<0, 1, 0b1110, 0, 1, "vcvt", "f32.s32",
                        v2f32, v2i32, int_arm_neon_vcvtfxs2fp>;
def VCVTxu2fd : N2VCvtD<1, 1, 0b1110, 0, 1, "vcvt", "f32.u32",
                        v2f32, v2i32, int_arm_neon_vcvtfxu2fp>;
}

let DecoderMethod = "DecodeVCVTQ" in {
def VCVTf2xsq : N2VCvtQ<0, 1, 0b1111, 0, 1, "vcvt", "s32.f32",
                        v4i32, v4f32, int_arm_neon_vcvtfp2fxs>;
def VCVTf2xuq : N2VCvtQ<1, 1, 0b1111, 0, 1, "vcvt", "u32.f32",
                        v4i32, v4f32, int_arm_neon_vcvtfp2fxu>;
def VCVTxs2fq : N2VCvtQ<0, 1, 0b1110, 0, 1, "vcvt", "f32.s32",
                        v4f32, v4i32, int_arm_neon_vcvtfxs2fp>;
def VCVTxu2fq : N2VCvtQ<1, 1, 0b1110, 0, 1, "vcvt", "f32.u32",
                        v4f32, v4i32, int_arm_neon_vcvtfxu2fp>;
}

//   VCVT     : Vector Convert Between Half-Precision and Single-Precision.
def  VCVTf2h  : N2VNInt<0b11, 0b11, 0b01, 0b10, 0b01100, 0, 0,
                        IIC_VUNAQ, "vcvt", "f16.f32",
                        v4i16, v4f32, int_arm_neon_vcvtfp2hf>,
                Requires<[HasNEON, HasFP16]>;
def  VCVTh2f  : N2VLInt<0b11, 0b11, 0b01, 0b10, 0b01110, 0, 0,
                        IIC_VUNAQ, "vcvt", "f32.f16",
                        v4f32, v4i16, int_arm_neon_vcvthf2fp>,
                Requires<[HasNEON, HasFP16]>;

// Vector Reverse.

//   VREV64   : Vector Reverse elements within 64-bit doublewords

class VREV64D<bits<2> op19_18, string OpcodeStr, string Dt, ValueType Ty>
  : N2V<0b11, 0b11, op19_18, 0b00, 0b00000, 0, 0, (outs DPR:$Vd),
        (ins DPR:$Vm), IIC_VMOVD,
        OpcodeStr, Dt, "$Vd, $Vm", "",
        [(set DPR:$Vd, (Ty (NEONvrev64 (Ty DPR:$Vm))))]>;
class VREV64Q<bits<2> op19_18, string OpcodeStr, string Dt, ValueType Ty>
  : N2V<0b11, 0b11, op19_18, 0b00, 0b00000, 1, 0, (outs QPR:$Vd),
        (ins QPR:$Vm), IIC_VMOVQ,
        OpcodeStr, Dt, "$Vd, $Vm", "",
        [(set QPR:$Vd, (Ty (NEONvrev64 (Ty QPR:$Vm))))]>;

def VREV64d8  : VREV64D<0b00, "vrev64", "8", v8i8>;
def VREV64d16 : VREV64D<0b01, "vrev64", "16", v4i16>;
def VREV64d32 : VREV64D<0b10, "vrev64", "32", v2i32>;
def : Pat<(v2f32 (NEONvrev64 (v2f32 DPR:$Vm))), (VREV64d32 DPR:$Vm)>;

def VREV64q8  : VREV64Q<0b00, "vrev64", "8", v16i8>;
def VREV64q16 : VREV64Q<0b01, "vrev64", "16", v8i16>;
def VREV64q32 : VREV64Q<0b10, "vrev64", "32", v4i32>;
def : Pat<(v4f32 (NEONvrev64 (v4f32 QPR:$Vm))), (VREV64q32 QPR:$Vm)>;

//   VREV32   : Vector Reverse elements within 32-bit words

class VREV32D<bits<2> op19_18, string OpcodeStr, string Dt, ValueType Ty>
  : N2V<0b11, 0b11, op19_18, 0b00, 0b00001, 0, 0, (outs DPR:$Vd),
        (ins DPR:$Vm), IIC_VMOVD,
        OpcodeStr, Dt, "$Vd, $Vm", "",
        [(set DPR:$Vd, (Ty (NEONvrev32 (Ty DPR:$Vm))))]>;
class VREV32Q<bits<2> op19_18, string OpcodeStr, string Dt, ValueType Ty>
  : N2V<0b11, 0b11, op19_18, 0b00, 0b00001, 1, 0, (outs QPR:$Vd),
        (ins QPR:$Vm), IIC_VMOVQ,
        OpcodeStr, Dt, "$Vd, $Vm", "",
        [(set QPR:$Vd, (Ty (NEONvrev32 (Ty QPR:$Vm))))]>;

def VREV32d8  : VREV32D<0b00, "vrev32", "8", v8i8>;
def VREV32d16 : VREV32D<0b01, "vrev32", "16", v4i16>;

def VREV32q8  : VREV32Q<0b00, "vrev32", "8", v16i8>;
def VREV32q16 : VREV32Q<0b01, "vrev32", "16", v8i16>;

//   VREV16   : Vector Reverse elements within 16-bit halfwords

class VREV16D<bits<2> op19_18, string OpcodeStr, string Dt, ValueType Ty>
  : N2V<0b11, 0b11, op19_18, 0b00, 0b00010, 0, 0, (outs DPR:$Vd),
        (ins DPR:$Vm), IIC_VMOVD,
        OpcodeStr, Dt, "$Vd, $Vm", "",
        [(set DPR:$Vd, (Ty (NEONvrev16 (Ty DPR:$Vm))))]>;
class VREV16Q<bits<2> op19_18, string OpcodeStr, string Dt, ValueType Ty>
  : N2V<0b11, 0b11, op19_18, 0b00, 0b00010, 1, 0, (outs QPR:$Vd),
        (ins QPR:$Vm), IIC_VMOVQ,
        OpcodeStr, Dt, "$Vd, $Vm", "",
        [(set QPR:$Vd, (Ty (NEONvrev16 (Ty QPR:$Vm))))]>;

def VREV16d8  : VREV16D<0b00, "vrev16", "8", v8i8>;
def VREV16q8  : VREV16Q<0b00, "vrev16", "8", v16i8>;

// Other Vector Shuffles.

//  Aligned extractions: really just dropping registers

class AlignedVEXTq<ValueType DestTy, ValueType SrcTy, SDNodeXForm LaneCVT>
      : Pat<(DestTy (vector_extract_subvec (SrcTy QPR:$src), (i32 imm:$start))),
             (EXTRACT_SUBREG (SrcTy QPR:$src), (LaneCVT imm:$start))>;

def : AlignedVEXTq<v8i8, v16i8, DSubReg_i8_reg>;

def : AlignedVEXTq<v4i16, v8i16, DSubReg_i16_reg>;

def : AlignedVEXTq<v2i32, v4i32, DSubReg_i32_reg>;

def : AlignedVEXTq<v1i64, v2i64, DSubReg_f64_reg>;

def : AlignedVEXTq<v2f32, v4f32, DSubReg_i32_reg>;


//   VEXT     : Vector Extract


// All of these have a two-operand InstAlias.
let TwoOperandAliasConstraint = "$Vn = $Vd" in {
class VEXTd<string OpcodeStr, string Dt, ValueType Ty, Operand immTy>
  : N3V<0,1,0b11,{?,?,?,?},0,0, (outs DPR:$Vd),
        (ins DPR:$Vn, DPR:$Vm, immTy:$index), NVExtFrm,
        IIC_VEXTD, OpcodeStr, Dt, "$Vd, $Vn, $Vm, $index", "",
        [(set DPR:$Vd, (Ty (NEONvext (Ty DPR:$Vn),
                                     (Ty DPR:$Vm), imm:$index)))]> {
  bits<3> index;
  let Inst{11} = 0b0;
  let Inst{10-8} = index{2-0};
}

class VEXTq<string OpcodeStr, string Dt, ValueType Ty, Operand immTy>
  : N3V<0,1,0b11,{?,?,?,?},1,0, (outs QPR:$Vd),
        (ins QPR:$Vn, QPR:$Vm, imm0_15:$index), NVExtFrm,
        IIC_VEXTQ, OpcodeStr, Dt, "$Vd, $Vn, $Vm, $index", "",
        [(set QPR:$Vd, (Ty (NEONvext (Ty QPR:$Vn),
                                     (Ty QPR:$Vm), imm:$index)))]> {
  bits<4> index;
  let Inst{11-8} = index{3-0};
}
}

def VEXTd8  : VEXTd<"vext", "8",  v8i8, imm0_7> {
  let Inst{10-8} = index{2-0};
}
def VEXTd16 : VEXTd<"vext", "16", v4i16, imm0_3> {
  let Inst{10-9} = index{1-0};
  let Inst{8}    = 0b0;
}
def VEXTd32 : VEXTd<"vext", "32", v2i32, imm0_1> {
  let Inst{10}     = index{0};
  let Inst{9-8}    = 0b00;
}
def : Pat<(v2f32 (NEONvext (v2f32 DPR:$Vn),
                           (v2f32 DPR:$Vm),
                           (i32 imm:$index))),
          (VEXTd32 DPR:$Vn, DPR:$Vm, imm:$index)>;

def VEXTq8  : VEXTq<"vext", "8",  v16i8, imm0_15> {
  let Inst{11-8} = index{3-0};
}
def VEXTq16 : VEXTq<"vext", "16", v8i16, imm0_7> {
  let Inst{11-9} = index{2-0};
  let Inst{8}    = 0b0;
}
def VEXTq32 : VEXTq<"vext", "32", v4i32, imm0_3> {
  let Inst{11-10} = index{1-0};
  let Inst{9-8}    = 0b00;
}
def VEXTq64 : VEXTq<"vext", "64", v2i64, imm0_1> {
  let Inst{11} = index{0};
  let Inst{10-8}    = 0b000;
}
def : Pat<(v4f32 (NEONvext (v4f32 QPR:$Vn),
                           (v4f32 QPR:$Vm),
                           (i32 imm:$index))),
          (VEXTq32 QPR:$Vn, QPR:$Vm, imm:$index)>;

//   VTRN     : Vector Transpose

def  VTRNd8   : N2VDShuffle<0b00, 0b00001, "vtrn", "8">;
def  VTRNd16  : N2VDShuffle<0b01, 0b00001, "vtrn", "16">;
def  VTRNd32  : N2VDShuffle<0b10, 0b00001, "vtrn", "32">;

def  VTRNq8   : N2VQShuffle<0b00, 0b00001, IIC_VPERMQ, "vtrn", "8">;
def  VTRNq16  : N2VQShuffle<0b01, 0b00001, IIC_VPERMQ, "vtrn", "16">;
def  VTRNq32  : N2VQShuffle<0b10, 0b00001, IIC_VPERMQ, "vtrn", "32">;

//   VUZP     : Vector Unzip (Deinterleave)

def  VUZPd8   : N2VDShuffle<0b00, 0b00010, "vuzp", "8">;
def  VUZPd16  : N2VDShuffle<0b01, 0b00010, "vuzp", "16">;
// vuzp.32 Dd, Dm is a pseudo-instruction expanded to vtrn.32 Dd, Dm.
def : NEONInstAlias<"vuzp${p}.32 $Dd, $Dm",
                    (VTRNd32 DPR:$Dd, DPR:$Dm, pred:$p)>;

def  VUZPq8   : N2VQShuffle<0b00, 0b00010, IIC_VPERMQ3, "vuzp", "8">;
def  VUZPq16  : N2VQShuffle<0b01, 0b00010, IIC_VPERMQ3, "vuzp", "16">;
def  VUZPq32  : N2VQShuffle<0b10, 0b00010, IIC_VPERMQ3, "vuzp", "32">;

//   VZIP     : Vector Zip (Interleave)

def  VZIPd8   : N2VDShuffle<0b00, 0b00011, "vzip", "8">;
def  VZIPd16  : N2VDShuffle<0b01, 0b00011, "vzip", "16">;
// vzip.32 Dd, Dm is a pseudo-instruction expanded to vtrn.32 Dd, Dm.
def : NEONInstAlias<"vzip${p}.32 $Dd, $Dm",
                    (VTRNd32 DPR:$Dd, DPR:$Dm, pred:$p)>;

def  VZIPq8   : N2VQShuffle<0b00, 0b00011, IIC_VPERMQ3, "vzip", "8">;
def  VZIPq16  : N2VQShuffle<0b01, 0b00011, IIC_VPERMQ3, "vzip", "16">;
def  VZIPq32  : N2VQShuffle<0b10, 0b00011, IIC_VPERMQ3, "vzip", "32">;

// Vector Table Lookup and Table Extension.

//   VTBL     : Vector Table Lookup
let DecoderMethod = "DecodeTBLInstruction" in {
def  VTBL1
  : N3V<1,1,0b11,0b1000,0,0, (outs DPR:$Vd),
        (ins VecListOneD:$Vn, DPR:$Vm), NVTBLFrm, IIC_VTB1,
        "vtbl", "8", "$Vd, $Vn, $Vm", "",
        [(set DPR:$Vd, (v8i8 (int_arm_neon_vtbl1 VecListOneD:$Vn, DPR:$Vm)))]>;
let hasExtraSrcRegAllocReq = 1 in {
def  VTBL2
  : N3V<1,1,0b11,0b1001,0,0, (outs DPR:$Vd),
        (ins VecListDPair:$Vn, DPR:$Vm), NVTBLFrm, IIC_VTB2,
        "vtbl", "8", "$Vd, $Vn, $Vm", "", []>;
def  VTBL3
  : N3V<1,1,0b11,0b1010,0,0, (outs DPR:$Vd),
        (ins VecListThreeD:$Vn, DPR:$Vm), NVTBLFrm, IIC_VTB3,
        "vtbl", "8", "$Vd, $Vn, $Vm", "", []>;
def  VTBL4
  : N3V<1,1,0b11,0b1011,0,0, (outs DPR:$Vd),
        (ins VecListFourD:$Vn, DPR:$Vm),
        NVTBLFrm, IIC_VTB4,
        "vtbl", "8", "$Vd, $Vn, $Vm", "", []>;
} // hasExtraSrcRegAllocReq = 1

def  VTBL3Pseudo
  : PseudoNeonI<(outs DPR:$dst), (ins QQPR:$tbl, DPR:$src), IIC_VTB3, "", []>;
def  VTBL4Pseudo
  : PseudoNeonI<(outs DPR:$dst), (ins QQPR:$tbl, DPR:$src), IIC_VTB4, "", []>;

//   VTBX     : Vector Table Extension
def  VTBX1
  : N3V<1,1,0b11,0b1000,1,0, (outs DPR:$Vd),
        (ins DPR:$orig, VecListOneD:$Vn, DPR:$Vm), NVTBLFrm, IIC_VTBX1,
        "vtbx", "8", "$Vd, $Vn, $Vm", "$orig = $Vd",
        [(set DPR:$Vd, (v8i8 (int_arm_neon_vtbx1
                               DPR:$orig, VecListOneD:$Vn, DPR:$Vm)))]>;
let hasExtraSrcRegAllocReq = 1 in {
def  VTBX2
  : N3V<1,1,0b11,0b1001,1,0, (outs DPR:$Vd),
        (ins DPR:$orig, VecListDPair:$Vn, DPR:$Vm), NVTBLFrm, IIC_VTBX2,
        "vtbx", "8", "$Vd, $Vn, $Vm", "$orig = $Vd", []>;
def  VTBX3
  : N3V<1,1,0b11,0b1010,1,0, (outs DPR:$Vd),
        (ins DPR:$orig, VecListThreeD:$Vn, DPR:$Vm),
        NVTBLFrm, IIC_VTBX3,
        "vtbx", "8", "$Vd, $Vn, $Vm",
        "$orig = $Vd", []>;
def  VTBX4
  : N3V<1,1,0b11,0b1011,1,0, (outs DPR:$Vd),
        (ins DPR:$orig, VecListFourD:$Vn, DPR:$Vm), NVTBLFrm, IIC_VTBX4,
        "vtbx", "8", "$Vd, $Vn, $Vm",
        "$orig = $Vd", []>;
} // hasExtraSrcRegAllocReq = 1

def  VTBX3Pseudo
  : PseudoNeonI<(outs DPR:$dst), (ins DPR:$orig, QQPR:$tbl, DPR:$src),
                IIC_VTBX3, "$orig = $dst", []>;
def  VTBX4Pseudo
  : PseudoNeonI<(outs DPR:$dst), (ins DPR:$orig, QQPR:$tbl, DPR:$src),
                IIC_VTBX4, "$orig = $dst", []>;
} // DecoderMethod = "DecodeTBLInstruction"

//===----------------------------------------------------------------------===//
// NEON instructions for single-precision FP math
//===----------------------------------------------------------------------===//

class N2VSPat<SDNode OpNode, NeonI Inst>
  : NEONFPPat<(f32 (OpNode SPR:$a)),
              (EXTRACT_SUBREG
               (v2f32 (COPY_TO_REGCLASS (Inst
                (INSERT_SUBREG
                 (v2f32 (COPY_TO_REGCLASS (v2f32 (IMPLICIT_DEF)), DPR_VFP2)),
                 SPR:$a, ssub_0)), DPR_VFP2)), ssub_0)>;

class N3VSPat<SDNode OpNode, NeonI Inst>
  : NEONFPPat<(f32 (OpNode SPR:$a, SPR:$b)),
              (EXTRACT_SUBREG
               (v2f32 (COPY_TO_REGCLASS (Inst
                (INSERT_SUBREG
                 (v2f32 (COPY_TO_REGCLASS (v2f32 (IMPLICIT_DEF)), DPR_VFP2)),
                 SPR:$a, ssub_0),
                (INSERT_SUBREG
                 (v2f32 (COPY_TO_REGCLASS (v2f32 (IMPLICIT_DEF)), DPR_VFP2)),
                 SPR:$b, ssub_0)), DPR_VFP2)), ssub_0)>;

class N3VSMulOpPat<SDNode MulNode, SDNode OpNode, NeonI Inst>
  : NEONFPPat<(f32 (OpNode SPR:$acc, (f32 (MulNode SPR:$a, SPR:$b)))),
              (EXTRACT_SUBREG
               (v2f32 (COPY_TO_REGCLASS (Inst
                (INSERT_SUBREG
                 (v2f32 (COPY_TO_REGCLASS (v2f32 (IMPLICIT_DEF)), DPR_VFP2)),
                 SPR:$acc, ssub_0),
                (INSERT_SUBREG
                 (v2f32 (COPY_TO_REGCLASS (v2f32 (IMPLICIT_DEF)), DPR_VFP2)),
                 SPR:$a, ssub_0),
                (INSERT_SUBREG
                 (v2f32 (COPY_TO_REGCLASS (v2f32 (IMPLICIT_DEF)), DPR_VFP2)),
                 SPR:$b, ssub_0)), DPR_VFP2)), ssub_0)>;

def : N3VSPat<fadd, VADDfd>;
def : N3VSPat<fsub, VSUBfd>;
def : N3VSPat<fmul, VMULfd>;
def : N3VSMulOpPat<fmul, fadd, VMLAfd>,
      Requires<[HasNEON, UseNEONForFP, UseFPVMLx, DontUseFusedMAC]>;
def : N3VSMulOpPat<fmul, fsub, VMLSfd>,
      Requires<[HasNEON, UseNEONForFP, UseFPVMLx, DontUseFusedMAC]>;
def : N3VSMulOpPat<fmul, fadd, VFMAfd>,
      Requires<[HasVFP4, UseNEONForFP, UseFusedMAC]>;
def : N3VSMulOpPat<fmul, fsub, VFMSfd>,
      Requires<[HasVFP4, UseNEONForFP, UseFusedMAC]>;
def : N2VSPat<fabs, VABSfd>;
def : N2VSPat<fneg, VNEGfd>;
def : N3VSPat<NEONfmax, VMAXfd>;
def : N3VSPat<NEONfmin, VMINfd>;
def : N2VSPat<arm_ftosi, VCVTf2sd>;
def : N2VSPat<arm_ftoui, VCVTf2ud>;
def : N2VSPat<arm_sitof, VCVTs2fd>;
def : N2VSPat<arm_uitof, VCVTu2fd>;

// Prefer VMOVDRR for i32 -> f32 bitcasts, it can write all DPR registers.
def : Pat<(f32 (bitconvert GPR:$a)),
          (EXTRACT_SUBREG (VMOVDRR GPR:$a, GPR:$a), ssub_0)>,
        Requires<[HasNEON, DontUseVMOVSR]>;

//===----------------------------------------------------------------------===//
// Non-Instruction Patterns
//===----------------------------------------------------------------------===//

// bit_convert
def : Pat<(v1i64 (bitconvert (v2i32 DPR:$src))), (v1i64 DPR:$src)>;
def : Pat<(v1i64 (bitconvert (v4i16 DPR:$src))), (v1i64 DPR:$src)>;
def : Pat<(v1i64 (bitconvert (v8i8  DPR:$src))), (v1i64 DPR:$src)>;
def : Pat<(v1i64 (bitconvert (f64   DPR:$src))), (v1i64 DPR:$src)>;
def : Pat<(v1i64 (bitconvert (v2f32 DPR:$src))), (v1i64 DPR:$src)>;
def : Pat<(v2i32 (bitconvert (v1i64 DPR:$src))), (v2i32 DPR:$src)>;
def : Pat<(v2i32 (bitconvert (v4i16 DPR:$src))), (v2i32 DPR:$src)>;
def : Pat<(v2i32 (bitconvert (v8i8  DPR:$src))), (v2i32 DPR:$src)>;
def : Pat<(v2i32 (bitconvert (f64   DPR:$src))), (v2i32 DPR:$src)>;
def : Pat<(v2i32 (bitconvert (v2f32 DPR:$src))), (v2i32 DPR:$src)>;
def : Pat<(v4i16 (bitconvert (v1i64 DPR:$src))), (v4i16 DPR:$src)>;
def : Pat<(v4i16 (bitconvert (v2i32 DPR:$src))), (v4i16 DPR:$src)>;
def : Pat<(v4i16 (bitconvert (v8i8  DPR:$src))), (v4i16 DPR:$src)>;
def : Pat<(v4i16 (bitconvert (f64   DPR:$src))), (v4i16 DPR:$src)>;
def : Pat<(v4i16 (bitconvert (v2f32 DPR:$src))), (v4i16 DPR:$src)>;
def : Pat<(v8i8  (bitconvert (v1i64 DPR:$src))), (v8i8  DPR:$src)>;
def : Pat<(v8i8  (bitconvert (v2i32 DPR:$src))), (v8i8  DPR:$src)>;
def : Pat<(v8i8  (bitconvert (v4i16 DPR:$src))), (v8i8  DPR:$src)>;
def : Pat<(v8i8  (bitconvert (f64   DPR:$src))), (v8i8  DPR:$src)>;
def : Pat<(v8i8  (bitconvert (v2f32 DPR:$src))), (v8i8  DPR:$src)>;
def : Pat<(f64   (bitconvert (v1i64 DPR:$src))), (f64   DPR:$src)>;
def : Pat<(f64   (bitconvert (v2i32 DPR:$src))), (f64   DPR:$src)>;
def : Pat<(f64   (bitconvert (v4i16 DPR:$src))), (f64   DPR:$src)>;
def : Pat<(f64   (bitconvert (v8i8  DPR:$src))), (f64   DPR:$src)>;
def : Pat<(f64   (bitconvert (v2f32 DPR:$src))), (f64   DPR:$src)>;
def : Pat<(v2f32 (bitconvert (f64   DPR:$src))), (v2f32 DPR:$src)>;
def : Pat<(v2f32 (bitconvert (v1i64 DPR:$src))), (v2f32 DPR:$src)>;
def : Pat<(v2f32 (bitconvert (v2i32 DPR:$src))), (v2f32 DPR:$src)>;
def : Pat<(v2f32 (bitconvert (v4i16 DPR:$src))), (v2f32 DPR:$src)>;
def : Pat<(v2f32 (bitconvert (v8i8  DPR:$src))), (v2f32 DPR:$src)>;

def : Pat<(v2i64 (bitconvert (v4i32 QPR:$src))), (v2i64 QPR:$src)>;
def : Pat<(v2i64 (bitconvert (v8i16 QPR:$src))), (v2i64 QPR:$src)>;
def : Pat<(v2i64 (bitconvert (v16i8 QPR:$src))), (v2i64 QPR:$src)>;
def : Pat<(v2i64 (bitconvert (v2f64 QPR:$src))), (v2i64 QPR:$src)>;
def : Pat<(v2i64 (bitconvert (v4f32 QPR:$src))), (v2i64 QPR:$src)>;
def : Pat<(v4i32 (bitconvert (v2i64 QPR:$src))), (v4i32 QPR:$src)>;
def : Pat<(v4i32 (bitconvert (v8i16 QPR:$src))), (v4i32 QPR:$src)>;
def : Pat<(v4i32 (bitconvert (v16i8 QPR:$src))), (v4i32 QPR:$src)>;
def : Pat<(v4i32 (bitconvert (v2f64 QPR:$src))), (v4i32 QPR:$src)>;
def : Pat<(v4i32 (bitconvert (v4f32 QPR:$src))), (v4i32 QPR:$src)>;
def : Pat<(v8i16 (bitconvert (v2i64 QPR:$src))), (v8i16 QPR:$src)>;
def : Pat<(v8i16 (bitconvert (v4i32 QPR:$src))), (v8i16 QPR:$src)>;
def : Pat<(v8i16 (bitconvert (v16i8 QPR:$src))), (v8i16 QPR:$src)>;
def : Pat<(v8i16 (bitconvert (v2f64 QPR:$src))), (v8i16 QPR:$src)>;
def : Pat<(v8i16 (bitconvert (v4f32 QPR:$src))), (v8i16 QPR:$src)>;
def : Pat<(v16i8 (bitconvert (v2i64 QPR:$src))), (v16i8 QPR:$src)>;
def : Pat<(v16i8 (bitconvert (v4i32 QPR:$src))), (v16i8 QPR:$src)>;
def : Pat<(v16i8 (bitconvert (v8i16 QPR:$src))), (v16i8 QPR:$src)>;
def : Pat<(v16i8 (bitconvert (v2f64 QPR:$src))), (v16i8 QPR:$src)>;
def : Pat<(v16i8 (bitconvert (v4f32 QPR:$src))), (v16i8 QPR:$src)>;
def : Pat<(v4f32 (bitconvert (v2i64 QPR:$src))), (v4f32 QPR:$src)>;
def : Pat<(v4f32 (bitconvert (v4i32 QPR:$src))), (v4f32 QPR:$src)>;
def : Pat<(v4f32 (bitconvert (v8i16 QPR:$src))), (v4f32 QPR:$src)>;
def : Pat<(v4f32 (bitconvert (v16i8 QPR:$src))), (v4f32 QPR:$src)>;
def : Pat<(v4f32 (bitconvert (v2f64 QPR:$src))), (v4f32 QPR:$src)>;
def : Pat<(v2f64 (bitconvert (v2i64 QPR:$src))), (v2f64 QPR:$src)>;
def : Pat<(v2f64 (bitconvert (v4i32 QPR:$src))), (v2f64 QPR:$src)>;
def : Pat<(v2f64 (bitconvert (v8i16 QPR:$src))), (v2f64 QPR:$src)>;
def : Pat<(v2f64 (bitconvert (v16i8 QPR:$src))), (v2f64 QPR:$src)>;
def : Pat<(v2f64 (bitconvert (v4f32 QPR:$src))), (v2f64 QPR:$src)>;

// Fold extracting an element out of a v2i32 into a vfp register.
def : Pat<(f32 (bitconvert (i32 (extractelt (v2i32 DPR:$src), imm:$lane)))),
          (f32 (EXTRACT_SUBREG DPR:$src, (SSubReg_f32_reg imm:$lane)))>;

// Vector lengthening move with load, matching extending loads.

// extload, zextload and sextload for a standard lengthening load. Example:
// Lengthen_Single<"8", "i16", "8"> = 
//     Pat<(v8i16 (extloadvi8 addrmode6:$addr))
//         (VMOVLuv8i16 (VLD1d8 addrmode6:$addr,
//                              (f64 (IMPLICIT_DEF)), (i32 0)))>;
multiclass Lengthen_Single<string DestLanes, string DestTy, string SrcTy> {
  let AddedComplexity = 10 in {
  def _Any : Pat<(!cast<ValueType>("v" # DestLanes # DestTy)
                    (!cast<PatFrag>("extloadvi" # SrcTy) addrmode6:$addr)),
                  (!cast<Instruction>("VMOVLuv" # DestLanes # DestTy)
                    (!cast<Instruction>("VLD1d" # SrcTy) addrmode6:$addr))>;

  def _Z : Pat<(!cast<ValueType>("v" # DestLanes # DestTy)
                  (!cast<PatFrag>("zextloadvi" # SrcTy) addrmode6:$addr)),
                (!cast<Instruction>("VMOVLuv" # DestLanes # DestTy)
                    (!cast<Instruction>("VLD1d" # SrcTy) addrmode6:$addr))>;

  def _S : Pat<(!cast<ValueType>("v" # DestLanes # DestTy)
                  (!cast<PatFrag>("sextloadvi" # SrcTy) addrmode6:$addr)),
                (!cast<Instruction>("VMOVLsv" # DestLanes # DestTy)
                    (!cast<Instruction>("VLD1d" # SrcTy) addrmode6:$addr))>;
  }
}

// extload, zextload and sextload for a lengthening load which only uses
// half the lanes available. Example:
// Lengthen_HalfSingle<"4", "i16", "8", "i16", "i8"> =
//     Pat<(v4i16 (extloadvi8 addrmode6oneL32:$addr)),
//         (EXTRACT_SUBREG (VMOVLuv8i16 (VLD1LNd32 addrmode6oneL32:$addr, 
//                                      (f64 (IMPLICIT_DEF)), (i32 0))),
//                         dsub_0)>;
multiclass Lengthen_HalfSingle<string DestLanes, string DestTy, string SrcTy,
                               string InsnLanes, string InsnTy> {
  def _Any : Pat<(!cast<ValueType>("v" # DestLanes # DestTy)
                   (!cast<PatFrag>("extloadv" # SrcTy) addrmode6oneL32:$addr)),
       (EXTRACT_SUBREG (!cast<Instruction>("VMOVLuv" # InsnLanes # InsnTy)
         (VLD1LNd32 addrmode6oneL32:$addr, (f64 (IMPLICIT_DEF)), (i32 0))),
         dsub_0)>;
  def _Z   : Pat<(!cast<ValueType>("v" # DestLanes # DestTy)
                   (!cast<PatFrag>("zextloadv" # SrcTy) addrmode6oneL32:$addr)),
       (EXTRACT_SUBREG (!cast<Instruction>("VMOVLuv" # InsnLanes # InsnTy)
         (VLD1LNd32 addrmode6oneL32:$addr, (f64 (IMPLICIT_DEF)), (i32 0))),
         dsub_0)>;
  def _S   : Pat<(!cast<ValueType>("v" # DestLanes # DestTy)
                   (!cast<PatFrag>("sextloadv" # SrcTy) addrmode6oneL32:$addr)),
       (EXTRACT_SUBREG (!cast<Instruction>("VMOVLsv" # InsnLanes # InsnTy)
         (VLD1LNd32 addrmode6oneL32:$addr, (f64 (IMPLICIT_DEF)), (i32 0))),
         dsub_0)>;
}

// extload, zextload and sextload for a lengthening load followed by another
// lengthening load, to quadruple the initial length.
//
// Lengthen_Double<"4", "i32", "i8", "8", "i16", "4", "i32"> =
//     Pat<(v4i32 (extloadvi8 addrmode6oneL32:$addr))
//         (EXTRACT_SUBREG (VMOVLuv4i32
//           (EXTRACT_SUBREG (VMOVLuv8i16 (VLD1LNd32 addrmode6oneL32:$addr,
//                                                   (f64 (IMPLICIT_DEF)),
//                                                   (i32 0))),
//                           dsub_0)),
//           dsub_0)>;
multiclass Lengthen_Double<string DestLanes, string DestTy, string SrcTy,
                           string Insn1Lanes, string Insn1Ty, string Insn2Lanes,
                           string Insn2Ty> {
  def _Any : Pat<(!cast<ValueType>("v" # DestLanes # DestTy)
                   (!cast<PatFrag>("extloadv" # SrcTy) addrmode6oneL32:$addr)),
         (!cast<Instruction>("VMOVLuv" # Insn2Lanes # Insn2Ty)
           (EXTRACT_SUBREG (!cast<Instruction>("VMOVLuv" # Insn1Lanes # Insn1Ty)
             (VLD1LNd32 addrmode6oneL32:$addr, (f64 (IMPLICIT_DEF)), (i32 0))),
             dsub_0))>;
  def _Z   : Pat<(!cast<ValueType>("v" # DestLanes # DestTy)
                   (!cast<PatFrag>("zextloadv" # SrcTy) addrmode6oneL32:$addr)),
         (!cast<Instruction>("VMOVLuv" # Insn2Lanes # Insn2Ty)
           (EXTRACT_SUBREG (!cast<Instruction>("VMOVLuv" # Insn1Lanes # Insn1Ty)
             (VLD1LNd32 addrmode6oneL32:$addr, (f64 (IMPLICIT_DEF)), (i32 0))),
             dsub_0))>;
  def _S   : Pat<(!cast<ValueType>("v" # DestLanes # DestTy)
                   (!cast<PatFrag>("sextloadv" # SrcTy) addrmode6oneL32:$addr)),
         (!cast<Instruction>("VMOVLsv" # Insn2Lanes # Insn2Ty)
           (EXTRACT_SUBREG (!cast<Instruction>("VMOVLsv" # Insn1Lanes # Insn1Ty)
             (VLD1LNd32 addrmode6oneL32:$addr, (f64 (IMPLICIT_DEF)), (i32 0))),
             dsub_0))>;
}

// extload, zextload and sextload for a lengthening load followed by another
// lengthening load, to quadruple the initial length, but which ends up only
// requiring half the available lanes (a 64-bit outcome instead of a 128-bit).
//
// Lengthen_HalfDouble<"2", "i32", "i8", "8", "i16", "4", "i32"> =
// Pat<(v2i32 (extloadvi8 addrmode6:$addr))
//     (EXTRACT_SUBREG (VMOVLuv4i32
//       (EXTRACT_SUBREG (VMOVLuv8i16 (VLD1LNd16 addrmode6:$addr,
//                                               (f64 (IMPLICIT_DEF)), (i32 0))),
//                       dsub_0)),
//       dsub_0)>;
multiclass Lengthen_HalfDouble<string DestLanes, string DestTy, string SrcTy,
                           string Insn1Lanes, string Insn1Ty, string Insn2Lanes,
                           string Insn2Ty> {
  def _Any : Pat<(!cast<ValueType>("v" # DestLanes # DestTy)
                   (!cast<PatFrag>("extloadv" # SrcTy) addrmode6:$addr)),
         (EXTRACT_SUBREG (!cast<Instruction>("VMOVLuv" # Insn2Lanes # Insn2Ty)
           (EXTRACT_SUBREG (!cast<Instruction>("VMOVLuv" # Insn1Lanes # Insn1Ty)
             (VLD1LNd16 addrmode6:$addr, (f64 (IMPLICIT_DEF)), (i32 0))),
             dsub_0)),
          dsub_0)>;
  def _Z   : Pat<(!cast<ValueType>("v" # DestLanes # DestTy)
                   (!cast<PatFrag>("zextloadv" # SrcTy) addrmode6:$addr)),
         (EXTRACT_SUBREG (!cast<Instruction>("VMOVLuv" # Insn2Lanes # Insn2Ty)
           (EXTRACT_SUBREG (!cast<Instruction>("VMOVLuv" # Insn1Lanes # Insn1Ty)
             (VLD1LNd16 addrmode6:$addr, (f64 (IMPLICIT_DEF)), (i32 0))),
             dsub_0)),
          dsub_0)>;
  def _S   : Pat<(!cast<ValueType>("v" # DestLanes # DestTy)
                   (!cast<PatFrag>("sextloadv" # SrcTy) addrmode6:$addr)),
         (EXTRACT_SUBREG (!cast<Instruction>("VMOVLsv" # Insn2Lanes # Insn2Ty)
           (EXTRACT_SUBREG (!cast<Instruction>("VMOVLsv" # Insn1Lanes # Insn1Ty)
             (VLD1LNd16 addrmode6:$addr, (f64 (IMPLICIT_DEF)), (i32 0))),
             dsub_0)),
          dsub_0)>;
}

defm : Lengthen_Single<"8", "i16", "8">; // v8i8 -> v8i16
defm : Lengthen_Single<"4", "i32", "16">; // v4i16 -> v4i32
defm : Lengthen_Single<"2", "i64", "32">; // v2i32 -> v2i64

defm : Lengthen_HalfSingle<"4", "i16", "i8", "8", "i16">; // v4i8 -> v4i16
defm : Lengthen_HalfSingle<"2", "i32", "i16", "4", "i32">; // v2i16 -> v2i32

// Double lengthening - v4i8 -> v4i16 -> v4i32
defm : Lengthen_Double<"4", "i32", "i8", "8", "i16", "4", "i32">;
// v2i8 -> v2i16 -> v2i32
defm : Lengthen_HalfDouble<"2", "i32", "i8", "8", "i16", "4", "i32">;
// v2i16 -> v2i32 -> v2i64
defm : Lengthen_Double<"2", "i64", "i16", "4", "i32", "2", "i64">;

// Triple lengthening - v2i8 -> v2i16 -> v2i32 -> v2i64
def : Pat<(v2i64 (extloadvi8 addrmode6:$addr)),
      (VMOVLuv2i64 (EXTRACT_SUBREG (VMOVLuv4i32 (EXTRACT_SUBREG (VMOVLuv8i16
         (VLD1LNd16 addrmode6:$addr, 
                    (f64 (IMPLICIT_DEF)), (i32 0))), dsub_0)), dsub_0))>;
def : Pat<(v2i64 (zextloadvi8 addrmode6:$addr)),
      (VMOVLuv2i64 (EXTRACT_SUBREG (VMOVLuv4i32 (EXTRACT_SUBREG (VMOVLuv8i16
         (VLD1LNd16 addrmode6:$addr,
                    (f64 (IMPLICIT_DEF)), (i32 0))), dsub_0)), dsub_0))>;
def : Pat<(v2i64 (sextloadvi8 addrmode6:$addr)),
      (VMOVLsv2i64 (EXTRACT_SUBREG (VMOVLsv4i32 (EXTRACT_SUBREG (VMOVLsv8i16
         (VLD1LNd16 addrmode6:$addr,
                    (f64 (IMPLICIT_DEF)), (i32 0))), dsub_0)), dsub_0))>;

//===----------------------------------------------------------------------===//
// Assembler aliases
//

def : VFP2InstAlias<"fmdhr${p} $Dd, $Rn",
                    (VSETLNi32 DPR:$Dd, GPR:$Rn, 1, pred:$p)>;
def : VFP2InstAlias<"fmdlr${p} $Dd, $Rn",
                    (VSETLNi32 DPR:$Dd, GPR:$Rn, 0, pred:$p)>;

// VAND/VBIC/VEOR/VORR accept but do not require a type suffix.
defm : NEONDTAnyInstAlias<"vand${p}", "$Vd, $Vn, $Vm",
                         (VANDd DPR:$Vd, DPR:$Vn, DPR:$Vm, pred:$p)>;
defm : NEONDTAnyInstAlias<"vand${p}", "$Vd, $Vn, $Vm",
                         (VANDq QPR:$Vd, QPR:$Vn, QPR:$Vm, pred:$p)>;
defm : NEONDTAnyInstAlias<"vbic${p}", "$Vd, $Vn, $Vm",
                         (VBICd DPR:$Vd, DPR:$Vn, DPR:$Vm, pred:$p)>;
defm : NEONDTAnyInstAlias<"vbic${p}", "$Vd, $Vn, $Vm",
                         (VBICq QPR:$Vd, QPR:$Vn, QPR:$Vm, pred:$p)>;
defm : NEONDTAnyInstAlias<"veor${p}", "$Vd, $Vn, $Vm",
                         (VEORd DPR:$Vd, DPR:$Vn, DPR:$Vm, pred:$p)>;
defm : NEONDTAnyInstAlias<"veor${p}", "$Vd, $Vn, $Vm",
                         (VEORq QPR:$Vd, QPR:$Vn, QPR:$Vm, pred:$p)>;
defm : NEONDTAnyInstAlias<"vorr${p}", "$Vd, $Vn, $Vm",
                         (VORRd DPR:$Vd, DPR:$Vn, DPR:$Vm, pred:$p)>;
defm : NEONDTAnyInstAlias<"vorr${p}", "$Vd, $Vn, $Vm",
                         (VORRq QPR:$Vd, QPR:$Vn, QPR:$Vm, pred:$p)>;
// ... two-operand aliases
defm : NEONDTAnyInstAlias<"vand${p}", "$Vdn, $Vm",
                         (VANDd DPR:$Vdn, DPR:$Vdn, DPR:$Vm, pred:$p)>;
defm : NEONDTAnyInstAlias<"vand${p}", "$Vdn, $Vm",
                         (VANDq QPR:$Vdn, QPR:$Vdn, QPR:$Vm, pred:$p)>;
defm : NEONDTAnyInstAlias<"veor${p}", "$Vdn, $Vm",
                         (VEORd DPR:$Vdn, DPR:$Vdn, DPR:$Vm, pred:$p)>;
defm : NEONDTAnyInstAlias<"veor${p}", "$Vdn, $Vm",
                         (VEORq QPR:$Vdn, QPR:$Vdn, QPR:$Vm, pred:$p)>;
defm : NEONDTAnyInstAlias<"vorr${p}", "$Vdn, $Vm",
                         (VORRd DPR:$Vdn, DPR:$Vdn, DPR:$Vm, pred:$p)>;
defm : NEONDTAnyInstAlias<"vorr${p}", "$Vdn, $Vm",
                         (VORRq QPR:$Vdn, QPR:$Vdn, QPR:$Vm, pred:$p)>;

// VLD1 single-lane pseudo-instructions. These need special handling for
// the lane index that an InstAlias can't handle, so we use these instead.
def VLD1LNdAsm_8 : NEONDataTypeAsmPseudoInst<"vld1${p}", ".8", "$list, $addr",
                 (ins VecListOneDByteIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD1LNdAsm_16 : NEONDataTypeAsmPseudoInst<"vld1${p}", ".16", "$list, $addr",
                 (ins VecListOneDHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD1LNdAsm_32 : NEONDataTypeAsmPseudoInst<"vld1${p}", ".32", "$list, $addr",
                 (ins VecListOneDWordIndexed:$list, addrmode6:$addr, pred:$p)>;

def VLD1LNdWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld1${p}", ".8", "$list, $addr!",
                 (ins VecListOneDByteIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD1LNdWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld1${p}", ".16", "$list, $addr!",
                 (ins VecListOneDHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD1LNdWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld1${p}", ".32", "$list, $addr!",
                 (ins VecListOneDWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD1LNdWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld1${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListOneDByteIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD1LNdWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld1${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListOneDHWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD1LNdWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld1${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListOneDWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;


// VST1 single-lane pseudo-instructions. These need special handling for
// the lane index that an InstAlias can't handle, so we use these instead.
def VST1LNdAsm_8 : NEONDataTypeAsmPseudoInst<"vst1${p}", ".8", "$list, $addr",
                 (ins VecListOneDByteIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST1LNdAsm_16 : NEONDataTypeAsmPseudoInst<"vst1${p}", ".16", "$list, $addr",
                 (ins VecListOneDHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST1LNdAsm_32 : NEONDataTypeAsmPseudoInst<"vst1${p}", ".32", "$list, $addr",
                 (ins VecListOneDWordIndexed:$list, addrmode6:$addr, pred:$p)>;

def VST1LNdWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vst1${p}", ".8", "$list, $addr!",
                 (ins VecListOneDByteIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST1LNdWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst1${p}", ".16", "$list, $addr!",
                 (ins VecListOneDHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST1LNdWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst1${p}", ".32", "$list, $addr!",
                 (ins VecListOneDWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST1LNdWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vst1${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListOneDByteIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST1LNdWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst1${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListOneDHWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST1LNdWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst1${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListOneDWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;

// VLD2 single-lane pseudo-instructions. These need special handling for
// the lane index that an InstAlias can't handle, so we use these instead.
def VLD2LNdAsm_8 : NEONDataTypeAsmPseudoInst<"vld2${p}", ".8", "$list, $addr",
                 (ins VecListTwoDByteIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD2LNdAsm_16 : NEONDataTypeAsmPseudoInst<"vld2${p}", ".16", "$list, $addr",
                 (ins VecListTwoDHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD2LNdAsm_32 : NEONDataTypeAsmPseudoInst<"vld2${p}", ".32", "$list, $addr",
                 (ins VecListTwoDWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD2LNqAsm_16 : NEONDataTypeAsmPseudoInst<"vld2${p}", ".16", "$list, $addr",
                 (ins VecListTwoQHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD2LNqAsm_32 : NEONDataTypeAsmPseudoInst<"vld2${p}", ".32", "$list, $addr",
                 (ins VecListTwoQWordIndexed:$list, addrmode6:$addr, pred:$p)>;

def VLD2LNdWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld2${p}", ".8", "$list, $addr!",
                 (ins VecListTwoDByteIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD2LNdWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld2${p}", ".16", "$list, $addr!",
                 (ins VecListTwoDHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD2LNdWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld2${p}", ".32", "$list, $addr!",
                 (ins VecListTwoDWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD2LNqWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld2${p}", ".16", "$list, $addr!",
                 (ins VecListTwoQHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD2LNqWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld2${p}", ".32", "$list, $addr!",
                 (ins VecListTwoQWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD2LNdWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld2${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListTwoDByteIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD2LNdWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld2${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListTwoDHWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD2LNdWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld2${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListTwoDWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD2LNqWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld2${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListTwoQHWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD2LNqWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld2${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListTwoQWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;


// VST2 single-lane pseudo-instructions. These need special handling for
// the lane index that an InstAlias can't handle, so we use these instead.
def VST2LNdAsm_8 : NEONDataTypeAsmPseudoInst<"vst2${p}", ".8", "$list, $addr",
                 (ins VecListTwoDByteIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST2LNdAsm_16 : NEONDataTypeAsmPseudoInst<"vst2${p}", ".16", "$list, $addr",
                 (ins VecListTwoDHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST2LNdAsm_32 : NEONDataTypeAsmPseudoInst<"vst2${p}", ".32", "$list, $addr",
                 (ins VecListTwoDWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST2LNqAsm_16 : NEONDataTypeAsmPseudoInst<"vst2${p}", ".16", "$list, $addr",
                 (ins VecListTwoQHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST2LNqAsm_32 : NEONDataTypeAsmPseudoInst<"vst2${p}", ".32", "$list, $addr",
                 (ins VecListTwoQWordIndexed:$list, addrmode6:$addr, pred:$p)>;

def VST2LNdWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vst2${p}", ".8", "$list, $addr!",
                 (ins VecListTwoDByteIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST2LNdWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst2${p}", ".16", "$list, $addr!",
                 (ins VecListTwoDHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST2LNdWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst2${p}", ".32", "$list, $addr!",
                 (ins VecListTwoDWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST2LNqWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst2${p}", ".16", "$list, $addr!",
                 (ins VecListTwoQHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST2LNqWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst2${p}", ".32", "$list, $addr!",
                 (ins VecListTwoQWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST2LNdWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vst2${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListTwoDByteIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST2LNdWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst2${p}", ".16","$list, $addr, $Rm",
                  (ins VecListTwoDHWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST2LNdWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst2${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListTwoDWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST2LNqWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst2${p}", ".16","$list, $addr, $Rm",
                  (ins VecListTwoQHWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST2LNqWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst2${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListTwoQWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;

// VLD3 all-lanes pseudo-instructions. These need special handling for
// the lane index that an InstAlias can't handle, so we use these instead.
def VLD3DUPdAsm_8 : NEONDataTypeAsmPseudoInst<"vld3${p}", ".8", "$list, $addr",
               (ins VecListThreeDAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD3DUPdAsm_16: NEONDataTypeAsmPseudoInst<"vld3${p}", ".16", "$list, $addr",
               (ins VecListThreeDAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD3DUPdAsm_32: NEONDataTypeAsmPseudoInst<"vld3${p}", ".32", "$list, $addr",
               (ins VecListThreeDAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD3DUPqAsm_8 : NEONDataTypeAsmPseudoInst<"vld3${p}", ".8", "$list, $addr",
               (ins VecListThreeQAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD3DUPqAsm_16: NEONDataTypeAsmPseudoInst<"vld3${p}", ".16", "$list, $addr",
               (ins VecListThreeQAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD3DUPqAsm_32: NEONDataTypeAsmPseudoInst<"vld3${p}", ".32", "$list, $addr",
               (ins VecListThreeQAllLanes:$list, addrmode6:$addr, pred:$p)>;

def VLD3DUPdWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".8", "$list, $addr!",
               (ins VecListThreeDAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD3DUPdWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".16", "$list, $addr!",
               (ins VecListThreeDAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD3DUPdWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".32", "$list, $addr!",
               (ins VecListThreeDAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD3DUPqWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".8", "$list, $addr!",
               (ins VecListThreeQAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD3DUPqWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".16", "$list, $addr!",
               (ins VecListThreeQAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD3DUPqWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".32", "$list, $addr!",
               (ins VecListThreeQAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD3DUPdWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListThreeDAllLanes:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD3DUPdWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListThreeDAllLanes:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD3DUPdWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListThreeDAllLanes:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD3DUPqWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListThreeQAllLanes:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD3DUPqWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListThreeQAllLanes:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD3DUPqWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListThreeQAllLanes:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;


// VLD3 single-lane pseudo-instructions. These need special handling for
// the lane index that an InstAlias can't handle, so we use these instead.
def VLD3LNdAsm_8 : NEONDataTypeAsmPseudoInst<"vld3${p}", ".8", "$list, $addr",
               (ins VecListThreeDByteIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD3LNdAsm_16 : NEONDataTypeAsmPseudoInst<"vld3${p}", ".16", "$list, $addr",
               (ins VecListThreeDHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD3LNdAsm_32 : NEONDataTypeAsmPseudoInst<"vld3${p}", ".32", "$list, $addr",
               (ins VecListThreeDWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD3LNqAsm_16 : NEONDataTypeAsmPseudoInst<"vld3${p}", ".16", "$list, $addr",
               (ins VecListThreeQHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD3LNqAsm_32 : NEONDataTypeAsmPseudoInst<"vld3${p}", ".32", "$list, $addr",
               (ins VecListThreeQWordIndexed:$list, addrmode6:$addr, pred:$p)>;

def VLD3LNdWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".8", "$list, $addr!",
               (ins VecListThreeDByteIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD3LNdWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".16", "$list, $addr!",
               (ins VecListThreeDHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD3LNdWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".32", "$list, $addr!",
               (ins VecListThreeDWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD3LNqWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".16", "$list, $addr!",
               (ins VecListThreeQHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD3LNqWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".32", "$list, $addr!",
               (ins VecListThreeQWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD3LNdWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListThreeDByteIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD3LNdWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListThreeDHWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD3LNdWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListThreeDWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD3LNqWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListThreeQHWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD3LNqWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListThreeQWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;

// VLD3 multiple structure pseudo-instructions. These need special handling for
// the vector operands that the normal instructions don't yet model.
// FIXME: Remove these when the register classes and instructions are updated.
def VLD3dAsm_8 : NEONDataTypeAsmPseudoInst<"vld3${p}", ".8", "$list, $addr",
               (ins VecListThreeD:$list, addrmode6:$addr, pred:$p)>;
def VLD3dAsm_16 : NEONDataTypeAsmPseudoInst<"vld3${p}", ".16", "$list, $addr",
               (ins VecListThreeD:$list, addrmode6:$addr, pred:$p)>;
def VLD3dAsm_32 : NEONDataTypeAsmPseudoInst<"vld3${p}", ".32", "$list, $addr",
               (ins VecListThreeD:$list, addrmode6:$addr, pred:$p)>;
def VLD3qAsm_8 : NEONDataTypeAsmPseudoInst<"vld3${p}", ".8", "$list, $addr",
               (ins VecListThreeQ:$list, addrmode6:$addr, pred:$p)>;
def VLD3qAsm_16 : NEONDataTypeAsmPseudoInst<"vld3${p}", ".16", "$list, $addr",
               (ins VecListThreeQ:$list, addrmode6:$addr, pred:$p)>;
def VLD3qAsm_32 : NEONDataTypeAsmPseudoInst<"vld3${p}", ".32", "$list, $addr",
               (ins VecListThreeQ:$list, addrmode6:$addr, pred:$p)>;

def VLD3dWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".8", "$list, $addr!",
               (ins VecListThreeD:$list, addrmode6:$addr, pred:$p)>;
def VLD3dWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".16", "$list, $addr!",
               (ins VecListThreeD:$list, addrmode6:$addr, pred:$p)>;
def VLD3dWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".32", "$list, $addr!",
               (ins VecListThreeD:$list, addrmode6:$addr, pred:$p)>;
def VLD3qWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".8", "$list, $addr!",
               (ins VecListThreeQ:$list, addrmode6:$addr, pred:$p)>;
def VLD3qWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".16", "$list, $addr!",
               (ins VecListThreeQ:$list, addrmode6:$addr, pred:$p)>;
def VLD3qWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".32", "$list, $addr!",
               (ins VecListThreeQ:$list, addrmode6:$addr, pred:$p)>;
def VLD3dWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListThreeD:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD3dWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListThreeD:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD3dWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListThreeD:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD3qWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListThreeQ:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD3qWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListThreeQ:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD3qWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld3${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListThreeQ:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;

// VST3 single-lane pseudo-instructions. These need special handling for
// the lane index that an InstAlias can't handle, so we use these instead.
def VST3LNdAsm_8 : NEONDataTypeAsmPseudoInst<"vst3${p}", ".8", "$list, $addr",
               (ins VecListThreeDByteIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST3LNdAsm_16 : NEONDataTypeAsmPseudoInst<"vst3${p}", ".16", "$list, $addr",
               (ins VecListThreeDHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST3LNdAsm_32 : NEONDataTypeAsmPseudoInst<"vst3${p}", ".32", "$list, $addr",
               (ins VecListThreeDWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST3LNqAsm_16 : NEONDataTypeAsmPseudoInst<"vst3${p}", ".16", "$list, $addr",
               (ins VecListThreeQHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST3LNqAsm_32 : NEONDataTypeAsmPseudoInst<"vst3${p}", ".32", "$list, $addr",
               (ins VecListThreeQWordIndexed:$list, addrmode6:$addr, pred:$p)>;

def VST3LNdWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".8", "$list, $addr!",
               (ins VecListThreeDByteIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST3LNdWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".16", "$list, $addr!",
               (ins VecListThreeDHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST3LNdWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".32", "$list, $addr!",
               (ins VecListThreeDWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST3LNqWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".16", "$list, $addr!",
               (ins VecListThreeQHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST3LNqWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".32", "$list, $addr!",
               (ins VecListThreeQWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST3LNdWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListThreeDByteIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST3LNdWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListThreeDHWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST3LNdWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListThreeDWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST3LNqWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListThreeQHWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST3LNqWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListThreeQWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;


// VST3 multiple structure pseudo-instructions. These need special handling for
// the vector operands that the normal instructions don't yet model.
// FIXME: Remove these when the register classes and instructions are updated.
def VST3dAsm_8 : NEONDataTypeAsmPseudoInst<"vst3${p}", ".8", "$list, $addr",
               (ins VecListThreeD:$list, addrmode6:$addr, pred:$p)>;
def VST3dAsm_16 : NEONDataTypeAsmPseudoInst<"vst3${p}", ".16", "$list, $addr",
               (ins VecListThreeD:$list, addrmode6:$addr, pred:$p)>;
def VST3dAsm_32 : NEONDataTypeAsmPseudoInst<"vst3${p}", ".32", "$list, $addr",
               (ins VecListThreeD:$list, addrmode6:$addr, pred:$p)>;
def VST3qAsm_8 : NEONDataTypeAsmPseudoInst<"vst3${p}", ".8", "$list, $addr",
               (ins VecListThreeQ:$list, addrmode6:$addr, pred:$p)>;
def VST3qAsm_16 : NEONDataTypeAsmPseudoInst<"vst3${p}", ".16", "$list, $addr",
               (ins VecListThreeQ:$list, addrmode6:$addr, pred:$p)>;
def VST3qAsm_32 : NEONDataTypeAsmPseudoInst<"vst3${p}", ".32", "$list, $addr",
               (ins VecListThreeQ:$list, addrmode6:$addr, pred:$p)>;

def VST3dWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".8", "$list, $addr!",
               (ins VecListThreeD:$list, addrmode6:$addr, pred:$p)>;
def VST3dWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".16", "$list, $addr!",
               (ins VecListThreeD:$list, addrmode6:$addr, pred:$p)>;
def VST3dWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".32", "$list, $addr!",
               (ins VecListThreeD:$list, addrmode6:$addr, pred:$p)>;
def VST3qWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".8", "$list, $addr!",
               (ins VecListThreeQ:$list, addrmode6:$addr, pred:$p)>;
def VST3qWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".16", "$list, $addr!",
               (ins VecListThreeQ:$list, addrmode6:$addr, pred:$p)>;
def VST3qWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".32", "$list, $addr!",
               (ins VecListThreeQ:$list, addrmode6:$addr, pred:$p)>;
def VST3dWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListThreeD:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST3dWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListThreeD:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST3dWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListThreeD:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST3qWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListThreeQ:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST3qWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListThreeQ:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST3qWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst3${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListThreeQ:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;

// VLD4 all-lanes pseudo-instructions. These need special handling for
// the lane index that an InstAlias can't handle, so we use these instead.
def VLD4DUPdAsm_8 : NEONDataTypeAsmPseudoInst<"vld4${p}", ".8", "$list, $addr",
               (ins VecListFourDAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD4DUPdAsm_16: NEONDataTypeAsmPseudoInst<"vld4${p}", ".16", "$list, $addr",
               (ins VecListFourDAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD4DUPdAsm_32: NEONDataTypeAsmPseudoInst<"vld4${p}", ".32", "$list, $addr",
               (ins VecListFourDAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD4DUPqAsm_8 : NEONDataTypeAsmPseudoInst<"vld4${p}", ".8", "$list, $addr",
               (ins VecListFourQAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD4DUPqAsm_16: NEONDataTypeAsmPseudoInst<"vld4${p}", ".16", "$list, $addr",
               (ins VecListFourQAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD4DUPqAsm_32: NEONDataTypeAsmPseudoInst<"vld4${p}", ".32", "$list, $addr",
               (ins VecListFourQAllLanes:$list, addrmode6:$addr, pred:$p)>;

def VLD4DUPdWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".8", "$list, $addr!",
               (ins VecListFourDAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD4DUPdWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".16", "$list, $addr!",
               (ins VecListFourDAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD4DUPdWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".32", "$list, $addr!",
               (ins VecListFourDAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD4DUPqWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".8", "$list, $addr!",
               (ins VecListFourQAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD4DUPqWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".16", "$list, $addr!",
               (ins VecListFourQAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD4DUPqWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".32", "$list, $addr!",
               (ins VecListFourQAllLanes:$list, addrmode6:$addr, pred:$p)>;
def VLD4DUPdWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListFourDAllLanes:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD4DUPdWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListFourDAllLanes:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD4DUPdWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListFourDAllLanes:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD4DUPqWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListFourQAllLanes:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD4DUPqWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListFourQAllLanes:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD4DUPqWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListFourQAllLanes:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;


// VLD4 single-lane pseudo-instructions. These need special handling for
// the lane index that an InstAlias can't handle, so we use these instead.
def VLD4LNdAsm_8 : NEONDataTypeAsmPseudoInst<"vld4${p}", ".8", "$list, $addr",
               (ins VecListFourDByteIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD4LNdAsm_16 : NEONDataTypeAsmPseudoInst<"vld4${p}", ".16", "$list, $addr",
               (ins VecListFourDHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD4LNdAsm_32 : NEONDataTypeAsmPseudoInst<"vld4${p}", ".32", "$list, $addr",
               (ins VecListFourDWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD4LNqAsm_16 : NEONDataTypeAsmPseudoInst<"vld4${p}", ".16", "$list, $addr",
               (ins VecListFourQHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD4LNqAsm_32 : NEONDataTypeAsmPseudoInst<"vld4${p}", ".32", "$list, $addr",
               (ins VecListFourQWordIndexed:$list, addrmode6:$addr, pred:$p)>;

def VLD4LNdWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".8", "$list, $addr!",
               (ins VecListFourDByteIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD4LNdWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".16", "$list, $addr!",
               (ins VecListFourDHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD4LNdWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".32", "$list, $addr!",
               (ins VecListFourDWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD4LNqWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".16", "$list, $addr!",
               (ins VecListFourQHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD4LNqWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".32", "$list, $addr!",
               (ins VecListFourQWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VLD4LNdWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListFourDByteIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD4LNdWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListFourDHWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD4LNdWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListFourDWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD4LNqWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListFourQHWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD4LNqWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListFourQWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;



// VLD4 multiple structure pseudo-instructions. These need special handling for
// the vector operands that the normal instructions don't yet model.
// FIXME: Remove these when the register classes and instructions are updated.
def VLD4dAsm_8 : NEONDataTypeAsmPseudoInst<"vld4${p}", ".8", "$list, $addr",
               (ins VecListFourD:$list, addrmode6:$addr, pred:$p)>;
def VLD4dAsm_16 : NEONDataTypeAsmPseudoInst<"vld4${p}", ".16", "$list, $addr",
               (ins VecListFourD:$list, addrmode6:$addr, pred:$p)>;
def VLD4dAsm_32 : NEONDataTypeAsmPseudoInst<"vld4${p}", ".32", "$list, $addr",
               (ins VecListFourD:$list, addrmode6:$addr, pred:$p)>;
def VLD4qAsm_8 : NEONDataTypeAsmPseudoInst<"vld4${p}", ".8", "$list, $addr",
               (ins VecListFourQ:$list, addrmode6:$addr, pred:$p)>;
def VLD4qAsm_16 : NEONDataTypeAsmPseudoInst<"vld4${p}", ".16", "$list, $addr",
               (ins VecListFourQ:$list, addrmode6:$addr, pred:$p)>;
def VLD4qAsm_32 : NEONDataTypeAsmPseudoInst<"vld4${p}", ".32", "$list, $addr",
               (ins VecListFourQ:$list, addrmode6:$addr, pred:$p)>;

def VLD4dWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".8", "$list, $addr!",
               (ins VecListFourD:$list, addrmode6:$addr, pred:$p)>;
def VLD4dWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".16", "$list, $addr!",
               (ins VecListFourD:$list, addrmode6:$addr, pred:$p)>;
def VLD4dWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".32", "$list, $addr!",
               (ins VecListFourD:$list, addrmode6:$addr, pred:$p)>;
def VLD4qWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".8", "$list, $addr!",
               (ins VecListFourQ:$list, addrmode6:$addr, pred:$p)>;
def VLD4qWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".16", "$list, $addr!",
               (ins VecListFourQ:$list, addrmode6:$addr, pred:$p)>;
def VLD4qWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".32", "$list, $addr!",
               (ins VecListFourQ:$list, addrmode6:$addr, pred:$p)>;
def VLD4dWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListFourD:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD4dWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListFourD:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD4dWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListFourD:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD4qWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListFourQ:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD4qWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListFourQ:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VLD4qWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vld4${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListFourQ:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;

// VST4 single-lane pseudo-instructions. These need special handling for
// the lane index that an InstAlias can't handle, so we use these instead.
def VST4LNdAsm_8 : NEONDataTypeAsmPseudoInst<"vst4${p}", ".8", "$list, $addr",
               (ins VecListFourDByteIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST4LNdAsm_16 : NEONDataTypeAsmPseudoInst<"vst4${p}", ".16", "$list, $addr",
               (ins VecListFourDHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST4LNdAsm_32 : NEONDataTypeAsmPseudoInst<"vst4${p}", ".32", "$list, $addr",
               (ins VecListFourDWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST4LNqAsm_16 : NEONDataTypeAsmPseudoInst<"vst4${p}", ".16", "$list, $addr",
               (ins VecListFourQHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST4LNqAsm_32 : NEONDataTypeAsmPseudoInst<"vst4${p}", ".32", "$list, $addr",
               (ins VecListFourQWordIndexed:$list, addrmode6:$addr, pred:$p)>;

def VST4LNdWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".8", "$list, $addr!",
               (ins VecListFourDByteIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST4LNdWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".16", "$list, $addr!",
               (ins VecListFourDHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST4LNdWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".32", "$list, $addr!",
               (ins VecListFourDWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST4LNqWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".16", "$list, $addr!",
               (ins VecListFourQHWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST4LNqWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".32", "$list, $addr!",
               (ins VecListFourQWordIndexed:$list, addrmode6:$addr, pred:$p)>;
def VST4LNdWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListFourDByteIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST4LNdWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListFourDHWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST4LNdWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListFourDWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST4LNqWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListFourQHWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST4LNqWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListFourQWordIndexed:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;


// VST4 multiple structure pseudo-instructions. These need special handling for
// the vector operands that the normal instructions don't yet model.
// FIXME: Remove these when the register classes and instructions are updated.
def VST4dAsm_8 : NEONDataTypeAsmPseudoInst<"vst4${p}", ".8", "$list, $addr",
               (ins VecListFourD:$list, addrmode6:$addr, pred:$p)>;
def VST4dAsm_16 : NEONDataTypeAsmPseudoInst<"vst4${p}", ".16", "$list, $addr",
               (ins VecListFourD:$list, addrmode6:$addr, pred:$p)>;
def VST4dAsm_32 : NEONDataTypeAsmPseudoInst<"vst4${p}", ".32", "$list, $addr",
               (ins VecListFourD:$list, addrmode6:$addr, pred:$p)>;
def VST4qAsm_8 : NEONDataTypeAsmPseudoInst<"vst4${p}", ".8", "$list, $addr",
               (ins VecListFourQ:$list, addrmode6:$addr, pred:$p)>;
def VST4qAsm_16 : NEONDataTypeAsmPseudoInst<"vst4${p}", ".16", "$list, $addr",
               (ins VecListFourQ:$list, addrmode6:$addr, pred:$p)>;
def VST4qAsm_32 : NEONDataTypeAsmPseudoInst<"vst4${p}", ".32", "$list, $addr",
               (ins VecListFourQ:$list, addrmode6:$addr, pred:$p)>;

def VST4dWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".8", "$list, $addr!",
               (ins VecListFourD:$list, addrmode6:$addr, pred:$p)>;
def VST4dWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".16", "$list, $addr!",
               (ins VecListFourD:$list, addrmode6:$addr, pred:$p)>;
def VST4dWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".32", "$list, $addr!",
               (ins VecListFourD:$list, addrmode6:$addr, pred:$p)>;
def VST4qWB_fixed_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".8", "$list, $addr!",
               (ins VecListFourQ:$list, addrmode6:$addr, pred:$p)>;
def VST4qWB_fixed_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".16", "$list, $addr!",
               (ins VecListFourQ:$list, addrmode6:$addr, pred:$p)>;
def VST4qWB_fixed_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".32", "$list, $addr!",
               (ins VecListFourQ:$list, addrmode6:$addr, pred:$p)>;
def VST4dWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListFourD:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST4dWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListFourD:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST4dWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListFourD:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST4qWB_register_Asm_8 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".8", "$list, $addr, $Rm",
                  (ins VecListFourQ:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST4qWB_register_Asm_16 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".16", "$list, $addr, $Rm",
                  (ins VecListFourQ:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;
def VST4qWB_register_Asm_32 :
        NEONDataTypeAsmPseudoInst<"vst4${p}", ".32", "$list, $addr, $Rm",
                  (ins VecListFourQ:$list, addrmode6:$addr,
                       rGPR:$Rm, pred:$p)>;

// VMOV takes an optional datatype suffix
defm : NEONDTAnyInstAlias<"vmov${p}", "$Vd, $Vm",
                         (VORRd DPR:$Vd, DPR:$Vm, DPR:$Vm, pred:$p)>;
defm : NEONDTAnyInstAlias<"vmov${p}", "$Vd, $Vm",
                         (VORRq QPR:$Vd, QPR:$Vm, QPR:$Vm, pred:$p)>;

// VCLT (register) is an assembler alias for VCGT w/ the operands reversed.
// D-register versions.
def : NEONInstAlias<"vcle${p}.s8 $Dd, $Dn, $Dm",
                    (VCGEsv8i8 DPR:$Dd, DPR:$Dm, DPR:$Dn, pred:$p)>;
def : NEONInstAlias<"vcle${p}.s16 $Dd, $Dn, $Dm",
                    (VCGEsv4i16 DPR:$Dd, DPR:$Dm, DPR:$Dn, pred:$p)>;
def : NEONInstAlias<"vcle${p}.s32 $Dd, $Dn, $Dm",
                    (VCGEsv2i32 DPR:$Dd, DPR:$Dm, DPR:$Dn, pred:$p)>;
def : NEONInstAlias<"vcle${p}.u8 $Dd, $Dn, $Dm",
                    (VCGEuv8i8 DPR:$Dd, DPR:$Dm, DPR:$Dn, pred:$p)>;
def : NEONInstAlias<"vcle${p}.u16 $Dd, $Dn, $Dm",
                    (VCGEuv4i16 DPR:$Dd, DPR:$Dm, DPR:$Dn, pred:$p)>;
def : NEONInstAlias<"vcle${p}.u32 $Dd, $Dn, $Dm",
                    (VCGEuv2i32 DPR:$Dd, DPR:$Dm, DPR:$Dn, pred:$p)>;
def : NEONInstAlias<"vcle${p}.f32 $Dd, $Dn, $Dm",
                    (VCGEfd DPR:$Dd, DPR:$Dm, DPR:$Dn, pred:$p)>;
// Q-register versions.
def : NEONInstAlias<"vcle${p}.s8 $Qd, $Qn, $Qm",
                    (VCGEsv16i8 QPR:$Qd, QPR:$Qm, QPR:$Qn, pred:$p)>;
def : NEONInstAlias<"vcle${p}.s16 $Qd, $Qn, $Qm",
                    (VCGEsv8i16 QPR:$Qd, QPR:$Qm, QPR:$Qn, pred:$p)>;
def : NEONInstAlias<"vcle${p}.s32 $Qd, $Qn, $Qm",
                    (VCGEsv4i32 QPR:$Qd, QPR:$Qm, QPR:$Qn, pred:$p)>;
def : NEONInstAlias<"vcle${p}.u8 $Qd, $Qn, $Qm",
                    (VCGEuv16i8 QPR:$Qd, QPR:$Qm, QPR:$Qn, pred:$p)>;
def : NEONInstAlias<"vcle${p}.u16 $Qd, $Qn, $Qm",
                    (VCGEuv8i16 QPR:$Qd, QPR:$Qm, QPR:$Qn, pred:$p)>;
def : NEONInstAlias<"vcle${p}.u32 $Qd, $Qn, $Qm",
                    (VCGEuv4i32 QPR:$Qd, QPR:$Qm, QPR:$Qn, pred:$p)>;
def : NEONInstAlias<"vcle${p}.f32 $Qd, $Qn, $Qm",
                    (VCGEfq QPR:$Qd, QPR:$Qm, QPR:$Qn, pred:$p)>;

// VCLT (register) is an assembler alias for VCGT w/ the operands reversed.
// D-register versions.
def : NEONInstAlias<"vclt${p}.s8 $Dd, $Dn, $Dm",
                    (VCGTsv8i8 DPR:$Dd, DPR:$Dm, DPR:$Dn, pred:$p)>;
def : NEONInstAlias<"vclt${p}.s16 $Dd, $Dn, $Dm",
                    (VCGTsv4i16 DPR:$Dd, DPR:$Dm, DPR:$Dn, pred:$p)>;
def : NEONInstAlias<"vclt${p}.s32 $Dd, $Dn, $Dm",
                    (VCGTsv2i32 DPR:$Dd, DPR:$Dm, DPR:$Dn, pred:$p)>;
def : NEONInstAlias<"vclt${p}.u8 $Dd, $Dn, $Dm",
                    (VCGTuv8i8 DPR:$Dd, DPR:$Dm, DPR:$Dn, pred:$p)>;
def : NEONInstAlias<"vclt${p}.u16 $Dd, $Dn, $Dm",
                    (VCGTuv4i16 DPR:$Dd, DPR:$Dm, DPR:$Dn, pred:$p)>;
def : NEONInstAlias<"vclt${p}.u32 $Dd, $Dn, $Dm",
                    (VCGTuv2i32 DPR:$Dd, DPR:$Dm, DPR:$Dn, pred:$p)>;
def : NEONInstAlias<"vclt${p}.f32 $Dd, $Dn, $Dm",
                    (VCGTfd DPR:$Dd, DPR:$Dm, DPR:$Dn, pred:$p)>;
// Q-register versions.
def : NEONInstAlias<"vclt${p}.s8 $Qd, $Qn, $Qm",
                    (VCGTsv16i8 QPR:$Qd, QPR:$Qm, QPR:$Qn, pred:$p)>;
def : NEONInstAlias<"vclt${p}.s16 $Qd, $Qn, $Qm",
                    (VCGTsv8i16 QPR:$Qd, QPR:$Qm, QPR:$Qn, pred:$p)>;
def : NEONInstAlias<"vclt${p}.s32 $Qd, $Qn, $Qm",
                    (VCGTsv4i32 QPR:$Qd, QPR:$Qm, QPR:$Qn, pred:$p)>;
def : NEONInstAlias<"vclt${p}.u8 $Qd, $Qn, $Qm",
                    (VCGTuv16i8 QPR:$Qd, QPR:$Qm, QPR:$Qn, pred:$p)>;
def : NEONInstAlias<"vclt${p}.u16 $Qd, $Qn, $Qm",
                    (VCGTuv8i16 QPR:$Qd, QPR:$Qm, QPR:$Qn, pred:$p)>;
def : NEONInstAlias<"vclt${p}.u32 $Qd, $Qn, $Qm",
                    (VCGTuv4i32 QPR:$Qd, QPR:$Qm, QPR:$Qn, pred:$p)>;
def : NEONInstAlias<"vclt${p}.f32 $Qd, $Qn, $Qm",
                    (VCGTfq QPR:$Qd, QPR:$Qm, QPR:$Qn, pred:$p)>;

// VSWP allows, but does not require, a type suffix.
defm : NEONDTAnyInstAlias<"vswp${p}", "$Vd, $Vm",
                         (VSWPd DPR:$Vd, DPR:$Vm, pred:$p)>;
defm : NEONDTAnyInstAlias<"vswp${p}", "$Vd, $Vm",
                         (VSWPq QPR:$Vd, QPR:$Vm, pred:$p)>;

// VBIF, VBIT, and VBSL allow, but do not require, a type suffix.
defm : NEONDTAnyInstAlias<"vbif${p}", "$Vd, $Vn, $Vm",
                         (VBIFd DPR:$Vd, DPR:$Vn, DPR:$Vm, pred:$p)>;
defm : NEONDTAnyInstAlias<"vbit${p}", "$Vd, $Vn, $Vm",
                         (VBITd DPR:$Vd, DPR:$Vn, DPR:$Vm, pred:$p)>;
defm : NEONDTAnyInstAlias<"vbsl${p}", "$Vd, $Vn, $Vm",
                         (VBSLd DPR:$Vd, DPR:$Vn, DPR:$Vm, pred:$p)>;
defm : NEONDTAnyInstAlias<"vbif${p}", "$Vd, $Vn, $Vm",
                         (VBIFq QPR:$Vd, QPR:$Vn, QPR:$Vm, pred:$p)>;
defm : NEONDTAnyInstAlias<"vbit${p}", "$Vd, $Vn, $Vm",
                         (VBITq QPR:$Vd, QPR:$Vn, QPR:$Vm, pred:$p)>;
defm : NEONDTAnyInstAlias<"vbsl${p}", "$Vd, $Vn, $Vm",
                         (VBSLq QPR:$Vd, QPR:$Vn, QPR:$Vm, pred:$p)>;

// "vmov Rd, #-imm" can be handled via "vmvn".
def : NEONInstAlias<"vmov${p}.i32 $Vd, $imm",
                    (VMVNv2i32 DPR:$Vd, nImmVMOVI32Neg:$imm, pred:$p)>;
def : NEONInstAlias<"vmov${p}.i32 $Vd, $imm",
                    (VMVNv4i32 QPR:$Vd, nImmVMOVI32Neg:$imm, pred:$p)>;
def : NEONInstAlias<"vmvn${p}.i32 $Vd, $imm",
                    (VMOVv2i32 DPR:$Vd, nImmVMOVI32Neg:$imm, pred:$p)>;
def : NEONInstAlias<"vmvn${p}.i32 $Vd, $imm",
                    (VMOVv4i32 QPR:$Vd, nImmVMOVI32Neg:$imm, pred:$p)>;

// 'gas' compatibility aliases for quad-word instructions. Strictly speaking,
// these should restrict to just the Q register variants, but the register
// classes are enough to match correctly regardless, so we keep it simple
// and just use MnemonicAlias.
def : NEONMnemonicAlias<"vbicq", "vbic">;
def : NEONMnemonicAlias<"vandq", "vand">;
def : NEONMnemonicAlias<"veorq", "veor">;
def : NEONMnemonicAlias<"vorrq", "vorr">;

def : NEONMnemonicAlias<"vmovq", "vmov">;
def : NEONMnemonicAlias<"vmvnq", "vmvn">;
// Explicit versions for floating point so that the FPImm variants get
// handled early. The parser gets confused otherwise.
def : NEONMnemonicAlias<"vmovq.f32", "vmov.f32">;
def : NEONMnemonicAlias<"vmovq.f64", "vmov.f64">;

def : NEONMnemonicAlias<"vaddq", "vadd">;
def : NEONMnemonicAlias<"vsubq", "vsub">;

def : NEONMnemonicAlias<"vminq", "vmin">;
def : NEONMnemonicAlias<"vmaxq", "vmax">;

def : NEONMnemonicAlias<"vmulq", "vmul">;

def : NEONMnemonicAlias<"vabsq", "vabs">;

def : NEONMnemonicAlias<"vshlq", "vshl">;
def : NEONMnemonicAlias<"vshrq", "vshr">;

def : NEONMnemonicAlias<"vcvtq", "vcvt">;

def : NEONMnemonicAlias<"vcleq", "vcle">;
def : NEONMnemonicAlias<"vceqq", "vceq">;

def : NEONMnemonicAlias<"vzipq", "vzip">;
def : NEONMnemonicAlias<"vswpq", "vswp">;

def : NEONMnemonicAlias<"vrecpeq.f32", "vrecpe.f32">;
def : NEONMnemonicAlias<"vrecpeq.u32", "vrecpe.u32">;


// Alias for loading floating point immediates that aren't representable
// using the vmov.f32 encoding but the bitpattern is representable using
// the .i32 encoding.
def : NEONInstAlias<"vmov${p}.f32 $Vd, $imm",
                     (VMOVv4i32 QPR:$Vd, nImmVMOVI32:$imm, pred:$p)>;
def : NEONInstAlias<"vmov${p}.f32 $Vd, $imm",
                     (VMOVv2i32 DPR:$Vd, nImmVMOVI32:$imm, pred:$p)>;

